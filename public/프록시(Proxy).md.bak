안녕하세요. 이번 시간에는 네트워크 아키텍처를 이야기할 때 빼놓을 수 없는 핵심 요소인 **프록시(Proxy)**에 대해 알아보겠습니다. Proxy는 '대리', '대리인'이라는 뜻을 가지고 있습니다. 이름 그대로, 프록시 서버는 클라이언트와 서버 사이에서 무언가를 대신 처리해주는 **중개자** 역할을 수행합니다.

사용자(클라이언트)가 어떤 웹사이트(서버)에 직접 접속하지 않고, 중간에 있는 프록시 서버를 통해 접속하는 구조입니다.

```mermaid
graph LR
    Client[<i class="fa fa-user"></i> 클라이언트] <--> Proxy[프록시 서버] <--> Server[<i class="fa fa-server"></i> 원본 서버]
```

하지만 모든 프록시가 똑같은 역할을 하는 것은 아닙니다. 누구를 위해, 어떤 방향으로 대리인 역할을 하느냐에 따라 크게 **포워드 프록시(Forward Proxy)**와 **리버스 프록시(Reverse Proxy)**로 나뉩니다. 이 둘의 차이점을 이해하는 것이 프록시를 제대로 이해하는 핵심입니다.

---

## 1. 포워드 프록시 (Forward Proxy): 클라이언트의 대리인

포워드 프록시는 **클라이언트를 대리**합니다. 주로 내부 네트워크에 있는 클라이언트들이 인터넷과 같은 외부 네트워크에 접속할 때 거치게 되는 서버입니다.


```mermaid
graph TD
    subgraph "내부 네트워크 (Private Network)"
        Client1[클라이언트 1] --> FProxy
        Client2[클라이언트 2] --> FProxy(<b>포워드 프록시</b>)
        Client3[클라이언트 3] --> FProxy
    end

    FProxy -- "클라이언트들을 대신하여 요청" --> Internet[<i class="fa fa-cloud"></i> 인터넷/외부 서버]

    subgraph "외부 서버"
        Internet -- "응답" --> FProxy
    end
    
    FProxy -- "응답 전달" --> Client1
    FProxy -- "응답 전달" --> Client2
    FProxy -- "응답 전달" --> Client3

```

위 그림처럼, 외부 서버(예: https://www.google.com/search?q=google.com) 입장에서 보면 모든 요청은 포워드 프록시 서버로부터 온 것으로 보입니다. 실제 요청을 보낸 클라이언트의 정보는 숨겨지게 되죠.

### 주요 사용 목적

- **보안 및 접근 제어**: 회사나 학교와 같은 내부망에서 특정 웹사이트(예: 유튜브, 소셜 미디어)에 접속하는 것을 막는 방화벽 역할을 할 수 있습니다. 포워드 프록시에서 해당 사이트로의 요청을 차단하면 되기 때문입니다.
- **[[캐싱(Caching)]]]**: 여러 클라이언트가 동일한 콘텐츠를 요청할 경우, 포워드 프록시는 해당 내용을 캐시에 저장해 둡니다. 이후 같은 요청이 들어오면 원본 서버까지 가지 않고 캐시에서 바로 응답하여 속도를 향상시킵니다.
- **익명성**: 클라이언트의 IP 주소를 숨기고 프록시 서버의 IP 주소로 외부와 통신하므로, 클라이언트의 익명성을 보장할 수 있습니다.

---

## 2. 리버스 프록시 (Reverse Proxy): 서버의 대리인

리버스 프록시는 포워드 프록시와 정반대로 **서버를 대리**합니다. 클라이언트가 인터넷을 통해 내부 네트워크의 서버에 접근할 때, 그 요청을 대신 받는 역할을 합니다.

```mermaid
graph TD
    subgraph "인터넷 (Public Network)"
        Client1[<i class="fa fa-user"></i> 클라이언트 1] --> RProxy
        Client2[<i class="fa fa-user"></i> 클라이언트 2] --> RProxy(<b>리버스 프록시</b>)
    end
    
    subgraph "내부 서버 인프라 (Private Network)"
        RProxy -- "요청을 적절한 서버로 분배" --> Server1[웹 서버 1]
        RProxy --> Server2[웹 서버 2]
        RProxy --> WAS[WAS 서버]
    end
```

클라이언트 입장에서는 리버스 프록시 서버가 실제 서버라고 생각하고 요청을 보냅니다. 하지만 리버스 프록시는 그 요청을 받아 내부의 여러 서버 중 하나에게 전달하고, 응답을 다시 클라이언트에게 반환해 줍니다. 클라이언트는 배후에 실제 서버들이 몇 대가 있는지, 어떤 구조로 되어 있는지 전혀 알 수 없습니다.

### 주요 사용 목적

이 구조가 낯설지 않으실 겁니다. 바로 이전에 다루었던 [[로드 밸런서(Load Balancer)]]가 리버스 프록시 방식으로 동작하기 때문입니다.

- **[[로드 밸런서(Load Balancer)]]**: 가장 대표적인 역할입니다. 여러 대의 백엔드 서버에 트래픽을 분산하여 서버 부하를 줄이고 가용성을 높입니다.
- **보안**: 실제 서버의 IP 주소와 아키텍처를 외부에 숨길 수 있어 보안성이 향상됩니다. 또한 리버스 프록시 단에서 악의적인 요청을 필터링하는 웹 방화벽([[WAF]])의 역할을 수행할 수도 있습니다.
- **[[SSL/TLS Termination]]**: 클라이언트와의 HTTPS 통신을 위한 암호화/복호화 과정을 리버스 프록시가 전담합니다. 백엔드 서버들은 이 부담을 덜고 비즈니스 로직 처리에만 집중할 수 있어 효율적입니다.
- **[[캐싱(Caching)]]**: 정적 콘텐츠(이미지, CSS, JS 파일 등)를 리버스 프록시가 캐싱하여 백엔드 서버의 부하를 줄이고 응답 속도를 높입니다.

대표적인 리버스 프록시 소프트웨어로는 `[[HAProxy]]`, Nginx, Apache 등이 있습니다.

---

## 포워드 프록시 vs 리버스 프록시 비교

|   |   |   |
|---|---|---|
|**구분**|**포워드 프록시 (Forward Proxy)**|**리버스 프록시 (Reverse Proxy)**|
|**대리 대상**|**클라이언트**|**서버**|
|**위치**|클라이언트 측 네트워크에 위치|서버 측 네트워크에 위치|
|**주요 목적**|캐싱, 접근 제어, 클라이언트 익명성|로드 밸런싱, 보안, SSL/TLS 처리|
|**서버가 보는 대상**|프록시 서버|프록시 서버|
|**클라이언트가 보는 대상**|프록시 서버|프록시 서버 (실제 서버로 인식)|

---

## 결론

'프록시'라는 용어는 단순히 하나의 기술을 지칭하는 것이 아니라, 아키텍처 상의 '역할'을 의미합니다. 클라이언트를 대리하여 보안과 캐싱을 책임지면 **포워드 프록시**, 서버를 대리하여 로드 밸런싱과 보안, 효율적인 리소스 관리를 책임지면 **리버스 프록시**가 됩니다.

현대의 거의 모든 대규모 웹 서비스는 리버스 프록시 구조를 기반으로 설계되어 있습니다. 개발자로서 이 두 가지 프록시의 개념과 차이점을 명확히 이해하는 것은 안정적이고 확장 가능한 시스템을 설계하는 데 매우 중요한 첫걸음이 될 것입니다.