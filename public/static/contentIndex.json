{"Java--변환,-이름,-스코프":{"title":"Java  변환, 이름, 스코프","links":[],"tags":[],"content":"개요\n\n이 장에서는 형 변환과 수치적 승격(numeric promotions)에 대해 설명합니다.\n\n형 변환은 컴파일 시간에 타입을 변경하거나 때로는 표현식의 값을 변경합니다.\n형 변환에는 원시 타입과 참조 타입 간의 박싱 및 언박싱 형 변환이 포함됩니다\n수치적 승격은 수치 연산자의 피연산자를 공통 타입으로 변환하여 연산이 수행될 수 있도록 합니다.\n언어에는 예외가 없으며, 참조 타입의 형 변환은 런타임에 타입 안전성을 보장하기 위해 검사됩니다.\n\n\n\n"},"Java-Keyword":{"title":"Java Keyword","links":["Java-abstract-keword"],"tags":[],"content":"자바의 키워드는 예약어와, 문맥어로 나눌 수 있습니다.\nReservedKeyword\n\n\nabstract: 추상 클래스나 메서드를 정의하는 데 사용됩니다. 구현이 없는 메서드를 선언할 때 유용합니다.\n\n\nassert: 디버깅 시 조건이 참인지 검사하는 데 사용됩니다. 참이 아니면 AssertionError가 발생합니다.\n\n\nboolean: 논리형 데이터를 저장하는 데 사용되며, true 또는 false 값을 가집니다.\n\n\nbreak: 반복문이나 switch문을 빠져나오는 데 사용됩니다.\n\n\nbyte: 8비트 정수형 데이터를 저장하는 데 사용됩니다.\n\n\ncase: switch문에서 각 조건을 정의할 때 사용됩니다.\n\n\ncatch: 예외를 처리하기 위한 블록을 정의할 때 사용됩니다.\n\n\nchar: 단일 문자 데이터를 저장하는 데 사용됩니다.\n\n\nclass: 클래스를 정의하는 데 사용됩니다.\n\n\nconst: 사용되지 않는 예약어로, final을 대신 사용합니다.\n\n\ncontinue: 반복문 내에서 현재 반복을 건너뛰고 다음 반복으로 진행합니다.\n\n\ndefault: switch문에서 지정된 값이 모두 해당되지 않을 때 실행되는 블록을 정의합니다.\n\n\ndo: do-while 반복문의 시작을 표시합니다.\n\n\ndouble: 64비트 부동 소수점 데이터를 저장하는 데 사용됩니다.\n\n\nelse: if문과 함께 사용되어 조건이 거짓일 때 실행할 코드를 정의합니다.\n\n\nenum: 열거형 타입을 정의하는 데 사용됩니다.\n\n\nextends: 상속 관계를 설정할 때 사용됩니다.\n\n\nfinal: 변경할 수 없는 상수나 메서드를 정의할 때 사용합니다.\n\n\nfinally: 예외 발생 여부와 관계없이 항상 실행되는 블록을 정의합니다.\n\n\nfloat: 32비트 부동 소수점 데이터를 저장하는 데 사용됩니다.\n\n\nfor: 반복문을 정의할 때 사용됩니다.\n\n\nif: 조건문을 시작할 때 사용됩니다.\n\n\ngoto: 사용되지 않는 예약어입니다.\n\n\nimplements: 인터페이스를 구현할 때 사용됩니다.\n\n\nimport: 다른 패키지의 클래스를 사용할 때 포함합니다.\n\n\ninstanceof: 객체가 특정 클래스의 인스턴스인지 확인합니다.\n\n\nint: 32비트 정수형 데이터를 저장하는 데 사용됩니다.\n\n\ninterface: 인터페이스를 정의할 때 사용됩니다.\n\n\nlong: 64비트 정수형 데이터를 저장하는 데 사용됩니다.\n\n\nnative: 네이티브 메서드를 정의할 때 사용되며, 보통 플랫폼 종속적인 기능을 수행합니다.\n\n\nnew: 객체를 생성할 때 사용됩니다.\n\n\npackage: 클래스를 묶는 패키지를 정의할 때 사용됩니다.\n\n\nprivate: 클래스 외부에서 접근할 수 없는 멤버를 정의합니다.\n\n\nprotected: 같은 패키지 또는 서브 클래스에서 접근할 수 있는 멤버를 정의합니다.\n\n\npublic: 모든 클래스에서 접근 가능한 멤버를 정의합니다.\n\n\nreturn: 메서드 실행을 종료하고 값을 반환합니다.\n\n\nshort: 16비트 정수형 데이터를 저장하는 데 사용됩니다.\n\n\nstatic: 인스턴스 생성 없이 클래스에 속하는 멤버를 정의합니다.\n\n\nstrictfp: 부동 소수점 계산의 결정성을 보장합니다.\n\n\nsuper: 부모 클래스의 멤버에 접근할 때 사용됩니다.\n\n\nswitch: 여러 조건 중 하나를 선택할 때 사용됩니다.\n\n\nsynchronized: 여러 스레드에서 접근할 때 동기화 메서드나 블록을 정의합니다.\n\n\nthis: 현재 인스턴스의 멤버에 접근할 때 사용합니다.\n\n\nthrow: 예외를 발생시킬 때 사용됩니다.\n\n\nthrows: 메서드가 던질 수 있는 예외를 선언합니다.\n\n\ntransient: 직렬화되지 않을 멤버를 정의합니다.\n\n\ntry: 예외가 발생할 수 있는 코드를 실행할 블록을 정의합니다.\n\n\nvoid: 메서드가 값을 반환하지 않음을 명시합니다.\n\n\nvolatile: 멀티스레드 환경에서 변수의 일관성을 유지하는 데 사용됩니다.\n\n\nwhile: 조건이 참인 동안 반복문을 실행합니다.\n\n\n_ (underscore): 식별자에 사용할 수 있지만 권장되지 않습니다.\n\n\nContextualKeyword\n\n\nexports: 모듈이 다른 모듈에게 패키지를 공개할 때 사용합니다.\n\n\nmodule: 모듈을 정의할 때 사용합니다.\n\n\nnon-sealed: 상속을 허용할 때 사용되며, sealed 클래스에서 제외됩니다.\n\n\nopen: 모듈이 다른 모듈에 의해 열린 상태로 유지될 수 있도록 합니다.\n\n\nopens: 특정 패키지가 런타임 시 다른 모듈에 의해 반사적으로 액세스될 수 있음을 명시합니다.\n\n\npermits: sealed 클래스가 특정 하위 클래스에 의해 확장될 수 있도록 합니다.\n\n\nprovides: 서비스 구현을 제공할 때 사용합니다.\n\n\nrecord: 불변 데이터 객체를 정의할 때 사용됩니다.\n\n\nrequires: 모듈이 다른 모듈에 의존성을 선언할 때 사용합니다.\n\n\nsealed: 클래스 상속을 제한할 때 사용됩니다.\n\n\nto: exports나 opens와 함께 사용되어 특정 모듈에 대해 공개하는 것을 명시합니다.\n\n\ntransitive: 의존 모듈이 다른 모듈에 함께 제공됨을 명시합니다.\n\n\nuses: 서비스 유형을 사용하는 모듈을 정의합니다.\n\n\nvar: 지역 변수 선언 시 타입을 추론하도록 합니다.\n\n\nwhen: 스위치 식에 사용되며, 자바 12 이후로 도입되었습니다.\n\n\nwith: provides와 함께 사용되어 구현 클래스를 명시합니다.\n\n\nyield: switch 식의 값을 반환할 때 사용됩니다.\n\n"},"Java-abstract-keword":{"title":"Java abstract keword","links":["추상화","자바-추상-클래스와-인터페이스와의-차이"],"tags":[],"content":"abstract 키워드는 Java 프로그래밍 언어에서 추상 클래스와 추상 메서드를 정의하는 데 사용됩니다. 추상화는 객체 지향 프로그래밍의 중요한 개념 중 하나로, 구체적인 구현 없이 개념적 표현만을 정의합니다. abstract를 사용하는 주요 요소는 다음과 같습니다.\n1. 추상 클래스 (Abstract Class)\n\n\n정의: 추상 클래스는 하나 이상의 추상 메서드를 포함할 수 있는 클래스입니다. 해당 클래스는 인스턴스를 생성할 수 없으며, 다른 클래스에 의해 상속되어야 합니다.\n\n\n목적: 공통된 기능은 구현해 두고, 특정 기능은 하위 클래스에서 구현하도록 강제합니다.\n\n\n구현: 추상 클래스는 일반 메서드와 추상 메서드 모두 가질 수 있습니다. 또한 멤버 변수, 생성자 등 다른 클래스 멤버도 포함할 수 있습니다.\nabstract class Animal {\n    String name;\n \n    // 일반 메서드\n    void breathe() {\n        System.out.println(&quot;Breathing...&quot;);\n    }\n \n    // 추상 메서드\n    abstract void makeSound();\n}\n\n\n2. 추상 메서드 (Abstract Method)\n\n\n정의: 추상 메서드는 선언만 하고, 구현은 하지 않는 메서드를 말합니다. 메서드 몸체가 없고, 세미콜론으로 끝납니다. 이 메서드는 하위 클래스에서 반드시 재정의해야 합니다.\n\n\n목적: 다양한 하위 클래스에서 다양한 방식으로 동작하게 만들기 위해 인터페이스를 제공하는 역할을 합니다.\nabstract void makeSound();  // 추상 클래스 내의 추상 메서드\n\n\n3. 추상 클래스 상속 및 구현\n\n\n추상 클래스는 extends 키워드를 사용하여 다른 클래스가 상속할 수 있습니다.\n\n\n추상 클래스를 상속하는 클래스는 반드시 모든 추상 메서드를 구현해야 합니다. 그렇지 않으면, 해당 클래스도 추상 클래스로 선언되어야 합니다.\nclass Dog extends Animal {\n    @Override\n    void makeSound() {\n        System.out.println(&quot;Bark&quot;);\n    }\n}\n\n\n4. 인터페이스와의 차이\nTransclude of 자바-추상-클래스와-인터페이스와의-차이\nabstract 키워드를 활용하면 설계의 유연성을 높이고 코드를 보다 구조적으로 관리할 수 있으며, 다양한 하위 클래스에서 다양한 방식으로 동작할 수 있는 기반을 제공합니다."},"Java-네이밍":{"title":"Java 네이밍","links":[],"tags":[],"content":"개요\n선언과 이름, 그리고 이름이 의미하는 바(즉, 이름이 나타내는 선언)가 무엇인지에 대해 설명합니다. Java 프로그래밍 언어는 클래스와 인터페이스 또는 그 멤버가 사용되기 전에 선언될 필요는 없습니다. 선언 순서는 로컬 변수, 로컬 클래스, 로컬 인터페이스, 그리고 클래스나 인터페이스의 필드 초기화 순서에만 중요합니다. 읽기 쉬운 프로그램을 위한 권장 명명 규칙이 이 장에 설명되어 있습니다.\n"},"Java-메서드,-생성자,-열거형,-레코드":{"title":"Java 메서드, 생성자, 열거형, 레코드","links":[],"tags":[],"content":"개요\n이 장에서는 클래스에 대해 설명합니다. 클래스의 멤버는 클래스, 인터페이스, 필드(변수) 및 메서드입니다. 클래스 변수는 클래스당 한 번만 존재합니다. 클래스 메서드는 특정 객체와 관련 없이 동작합니다. 인스턴스 변수는 클래스의 인스턴스인 객체에서 동적으로 생성됩니다. 인스턴스 메서드는 클래스의 인스턴스에서 호출됩니다. 이들 인스턴스는 실행 중에 현재 객체(this)가 되어 객체 지향 프로그래밍 스타일을 지원합니다.\n"},"Java-문법(Grammer)":{"title":"Java 문법(Grammer)","links":["Java-Keyword"],"tags":[],"content":"\nJava Keyword\n"},"Java-문법":{"title":"Java 문법","links":[],"tags":[],"content":"\n이 장에서는 언어의 어휘 및 구문 문법을 표현하는 데 사용되는 문법과 표기법을 설명합니다.\n"},"Java-어휘-구조":{"title":"Java 어휘 구조","links":[],"tags":[],"content":"\n이 장에서는 C와 C++를 기반으로 하는 Java 프로그래밍 언어의 어휘 구조를 설명합니다. 이 언어는 유니코드 문자 집합으로 작성됩니다. ASCII만 지원하는 시스템에서 유니코드 문자 쓰기를 지원합니다.\n"},"Java-언어-명세서,-Java-SE-22-Edition":{"title":"Java 언어 명세서, Java SE 22 Edition","links":["Java-언어-소개","Java-문법(Grammer)","Java-어휘-구조","Java-타입,-값,-변수","Java--변환,-이름,-스코프","Java-네이밍","Java-패키지,-모듈","Java-\b클래스","Java-인터페이스","Java-배열","Java-예외","Java-실행","Java-바이너리-호환성","Java-블록,-문(statement),-패턴","Java-Expressions","Java-변수-초기화","Java-스레드와-락","Java-타입-추론","Java-구문(Syntax)","자바-언어-딥다이브-커리큘럼"],"tags":[],"content":"\nJava 언어 소개\nJava 문법(Grammer)\nJava 어휘 구조\nJava 타입, 값, 변수\nJava  변환, 이름, 스코프\nJava 네이밍\nJava 패키지, 모듈\nJava \b클래스\nJava 인터페이스\nJava 배열\nJava 예외\nJava 실행\nJava 바이너리 호환성\nJava 블록, 문(statement), 패턴\nJava Expressions\nJava 변수 초기화\nJava 스레드와 락\nJava 타입 추론\nJava 구문(Syntax)\n\n참고자료\n-The Java® Language Specification\n관련 노트\n\n자바 언어 딥다이브 커리큘럼\n"},"Java-언어-소개":{"title":"Java 언어 소개","links":["범용-언어(general-purpose)","동시성-언어(concurrent)","클래스-기반-언어(Class-based-Language)","객체-지향-언어","연구-언어(Research-Language)","프로덕션-언어(Production-Language)","정적-타이핑(Static-Typing)","고수준-언어(High-Level-Language)"],"tags":[],"content":"\nJava 프로그래밍 언어는\n\n범용 언어(general-purpose), 동시성 언어(concurrent), 클래스 기반, 객체 지향 언어입니다.\n많은 프로그래머가 능숙히 익히도록 간단히 설계되었습니다.\n연구 언어가 아닌 프로덕션 언어로 의도되었습니다.\n강력하고 정적으로 유형이 지정됩니다.\n\n컴파일 타임, 런타임 오류를 명확히 구분 가능합니다.\n\n컴파일 타임은 일반적으로 프로그램을 기계에 독립적인 바이트 코드 표현으로 변환하는 것으로 구성됩니다.\n런타임 활동에는 프로그램을 실행하는 데 필요한 클래스의 로딩 및 링크, 선택적 기계 코드 생성 및 프로그램의 동적 최적화, 실제 프로그램 실행이 포함됩니다.\n\n\n\n\n상대적으로 고수준 언어(High-Level Language)로, 머신 표현의 세부 사항을 언어를 통해 사용할 수 없습니다.\n\n여기에는 일반적으로 가비지 수집기를 사용하여 명시적 할당 해제(C free 또는 C++ 에서와 같이 delete)의 안전 문제를 피하기 위한 자동 스토리지 관리가 포함됩니다.\n이 언어에는 인덱스 검사 없이 배열 액세스와 같은 안전하지 않은 구성 요소가 포함되지 않습니다.\n\n\n일반적으로 Java Virtual Machine Specification 에 정의된 바이트코드 명령어 집합 및 바이너리 형식으로 컴파일됩니다 .\n\n\n"},"Java-타입,-값,-변수":{"title":"Java 타입, 값, 변수","links":[],"tags":[],"content":"개요\n\n4장에서는 타입, 값 및 변수에 대해 설명합니다. 타입은 원시 타입(primitive types)과 참조 타입(reference types)으로 세분화됩니다.\n\n\n원시 타입은 모든 기계와 구현에서 동일하게 정의되며, 이는 2의 보수 정수, IEEE 754 부동소수점 숫자, 불리언 타입, 그리고 유니코드 문자 char 타입으로 구성됩니다. 원시 타입의 값은 상태를 공유하지 않습니다.\n참조 타입은 클래스 타입, 인터페이스 타입, 배열 타입입니다.\n\n동적으로 생성된 객체로 구현되며, 이는 클래스나 배열의 인스턴스일 수 있습니다.\n\n각 객체에는 여러 참조가 있을 수 있습니다.\n모든 객체(배열 포함)는 클래스 Object의 메서드를 지원하며, 이는 클래스 계층 구조의 (유일한) 루트입니다.\n미리 정의된 String 클래스는 유니코드 문자 문자열을 지원합니다.\n\n\n클래스는 원시 값을 객체 내에 감싸는 데 사용됩니다. 많은 경우, 감싸기와 풀어내기는 컴파일러에 의해 자동으로 수행됩니다(이 경우 감싸기는 박싱(boxing), 풀어내기는 언박싱(unboxing)이라고 불립니다)\n클래스와 인터페이스는 제네릭(Generic)일 수 있으며, 즉 참조 타입에 의해 매개변수화될 수 있습니다.\n이러한 클래스와 인터페이스의 매개변수화된 타입은 특정 타입 인수로 호출될 수 있습니다.\n\n\n변수는 타입이 지정된 저장 위치입니다.\n\n원시 타입의 변수는 해당 원시 타입의 값을 저장합니다.\n클래스 타입의 변수는 null 참조나 해당 클래스의 인스턴스 또는 그 하위 클래스의 인스턴스를 참조할 수 있습니다.\n인터페이스 타입의 변수는 null 참조나 해당 인터페이스를 구현한 클래스의 인스턴스를 참조할 수 있습니다.\n배열 타입의 변수는 null 참조나 배열을 참조할 수 있습니다.\nObject 클래스 타입의 변수는 null 참조나 어떤 객체든지 참조할 수 있습니다(클래스 인스턴스 또는 배열).\n\n\n\n"},"Java-패키지,-모듈":{"title":"Java 패키지, 모듈","links":[],"tags":[],"content":"개요\n프로그램의 구조에 대해 설명하며, 프로그램은 패키지로 구성됩니다. 패키지의 멤버는 클래스, 인터페이스 및 하위 패키지입니다. 패키지와 그 멤버는 계층적인 이름 공간에서 이름을 가집니다. 인터넷 도메인 이름 시스템은 일반적으로 고유한 패키지 이름을 형성하는 데 사용될 수 있습니다. 컴파일 단위는 주어진 패키지의 클래스와 인터페이스에 대한 선언을 포함하며, 다른 패키지의 클래스와 인터페이스를 임포트하여 짧은 이름을 사용할 수 있습니다.\n패키지는 모듈로 그룹화되어 매우 큰 프로그램을 구축하는 데 필요한 빌딩 블록 역할을 합니다. 모듈의 선언은 해당 모듈을 컴파일하고 실행하는 데 필요한 다른 모듈(즉, 패키지, 클래스 및 인터페이스)을 지정합니다.\nJava 프로그래밍 언어는 패키지, 클래스 및 인터페이스 멤버에 대한 외부 접근에 제한을 둘 수 있습니다. 패키지의 멤버는 동일한 패키지 내의 다른 멤버만 접근할 수 있거나, 동일한 모듈 내의 다른 패키지의 멤버, 또는 다른 모듈의 패키지에서 접근할 수 있습니다. 클래스와 인터페이스의 멤버에도 유사한 제약이 적용됩니다.\n"},"Java":{"title":"Java","links":["Java-Language-Sepcification"],"tags":[],"content":"Java Language Sepcification"},"Next-Step":{"title":"Next Step","links":["원티드-잡"],"tags":[],"content":"\n목표 : 원티드 잡으로 이직하기\n"},"index":{"title":"index","links":[],"tags":[],"content":"Beoks의 개발자 블로그\n안녕하세요! 저는 백엔드 개발자 Beoks입니다.\n이 블로그에서는 개발 이론을 어떻게 실전에서 활용할 수 있는지에 대해 이야기합니다. 이론을 깊이 있게 공부하고, 그것을 실제로 적용하는 데 관심이 많습니다. 최신 기술 트렌드를 따라가며, 이를 프로젝트에 활용하는 것을 좋아합니다."},"객체-지향-언어":{"title":"객체 지향 언어","links":[],"tags":[],"content":""},"고성능-처리-언어":{"title":"고성능 처리 언어","links":[],"tags":[],"content":"고성능 처리를 위한 프로그래밍 언어는 대량의 데이터와 복잡한 계산을 신속하고 효율적으로 수행할 수 있어야 합니다. 이러한 언어는 시스템 자원을 최적으로 활용하고, 실행 시간과 메모리 사용량을 최소화하며, 병렬 처리를 효과적으로 지원해야 합니다. 고성능 처리에 적합한 언어의 조건에 대해 자세히 설명하면 다음과 같습니다.\n\n1. 효율적인 실행 모델 및 성능 최적화\n\n\n컴파일 언어의 이점: 고성능 언어는 일반적으로 컴파일러를 통해 기계어 또는 저수준 중간 표현으로 번역됩니다. 이는 실행 시간에 인터프리터나 JIT(Just-In-Time) 컴파일러의 오버헤드가 없어 빠른 실행 속도를 보장합니다.\n\n예시: C, C++, Rust 등은 컴파일된 바이너리가 기계어 수준에서 직접 실행되어 높은 성능을 제공합니다.\n\n\n\n최적화된 컴파일러 지원: 컴파일러가 코드 최적화를 적극적으로 수행하여 불필요한 연산을 제거하고, 하드웨어의 특성을 최대한 활용할 수 있어야 합니다.\n\n예시: GCC나 Clang과 같은 컴파일러는 다양한 최적화 옵션을 제공하여 성능을 향상시킵니다.\n\n\n\n2. 저수준 메모리 관리 및 제어\n\n\n메모리 제어의 유연성: 고성능 언어는 메모리 할당과 해제를 프로그래머가 직접 관리할 수 있도록 지원하여 메모리 오버헤드와 누수를 최소화합니다.\n\n예시: C와 C++은 malloc/free, new/delete를 통해 수동 메모리 관리를 지원합니다.\n\n\n\n메모리 접근의 효율성: 메모리에 대한 직접적인 접근과 포인터 연산 등을 통해 데이터를 효율적으로 조작할 수 있어야 합니다.\n\n예시: 배열과 포인터를 사용하여 메모리 레이아웃을 최적화할 수 있습니다.\n\n\n\n3. 병렬 처리 및 동시성 지원\n\n\n멀티스레딩 및 멀티프로세싱 지원: 언어 수준에서 스레드와 프로세스를 생성하고 관리할 수 있는 기능을 제공하여 여러 작업을 동시에 수행할 수 있어야 합니다.\n\n예시: C++11 이후 표준에서는 스레드 라이브러리를 제공하며, OpenMP와 같은 병렬 프로그래밍 API를 활용할 수 있습니다.\n\n\n\n비동기 프로그래밍 모델: 비동기 함수와 코루틴을 지원하여 I/O 작업이나 장기 실행 작업의 대기 시간을 줄일 수 있어야 합니다.\n\n예시: Rust는 async/await 키워드를 통해 비동기 프로그래밍을 지원합니다.\n\n\n\n4. 하드웨어 가속 기능의 활용\n\n\n벡터화 및 SIMD 지원: 언어 또는 컴파일러가 SIMD(Single Instruction, Multiple Data) 명령어를 활용하여 벡터 연산을 최적화할 수 있어야 합니다.\n\n예시: C와 C++에서는 네온(NEON), SSE, AVX 등의 SIMD 확장을 인라인 어셈블리나 컴파일러 내장 함수를 통해 사용할 수 있습니다.\n\n\n\nGPU 컴퓨팅 지원: GPU의 병렬 처리 능력을 활용할 수 있도록 CUDA나 OpenCL과의 연동이 가능해야 합니다.\n\n예시: C++은 CUDA C++를 통해 NVIDIA GPU를 활용한 병렬 처리를 지원합니다.\n\n\n\n5. 저수준 연산 및 시스템 자원 접근\n\n\n어셈블리 코드 인라인 삽입: 특정 성능이 중요한 부분에 어셈블리 코드를 직접 삽입하여 최적화를 수행할 수 있어야 합니다.\n\n예시: C와 C++에서는 asm 키워드를 사용하여 인라인 어셈블리를 작성할 수 있습니다.\n\n\n\n시스템 호출 및 하드웨어 제어: 운영체제의 시스템 호출이나 하드웨어 레지스터에 직접 접근하여 성능을 향상시킬 수 있어야 합니다.\n\n\n6. 정적 타입 시스템 및 컴파일 타임 체크\n\n\n정적 타입 검사: 컴파일 타임에 타입 오류를 검출하여 런타임 에러를 방지하고, 최적화를 위한 정보를 제공합니다.\n\n예시: C++, Rust 등의 언어는 강력한 정적 타입 시스템을 갖추고 있습니다.\n\n\n\n제네릭 및 템플릿 메타프로그래밍: 컴파일 타임에 코드를 생성하여 런타임 오버헤드를 줄이고, 코드 재사용성을 높입니다.\n\n예시: C++의 템플릿은 컴파일 타임에 타입에 따른 코드를 생성하여 성능 저하를 막습니다.\n\n\n\n7. 낮은 런타임 오버헤드\n\n\n가비지 컬렉션의 부재 또는 제어 가능: 가비지 컬렉션으로 인한 일시적인 성능 저하를 방지하기 위해 수동 메모리 관리를 하거나, 가비지 컬렉션의 동작을 세밀하게 제어할 수 있어야 합니다.\n\n예시: Rust는 소유권과 생애주기(lifetime) 시스템을 통해 가비지 컬렉션 없이 메모리 안전성을 제공합니다.\n\n\n\n경량화된 런타임 환경: 프로그램 실행 시 추가적인 런타임 오버헤드가 최소화되어야 합니다.\n\n\n8. 최신 기능 및 표준의 지원\n\n\n최신 프로그래밍 패러다임: 함수형 프로그래밍, 표현식 기반의 프로그래밍 등 최신 패러다임을 지원하여 더 간결하고 최적화된 코드 작성을 가능하게 합니다.\n\n예시: C++17, C++20에서는 람다 표현식, 범위 기반 for문 등 현대적인 기능을 제공합니다.\n\n\n\n표준의 지속적인 발전: 언어 표준이 지속적으로 업데이트되어 새로운 하드웨어와 최적화 기술을 지원해야 합니다.\n\n\n9. 강력한 생태계 및 라이브러리 지원\n\n\n고성능 라이브러리의 제공: 수학 연산, 데이터 처리, 네트워킹 등의 분야에서 최적화된 라이브러리를 제공하여 성능을 향상시킬 수 있어야 합니다.\n\n예시: BLAS, LAPACK, Boost 등이 C++에서 사용 가능한 고성능 라이브러리입니다.\n\n\n\n도구 및 프로파일링 지원: 성능 분석과 최적화를 위한 프로파일러, 디버거 등의 도구가 풍부하게 제공되어야 합니다.\n\n예시: Valgrind, gprof, Intel VTune 등의 도구를 통해 성능 병목 지점을 파악할 수 있습니다.\n\n\n\n10. 하드웨어 및 플랫폼 독립성\n\n\n플랫폼 최적화 지원: 다양한 플랫폼에서 최적의 성능을 발휘할 수 있도록 플랫폼별 최적화를 지원해야 합니다.\n\n예시: C/C++은 다양한 플랫폼에서 컴파일러와 라이브러리를 통해 플랫폼 최적화를 수행할 수 있습니다.\n\n\n\n크로스 컴파일 및 이식성: 코드를 수정하지 않고도 다른 아키텍처에 맞게 컴파일하여 실행할 수 있어야 합니다.\n\n\n\n예시 언어 및 그 특징:\n\nC:\n\n가장 저수준의 프로그래밍 언어 중 하나로, 하드웨어에 밀접하게 접근할 수 있습니다.\n메모리 관리와 포인터 연산 등을 통해 세밀한 최적화가 가능합니다.\n\n\nC++:\n\n객체 지향 및 제네릭 프로그래밍을 지원하여 코드 재사용성과 유연성을 제공합니다.\n템플릿 메타프로그래밍을 통해 컴파일 타임에 코드를 생성하여 런타임 오버헤드를 줄일 수 있습니다.\n\n\nRust:\n\n메모리 안전성과 고성능을 동시에 추구하는 언어로, 소유권 기반의 메모리 관리 모델을 제공합니다.\n현대적인 문법과 강력한 동시성 지원으로 안전한 병렬 프로그래밍이 가능합니다.\n\n\nFortran:\n\n과학 계산 분야에서 오랜 기간 사용되어 왔으며, 배열 연산과 수치 계산에 최적화되어 있습니다.\n최신 표준에서는 병렬 처리를 위한 Coarray 등의 기능을 제공합니다.\n\n\n\n\n결론:\n고성능 처리를 위한 언어는 하드웨어의 성능을 최대한 끌어낼 수 있도록 저수준 접근과 고급 기능의 균형을 이루어야 합니다. 프로그래머에게는 세밀한 제어권을 부여하면서도 안전성과 생산성을 저해하지 않는 것이 중요합니다. 또한, 강력한 컴파일러와 도구 지원, 풍부한 라이브러리와 활발한 커뮤니티 역시 고성능 언어의 중요한 조건입니다.\n언어를 선택할 때는 대상 시스템의 특성, 개발 팀의 역량, 개발 기간과 유지보수 계획 등을 종합적으로 고려해야 합니다. 특정 언어가 모든 상황에서 최선은 아니므로, 요구 사항에 가장 부합하는 언어와 기술 스택을 선택하는 것이 중요합니다."},"고수준-언어(High-Level-Language)":{"title":"고수준 언어(High-Level Language)","links":[],"tags":[],"content":"고수준 언어(high-level language)는 프로그래머가 컴퓨터와 소통할 때 사용하는 언어로, 기계어(컴퓨터가 직접 이해하는 0과 1로 이루어진 코드)보다 훨씬 추상화된 형태로 작성됩니다. 이를 통해 개발자는 복잡한 하드웨어 제어나 메모리 관리 등을 직접 다루지 않고도 알고리즘과 로직에 집중할 수 있습니다. 아래에서 고수준 언어의 특징과 장점에 대해 자세히 설명드리겠습니다.\n\n1. 추상화와 인간 친화적인 문법\n\n추상화: 고수준 언어는 하드웨어의 세부 사항(예: 레지스터, 메모리 주소 등)을 추상화하여, 개발자가 보다 직관적인 명령어와 구조로 프로그래밍할 수 있게 해줍니다.\n문법과 구조: 사람의 자연어와 유사한 문법 구조를 갖추어, 코드의 가독성이 높고 이해하기 쉽습니다.\n\n2. 생산성과 유지보수의 용이성\n\n빠른 개발: 복잡한 기능들을 간단한 코드로 구현할 수 있으므로 개발 속도가 빨라집니다.\n유지보수: 코드의 가독성과 모듈화가 잘 되어 있어, 이후 버그 수정이나 기능 추가 등이 용이합니다.\n\n3. 플랫폼 독립성\n\n이식성: 고수준 언어로 작성된 프로그램은 운영체제나 하드웨어 플랫폼에 독립적인 경우가 많습니다. 단, 이를 위해 컴파일러나 인터프리터가 각 플랫폼에 맞게 제공되어야 합니다.\n컴파일러/인터프리터: 고수준 언어는 보통 컴파일러(예: C, C++)나 인터프리터(예: Python, Ruby)를 통해 기계어로 변환되어 실행됩니다.\n\n4. 내장 라이브러리와 풍부한 기능\n\n라이브러리 지원: 문자열 처리, 파일 입출력, 네트워크 통신 등 다양한 기능을 지원하는 표준 라이브러리가 내장되어 있어, 별도의 복잡한 코드를 작성할 필요가 없습니다.\n추가 모듈: 오픈 소스 커뮤니티와 상업적 지원을 통해 수많은 추가 모듈과 프레임워크를 사용할 수 있습니다.\n\n5. 메모리 관리의 자동화\n\n가비지 컬렉션: 많은 고수준 언어는 자동 메모리 관리 기능(예: 가비지 컬렉션)을 제공하여, 프로그래머가 직접 메모리 할당과 해제를 관리하는 부담을 덜어줍니다.\n안정성: 이러한 자동화는 메모리 누수나 잘못된 포인터 접근 등과 같은 오류를 줄이는 데 도움을 줍니다.\n\n\n고수준 언어의 예시\n\nPython: 간결하고 직관적인 문법으로 초보자부터 전문가까지 널리 사용되는 언어.\nJava: 객체지향 프로그래밍을 지원하며, 한 번 작성하면 다양한 플랫폼에서 실행 가능한 “Write Once, Run Anywhere” 철학을 지님.\nC#: Microsoft에서 개발한 언어로, .NET 프레임워크와 함께 사용되며 강력한 기능과 풍부한 라이브러리를 제공.\nJavaScript: 웹 개발의 표준 언어로, 클라이언트와 서버 모두에서 사용 가능.\nRuby: 간결하고 유연한 문법으로 웹 애플리케이션 개발에 많이 활용됨.\n\n\n고수준 언어와 저수준 언어의 비교\n\n저수준 언어(예: 어셈블리, 기계어): 하드웨어와 매우 가까운 수준에서 동작하며, 빠른 실행 속도와 세밀한 제어가 가능하지만, 작성과 유지보수가 어렵고 코드의 가독성이 낮습니다.\n고수준 언어: 코드의 가독성과 개발 생산성이 높으며, 유지보수가 용이하지만, 일부 경우에는 저수준 언어에 비해 실행 속도가 느릴 수 있습니다.\n"},"대규모-시스템에-적합한-언어":{"title":"대규모 시스템에 적합한 언어","links":["고성능-처리-언어","코드의-안정성"],"tags":[],"content":"대규모 시스템에 적합한 프로그래밍 언어는 복잡하고 방대한 규모의 애플리케이션을 효율적으로 개발하고 유지보수할 수 있는 특징을 가져야 합니다. 이러한 언어의 조건과 특징은 다음과 같습니다.\n\n\n성능 및 효율성:\n\n고성능 처리 언어: 대량의 데이터와 트래픽을 처리해야 하므로 언어의 실행 속도가 빠르고 효율적이어야 합니다.\n최적화 가능성: 시스템의 특정 부분을 최적화할 수 있는 기능과 도구를 제공해야 합니다.\n\n\n\n확장성:\n\n수평적 확장 지원: 시스템이 성장함에 따라 쉽게 확장할 수 있어야 합니다.\n모듈성 및 컴포넌트화: 코드가 모듈화되어 있어 변경이나 추가 개발이 용이해야 합니다.\n\n\n\n안정성 및 신뢰성:\n\n에러 처리 능력: 예외 상황을 효과적으로 처리할 수 있는 메커니즘이 있어야 합니다.\n메모리 안전성: 메모리 누수나 접근 오류를 방지할 수 있는 기능이 중요합니다.\n\n\n\n병렬 처리 및 동시성 지원:\n\n멀티스레딩 지원: 동시 사용자 요청을 효율적으로 처리하기 위한 스레드 관리가 필요합니다.\n비동기 프로그래밍: 비동기 처리를 지원하여 자원 활용도를 높여야 합니다.\n\n\n\n유지보수성:\n\n가독성 높은 문법: 코드가 이해하기 쉽고 명확해야 협업과 유지보수가 용이합니다.\n강한 타입 시스템: 타입 오류를 최소화하여 런타임 에러를 줄일 수 있습니다.\n\n\n\n풍부한 라이브러리 및 프레임워크:\n\n표준 라이브러리의 다양성: 필요한 기능을 빠르게 구현할 수 있도록 지원해야 합니다.\n커뮤니티와 생태계: 활발한 커뮤니티는 다양한 문제 해결과 지속적인 업데이트를 제공합니다.\n\n\n\n도구 및 지원 환경:\n\n디버깅 및 프로파일링 도구: 문제를 빠르게 파악하고 해결할 수 있어야 합니다.\n통합 개발 환경(IDE) 지원: 개발 생산성을 높여주는 환경이 필요합니다.\n\n\n\n보안성:\n\n내장된 보안 기능: 일반적인 취약점을 방지할 수 있는 언어적 지원이 중요합니다.\n입력 검증 및 안전한 메모리 관리: 악의적인 공격으로부터 시스템을 보호해야 합니다.\n\n\n\n표준화 및 호환성:\n\n플랫폼 독립성: 다양한 환경에서 동작할 수 있어야 글로벌 서비스에 적합합니다.\n호환성 및 상호 운영성: 다른 시스템 및 언어와의 연동이 용이해야 합니다.\n\n\n\n학습 곡선:\n\n개발자 접근성: 언어가 복잡하지 않고 학습하기 쉬워야 인력 수급이 원활합니다.\n문서화 및 교육 자료: 충분한 자료가 있어야 개발자들이 쉽게 활용할 수 있습니다.\n\n\n\n예시 언어:\n\n자바(Java): 객체 지향 언어로서 안정성과 풍부한 라이브러리를 제공하며, JVM을 통해 플랫폼 독립성을 가집니다.\n고(Go): 구글에서 개발한 언어로서, 간결한 문법과 뛰어난 동시성 지원으로 대규모 시스템에 적합합니다.\n스칼라(Scala): 함수형 프로그래밍과 객체 지향을 결합하여 복잡한 시스템을 효과적으로 관리할 수 있습니다.\n러스트(Rust): 메모리 안전성과 성능을 모두 제공하여 시스템 프로그래밍에 강점이 있습니다.\n"},"동시성-언어(concurrent)":{"title":"동시성 언어(concurrent)","links":[],"tags":[],"content":"“concurrent”는 여러 작업이 동시에 진행될 수 있음을 의미합니다. 즉,  여러 작업이나 프로세스가 동시에 실행될 수 있는 기능을 제공한다는 뜻입니다. 이를 통해 여러 작업을 병렬로 처리하거나, 멀티태스킹을 구현할 수 있습니다. 예를 들어, 여러 스레드를 동시에 실행하여 성능을 개선하거나, 사용자 인터페이스(UI)가 응답을 멈추지 않도록 할 수 있습니다."},"모듈화":{"title":"모듈화","links":["추상화는-어떻게-모듈화를-지원하는가","자바-모듈"],"tags":[],"content":"모듈화는 프로그램을 기능별로 나누어 독립적인 단위인 모듈로 구성하는 것을 말합니다. 모듈화된 코드는 각 모듈이 서로 독립적으로 작동하므로 개발, 테스트, 유지보수가 용이해집니다.\n관련 노트\n\n추상화는 어떻게 모듈화를 지원하는가\n자바 모듈\n"},"범용-언어(general-purpose)":{"title":"범용 언어(general-purpose)","links":[],"tags":[],"content":"“general-purpose”는 특정한 용도나 분야에 한정되지 않고 다양한 용도로 사용될 수 있음을 의미합니다. 즉,  다양한 종류의 소프트웨어 개발, 예를 들어 데스크탑 애플리케이션, 웹 애플리케이션, 모바일 앱 등 다양한 분야에서 활용할 수 있다는 뜻입니다."},"연구-언어-vs-프로덕션-언어":{"title":"연구 언어 vs 프로덕션 언어","links":[],"tags":[],"content":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n비교 항목연구 언어프로덕션 언어목적새로운 개념 연구, 실험안정적인 소프트웨어 개발안정성상대적으로 낮음매우 중요사용성주로 학계, 특정 도메인산업 전반에서 사용성능 최적화덜 중요함매우 중요함예제 언어Haskell, Prolog, LispJava, Python, C++"},"연구-언어(Research-Language)":{"title":"연구 언어(Research Language)","links":["연구-언어-vs-프로덕션-언어"],"tags":[],"content":"**연구 언어(Research Language)**는 새로운 프로그래밍 개념, 패러다임, 언어 설계 원칙을 실험하거나 특정 연구 목적을 위해 개발된 프로그래밍 언어입니다.\n이 언어들은 상용 소프트웨어 개발보다는 이론적 탐구, 컴퓨터 과학 연구, 특정 문제 해결을 위한 실험적 도구로 사용됩니다.\n\n연구 언어의 특징\n1. 새로운 패러다임 및 개념 검증\n\n기존 언어에서 해결하기 어려운 문제를 다루거나 새로운 프로그래밍 개념을 탐구하는 데 초점을 맞춤.\n예: Haskell → 순수 함수형 프로그래밍 연구\n예: Prolog → 논리 프로그래밍 연구\n\n2. 안정성과 성능보다는 실험성을 중시\n\n프로덕션 언어처럼 최적화나 확장성보다는 이론적 가능성을 탐색하는 것이 목표.\n문법이 복잡하거나, 기존 개발 방식과 많이 다를 수 있음.\n\n3. 커뮤니티와 생태계가 작을 수 있음\n\n연구 목적이므로 널리 사용되지 않거나, 실무에서 사용하기 어려운 경우가 많음.\n상용 프로젝트를 지원하는 생태계(라이브러리, 도구, 커뮤니티)가 부족할 수 있음.\n\n4. 교육 및 특정 분야에서 활용됨\n\n대학 및 연구 기관에서 교육 또는 특정 연구에 사용됨.\n특정 분야에 최적화된 경우도 있음 (예: Julia는 수학 및 과학 계산 연구).\n\n\n대표적인 연구 언어\n1. Haskell (순수 함수형 프로그래밍 연구)\n\n특징: 순수 함수형 언어, 지연 평가(Lazy Evaluation), 강한 타입 시스템.\n목적: 함수형 패러다임 연구, 수학적 프로그램 모델 연구.\n실제 활용: 연구 및 교육용, 일부 금융 및 블록체인 프로젝트에서 사용됨.\n\n2. Prolog (논리 프로그래밍 연구)\n\n특징: 선언적 프로그래밍, 논리적 추론을 활용한 문제 해결.\n목적: 인공지능(AI), 자연어 처리(NLP) 연구.\n실제 활용: 전문가 시스템, AI 연구, 자동화된 추론 시스템.\n\n3. Erlang (고가용성 시스템 연구)\n\n특징: 병렬성 및 분산 시스템 지원, 고장 허용성(Fault Tolerance).\n목적: 분산 시스템 및 통신 시스템 연구.\n실제 활용: WhatsApp, 전화 교환 시스템(통신 분야).\n\n4. Lisp (인공지능 연구)\n\n특징: 메타프로그래밍, 동적 타이핑, 강력한 리스트 처리 기능.\n목적: AI 연구, 언어 설계 연구.\n실제 활용: AI 초기 연구, Emacs 같은 편집기에서 사용됨.\n\n5. Julia (수학 및 과학 계산 연구)\n\n특징: 높은 성능, 다이나믹 타입, 병렬 처리 최적화.\n목적: 고성능 수학 및 과학 계산 연구.\n실제 활용: 머신러닝, 데이터 과학, 물리학 연구.\n\n\n연구 언어가 프로덕션 언어로 발전하는 경우\n일부 연구 언어는 시간이 지나면서 산업에서도 인기를 얻고 실무에서 사용되기도 함. 예를 들어:\n\nPython → 연구용 스크립트 언어에서 시작했지만, AI 및 웹 개발에서 널리 사용됨.\nErlang → 연구 목적에서 시작했지만, 통신 및 메시징 시스템(WhatsApp, RabbitMQ)에서 활용됨.\nHaskell의 개념 → 일부 아이디어(함수형 프로그래밍, 강한 타입 시스템)는 Scala, Kotlin, TypeScript 등의 언어에 영향을 줌.\n\n관련 노트\n\n\b연구 언어 vs 프로덕션 언어\n"},"옵시디언-Periodic-Notes-플러그인":{"title":"옵시디언 Periodic Notes 플러그인","links":[],"tags":[],"content":"\n일일, 주간 그리고 월간 노트를 자동으로 생성해주는 플러그인\n\n🔹 1. 일일 노트 템플릿 설정 (Templates/daily.md)\n📌 어제 / 내일 링크 추가 (Templater 활용)\n예시 템플릿\n# 📅 {{tp_date}}  \n&lt;&lt; [[&lt;% tp.date.now(&quot;YYYY-MM-DD&quot;, -1) %&gt;]] | [[&lt;% tp.date.now(&quot;YYYY-MM-DD&quot;, +1) %&gt;]] &gt;&gt;  \n\n## 🌅 오늘의 목표\n- [ ] 주요 목표 1\n- [ ] 주요 목표 2\n\n## 📝 오늘의 기록\n- 아침 운동:\n- 업무 중 배운 것:\n- 추가 메모:\n\n## 📌 내일 할 일\n- [ ] 미리 계획할 작업\n\n\n💡 이 기능의 효과:\n\n상단에 자동으로 어제와 내일 노트 링크 추가\nObsidian에서 Ctrl + Click으로 빠르게 이동 가능\n\n📌 설정 적용\n\n⚙️(설정) → Periodic Notes → Daily Note\n\n“Folder” → Daily Notes/\n“Template” → Templates/daily.md\n“Date format” → YYYY-MM-DD\n\n\n\n다른 주간, 월간도 다음과 같이 설정 가능"},"옵시디언-Tasks-플러그인":{"title":"옵시디언 Tasks 플러그인","links":[],"tags":[],"content":"🔹 1. Tasks 플러그인 설치 및 설정\n\n\nTasks 플러그인 설치\n\n⚙️(설정) → Community Plugins → “Tasks” 검색 후 설치 및 활성화\n\n\n\n할 일 관리 기본 설정\n\nTasks 플러그인은 마크다운 체크박스를 활용해 - [ ] 형식으로 태스크를 관리합니다.\n특정 날짜나 태그를 기반으로 할 일을 자동으로 필터링할 수 있음.\n\n\n\n오늘 할 일 필터링\n다음과 같이 코드 블럭에 due today 추가\n\\```\ndue today\n\\```\n"},"옵시디언-Templater-플러그인-새-노트-생성시-활성화":{"title":"옵시디언 Templater 플러그인 새 노트 생성시 활성화","links":[],"tags":[],"content":"플러그인 설정에서 새 파일 생성시 트리거를 활성화할 수 있다.\n"},"옵시디언-Templater-플러그인":{"title":"옵시디언 Templater 플러그인","links":["옵시디언-Templater-플러그인-새-노트-생성시-활성화"],"tags":[],"content":"🔹 1. 플러그인 활성화\n\n\nTemplater 설치 및 활성화\n\n⚙️(설정) → Community plugins → “Templater” 검색 후 설치 및 활성화\n⚙️(설정) → Templater 메뉴로 이동\n“Template folder location” → Templates/ 설정\n\n\n\n비고\n옵시디언 Templater 플러그인 새 노트 생성시 활성화"},"옵시디언-기본-일일-노트-플러그인-사용법":{"title":"옵시디언 기본 일일 노트 플러그인 사용법","links":["옵시디언-Templater-플러그인","옵시디언-Periodic-Notes-플러그인"],"tags":[],"content":"✅ 1. Daily Notes 플러그인 활성화\n\nObsidian을 실행합니다.\n좌측 하단 ⚙️(설정) → “Core Plugins”(코어 플러그인)으로 이동합니다.\n**“Daily Notes”**를 찾아 활성화합니다.\n\n\n✅ 2. Daily Notes 기본 설정\nDaily Notes를 활성화하면 설정 옵션이 생깁니다.\n\n⚙️(설정) → “Daily Notes” 메뉴로 이동합니다.\n주요 설정을 조정합니다:\n\n“New file location” → 일일 노트를 저장할 폴더 지정 (예: Daily Notes/)\n“Template file location” → 템플릿을 사용하려면 템플릿 파일 위치 지정 (예: Templates/daily.md)\n“Date format” → 파일명 형식 지정 (예: YYYY-MM-DD 또는 YYYY년 MM월 DD일)\n\n\n\n\n✅ 3. 일일 노트 템플릿 만들기\n반복되는 구조를 만들려면 템플릿을 설정하세요.\n\n\n템플릿 폴더 생성: Templates/ 폴더를 만듭니다.\n\n\ndaily.md 파일 생성 후 예제 템플릿 작성:\n# 📅 {{date}}\n \n## 🌅 오늘의 목표\n- [ ] 주요 목표 1\n- [ ] 주요 목표 2\n \n## 📝 오늘의 기록\n- 아침 운동:\n- 업무 중 배운 것:\n- 추가 메모:\n \n## 📌 내일 할 일\n- [ ] 미리 계획할 작업\n\n\n⚙️(설정) → **“Daily Notes”**에서 템플릿 파일 위치를 Templates/daily.md로 설정합니다.\n\n\n\n✅ 4. 일일 노트 사용하기\n\n단축키: Cmd/Ctrl + Shift + D\n왼쪽 사이드바 “일일 노트” 버튼 클릭\n설정된 날짜 형식에 맞춰 자동으로 노트가 생성됩니다.\n\n단점\n\n동적 템플릿 기능 불가 ex. 파일을 생성할떄 자동으로 날짜 등을 기입\n\n대안\n\n옵시디언 Templater 플러그인: 동적 템플릿 생성\n옵시디언 Periodic Notes 플러그인: 주간/월간 노트도 자동 생성\nDataview: 일일 노트 데이터 검색 및 정리\n"},"옵시디언-노트-바로-열기":{"title":"옵시디언 노트 바로 열기","links":[],"tags":[],"content":"\n옵시디언의 파일 관리 단위는 파일이 아니라 볼트이기 때문에 마크다운 파일을 바로 클릭한다해도 열리지 않아 불편한점이 있습니다.\n이를 해소하기 위해 Automator 를 이용해 자동으로 파일을 클릭하면 볼트를 기준으로 열거나, 볼트가 없는 경우 다른 에디터로 여는 방법을 소개합니다.\n\n상세\n\n응용프로그램에서 Automator 를 찾아 실행합니다.\n문서 유형 선택에서 응용 프로그램을 선택합니다.\n\n좌측에서 보관함 &gt; 유틸리티 &gt; 쉘 스크립드 실행을 선택합니다.\n\n다음 스크립트를 추가합니다.\n볼트가 없는 마크다운일 경우 VScode 로 실행하도록 설정되어 있습니다. 다른 에디터를 사용하고 싶은 경우 해당 프로그램의 이름으로 변경하면됩니다.\n\n# For each file that we are passed\nfor f in &quot;$@&quot;\ndo\n    # start at the folder the file is in\n    dir=$(dirname &quot;$f&quot;)\n    # while we are not at the root of the hard drive\n    while [ &quot;$dir&quot; != &quot;/&quot; ]; do\n        # check to see if we have reached an obsidian vault\n        if [ -d &quot;$dir/.obsidian&quot; ]; then\n            # If we have, open in obsidian\n            open &quot;obsidian://open?vault=$(basename &quot;$dir&quot;)&amp;file=${f#$dir/}&quot;\n            exit\n        fi\n        # go up one folder to se if we are in an obsidian vault\n        dir=$(dirname &quot;$dir&quot;)\n    done\n    # if we get this far, then we reached the root of the hard drive, and did not find an obsidian vault\n    # Fallback to Sublime Text\n    open -a &quot;Visual Studio Code&quot; &quot;$f&quot;\ndone\n\n생성한 응용 프로그램을 응용 프로그램 폴더에 저장합니다.\n\n\n이제 아무 마크 다운 파일 &gt; 우클릭 &gt; 정보 가져오기 &gt; 다음으로 열기 &gt; 생성한 응용프로그램 선택 &gt; 모두 변경을 설정하면 완료됩니다.\n\n\n참고 자료\n\nforum.obsidian.md/t/have-obsidian-be-the-handler-of-md-files-add-ability-to-use-obsidian-as-a-markdown-editor-on-files-outside-vault-file-association/314/125\n"},"옵시디언-세팅":{"title":"옵시디언 세팅","links":["옵시디언에서-현재-폴더에-새-노트를-만드는-방법","옵시디언에서-이미지를-특정-디렉토리-하위에-모으는-방법","옵시디언에서-일일-노트를-만드는-방법"],"tags":[],"content":"\n옵시디언에서 현재 폴더에 새 노트를 만드는 방법\n옵시디언에서 이미지를 특정 디렉토리 하위에 모으는 방법\n옵시디언에서 일일 노트를 만드는 방법\n"},"옵시디언에서-이미지를-특정-디렉토리-하위에-모으는-방법":{"title":"옵시디언에서 이미지를 특정 디렉토리 하위에 모으는 방법","links":[],"tags":[],"content":"\n설정 &gt; 옵션 &gt; 파일과 링크 탭에서 사용 가능\n여러 방식으로 첨부파일 위치를 지정 가능\n\n"},"옵시디언에서-일일-노트를-만드는-방법":{"title":"옵시디언에서 일일 노트를 만드는 방법","links":["옵시디언-기본-일일-노트-플러그인-사용법"],"tags":[],"content":"옵시디언 기본 일일 노트 플러그인 사용법"},"옵시디언에서-현재-폴더에-새-노트를-만드는-방법":{"title":"옵시디언에서 현재 폴더에 새 노트를 만드는 방법","links":[],"tags":[],"content":"옵시디언 설정 &gt; 옵션 탭에서 다음과 같이 설정 가능\n"},"인터페이스-분리-원칙-(Interface-Segregation-Principle)":{"title":"인터페이스 분리 원칙 (Interface Segregation Principle)","links":[],"tags":[],"content":""},"자바-언어-딥다이브-커리큘럼":{"title":"자바 언어 딥다이브 커리큘럼","links":[],"tags":[],"content":"아래는 Java 언어 명세(JLS 22판)를 하루 2시간씩 공부할 수 있도록 12주(약 3개월) 동안 진행할 수 있는 커리큘럼 예시입니다. 이 커리큘럼은 명세의 체계적인 구성(예, 목차 citeturn0file0)을 바탕으로 주요 주제별로 나누었으며, 각 주차마다 이론 학습, 예제 분석, 그리고 실습(또는 자기 점검) 시간을 포함하도록 구성했습니다.\n─────────────────────────────\n【1주차 – 개요 및 기본 구조】\n• 1일차:\n - 명세 소개 및 전체 구성 파악 (Chapter 1, Introduction)\n - 목차와 공부 목표 정리\n• 2일차:\n - 언어 명세의 조직 방식과 예제 프로그램 살펴보기\n• 3일차:\n - Chapter 2 (Grammars)를 읽으며 Java의 구문(문법) 구조 이해\n• 4일차:\n - Chapter 3 (Lexical Structure) – 토큰, 식별자, 키워드, 리터럴 등 기초 용어 정리\n• 5일차:\n - 읽은 내용 정리 및 간단한 예제(예: 간단한 코드 스니펫 분석) 실습\n• 6~7일차:\n - 복습 및 자가 진단: 지금까지 학습한 부분에 대해 요약 정리하고, 주요 개념에 대해 퀴즈 형식으로 스스로 점검\n─────────────────────────────\n【2주차 – 타입과 값, 변수】\n• 1일차:\n - Chapter 4 개요 – 타입, 값, 변수의 분류와 기본 개념 읽기\n• 2일차:\n - Primitive Types (정수, 부동소수점, boolean, char 등) 세부 내용 학습\n• 3일차:\n - Reference Types, 객체, String 등, 그리고 null 개념 정리\n• 4일차:\n - Type Variables, 제네릭, 파라미터화된 타입 및 타입 소거(Erasure) 이해\n• 5일차:\n - 학습 내용 정리 및 관련 예제 코드 분석\n• 6일차:\n - 간단한 실습: 직접 타입과 변수 선언, 기본 연산 수행\n• 7일차:\n - 복습 및 요약, 이해도 점검\n─────────────────────────────\n【3주차 – 형 변환과 컨텍스트】\n• 1일차:\n - Chapter 5 개요 – 다양한 변환 종류(Identity, Widening, Narrowing 등) 읽기\n• 2일차:\n - 기본 숫자형 변환 및 연산 시의 형 변환 규칙 정리\n• 3일차:\n - Boxing/Unboxing, String, 캐스팅 관련 내용 집중 학습\n• 4일차:\n - 대입, 호출, 연산(숫자, 비교 등) 컨텍스트에서의 형 변환 예제 분석\n• 5일차:\n - 학습 내용 정리 및 실습 코드 작성\n• 6일차:\n - 문제 해결 및 복습\n• 7일차:\n - 자가 점검 및 요약\n─────────────────────────────\n【4주차 – 이름, 스코프, 선언 규칙】\n• 1일차:\n - Chapter 6 (Names) 읽기 – 선언, 식별자, 예약어, 의미 결정 방식\n• 2일차:\n - 스코프와 생명주기, 네이밍 규칙(지역변수, 필드, 메서드 등) 분석\n• 3일차:\n - 오버로딩, 섀도잉, 가시성(access control) 관련 세부 규칙 학습\n• 4일차:\n - 예제 코드와 실제 Java 프로젝트에서의 사례 분석\n• 5일차:\n - 스스로 연습 문제 풀이\n• 6일차:\n - 정리 및 메모, 이해되지 않는 부분 재검토\n• 7일차:\n - 복습 및 자가 테스트\n─────────────────────────────\n【5주차 – 패키지, 클래스, 인터페이스】\n• 1일차:\n - Chapter 7 (Packages and Modules) – 패키지 구조와 모듈 시스템 이해\n• 2일차:\n - Chapter 8 (Classes) 시작 – 클래스 선언, 수정자, 생성자 개념 정리\n• 3일차:\n - 클래스 멤버(필드, 메서드, 생성자, 내부 클래스) 세부 내용 학습\n• 4일차:\n - 상속, 추상 클래스, final, sealed 클래스 등의 특징 분석\n• 5일차:\n - Chapter 9 (Interfaces) – 인터페이스, 디폴트 메서드, 애너테이션 등 학습\n• 6일차:\n - 간단한 클래스 및 인터페이스 작성 실습\n• 7일차:\n - 복습 및 예제 재검토\n─────────────────────────────\n【6주차 – 배열과 예외 처리】\n• 1일차:\n - Chapter 10 (Arrays) – 배열 선언, 초기화, 다차원 배열 및 예외 상황 이해\n• 2일차:\n - 배열 접근, 저장, 런타임 오류(예: ArrayStoreException) 사례 분석\n• 3일차:\n - Chapter 11 (Exceptions) – 예외의 종류(checked, runtime, error)와 처리 방법 학습\n• 4일차:\n - try-catch-finally, try-with-resources 구문 등 예외 처리 기법 정리\n• 5일차:\n - 실제 코드를 통한 예외 발생 및 처리 실습\n• 6일차:\n - 학습 내용 정리 및 문제 풀이\n• 7일차:\n - 복습 및 자가 점검\n─────────────────────────────\n【7주차 – 실행 모델과 바이너리 호환성】\n• 1일차:\n - Chapter 12 (Execution) – JVM의 시작, 클래스 로딩, 링킹, 초기화 과정 학습\n• 2일차:\n - 객체 생성, 초기화, finalization의 동작 원리 이해\n• 3일차:\n - 클래스 언로딩 및 메모리 관리 관련 개념 정리\n• 4일차:\n - Chapter 13 (Binary Compatibility) – 바이너리 호환성, API 변화 시 고려사항 분석\n• 5일차:\n - 실제 사례 연구: 클래스 버전 변화에 따른 호환성 이슈 탐구\n• 6일차:\n - 관련 문제 풀이 및 토론\n• 7일차:\n - 복습 및 요약\n─────────────────────────────\n【8주차 – 블록, 문, 패턴과 표현식】\n• 1일차:\n - Chapter 14 (Blocks, Statements, and Patterns) – if, switch, loop, 블록 구성 분석\n• 2일차:\n - 조건문, 반복문 및 예외 전환문 등 제어문 구조 심화 학습\n• 3일차:\n - Chapter 15 (Expressions) – 표현식 평가 순서, 연산자 우선순위, 기본 표현식 이해\n• 4일차:\n - 복잡한 표현식과 메서드 호출, 람다 표현식 사례 분석\n• 5일차:\n - 실습: 복합 표현식과 조건식을 직접 작성해보기\n• 6일차:\n - 학습 내용 정리 및 주요 포인트 리뷰\n• 7일차:\n - 자가 테스트 및 복습\n─────────────────────────────\n【9주차 – 결정적 할당(Definite Assignment)】\n• 1일차:\n - Chapter 16 (Definite Assignment) – 지역 변수, 초기화 규칙 개요 학습\n• 2일차:\n - 조건문, 반복문에서의 변수 할당 규칙 심화 분석\n• 3일차:\n - 실제 예제와 컴파일러 오류 사례 분석\n• 4일차:\n - 연습 문제 풀이 및 토론\n• 5일차:\n - 학습 내용 정리 및 보충 학습\n• 6일차:\n - 문제 해결 및 자가 진단\n• 7일차:\n - 복습 및 요약\n─────────────────────────────\n【10주차 – 스레드와 동기화】\n• 1일차:\n - Chapter 17 (Threads and Locks) – 스레드 기본, 동기화, 모니터 개념 학습\n• 2일차:\n - wait/notify, interruption, 그리고 스레드 안전성 관련 사례 분석\n• 3일차:\n - Java 메모리 모델, happens-before 규칙 등 심화 내용 학습\n• 4일차:\n - 멀티스레드 프로그램 작성 실습 및 문제점 파악\n• 5일차:\n - 학습 내용 정리 및 코드 리뷰\n• 6일차:\n - 관련 연습 문제 풀이\n• 7일차:\n - 복습 및 자가 점검\n─────────────────────────────\n【11주차 – 타입 추론 및 제네릭 심화】\n• 1일차:\n - Chapter 18 (Type Inference) – 제네릭 메서드와 타입 추론 기본 원리 이해\n• 2일차:\n - 추론 변수, 제약 조건, 인보케이션 타임 인퍼런스 사례 분석\n• 3일차:\n - 실제 코드에서의 제네릭 사용과 한계 분석\n• 4일차:\n - 연습 문제 및 사례 연구\n• 5일차:\n - 학습 내용 정리 및 보충 학습\n• 6일차:\n - 자가 진단 및 코드 실습\n• 7일차:\n - 복습 및 요약\n─────────────────────────────\n【12주차 – 전체 문법과 종합 복습】\n• 1일차:\n - Chapter 19 (Syntax) – 전체 문법 규칙 및 생산 규칙 개요 학습\n• 2일차:\n - 문법 생산 규칙 심화 분석 및 다양한 예제 검토\n• 3일차:\n - 전체 명세에서 다루지 못한 미비한 부분 재검토\n• 4일차:\n - 지금까지 학습한 모든 주제에 대한 종합 복습\n• 5일차:\n - 자신이 작성한 코드 및 예제를 통해 실전 적용 연습\n• 6일차:\n - 자가 테스트(퀴즈, 모의 문제) 및 오답 분석\n• 7일차:\n - 최종 종합 정리 및 앞으로의 심화 학습 방향 설정\n─────────────────────────────\n※ 이 커리큘럼은 개인의 선행 지식과 학습 속도에 따라 조정할 수 있으며, 각 주차별로 이론 학습 후 반드시 간단한 코드 실습이나 문제 풀이를 통해 이해도를 점검하는 것이 좋습니다. 또한, 명세를 읽으면서 궁금한 부분은 관련 온라인 자료나 토론 포럼에서 보충 학습하는 것도 도움이 됩니다.\n이와 같이 진행하면 Java 언어 명세의 방대한 내용을 체계적으로 이해할 수 있을 것입니다."},"자바-추상-클래스와-인터페이스와의-차이":{"title":"자바 추상 클래스와 인터페이스와의 차이","links":["**다이아몬드-문제(Diamond-Problem)"],"tags":[],"content":"자바에서 추상 클래스와 인터페이스는 객체 지향 프로그래밍에서 추상화를 구현하기 위한 중요한 도구입니다. 이 둘 사이에는 몇 가지 핵심적인 차이점이 있으며, 이를 정확히 설명하면 다음과 같습니다.\n\n\n상속과 구현 관계:\n\n추상 클래스 (Abstract Class):\n\n클래스 상속을 통해 확장됩니다. extends 키워드를 사용합니다.\n단일 상속만 지원하므로 한 클래스는 **하나의 부모 클래스(추상 클래스 포함)만을 상속**할 수 있습니다.\n\n\n인터페이스 (Interface):\n\n인터페이스 구현을 통해 적용됩니다. implements 키워드를 사용합니다.\n다중 구현이 가능하므로 한 클래스는 여러 개의 인터페이스를 구현할 수 있습니다.\n\n\n\n\n\n메서드 구성:\n\n추상 클래스:\n\n추상 메서드와 구체적인 메서드 모두를 가질 수 있습니다.\n추상 메서드는 메서드 선언만 있고 구현부는 없습니다. 하위 클래스에서 반드시 구현해야 합니다.\n구체적인 메서드는 구현부가 있으며, 하위 클래스에서 상속받아 사용할 수 있거나 재정의(오버라이딩)할 수 있습니다.\n\n\n인터페이스:\n\nJava 8 이전에는 모든 메서드가 암묵적으로 public abstract이며, 구현부를 가질 수 없었습니다.\nJava 8 이후부터는 default 메서드와 static 메서드를 통해 구현부를 가진 메서드를 정의할 수 있습니다.\nJava 9부터는 private 메서드도 선언하여 인터페이스 내부에서만 사용할 수 있습니다.\n\n\n\n\n\n필드 (멤버 변수):\n\n추상 클래스:\n\n인스턴스 변수와 클래스 변수를 모두 가질 수 있습니다.\n접근 제한자 (public, protected, private)를 사용하여 필드의 접근 범위를 지정할 수 있습니다.\n\n\n인터페이스:\n\n모든 필드는 암묵적으로 public static final입니다.\n즉, 인터페이스 내에서 선언된 변수는 상수로 취급되며, 반드시 값을 초기화해야 합니다.\n\n\n\n\n\n생성자:\n\n추상 클래스:\n\n생성자를 가질 수 있습니다.\n추상 클래스 자체로는 객체를 생성할 수 없지만, 하위 클래스의 생성자에서 super()를 통해 부모 클래스의 생성자를 호출하여 부모 클래스의 초기화를 수행합니다.\n\n\n인터페이스:\n\n생성자를 가질 수 없습니다.\n상태를 가질 수 없으며, 인스턴스화할 수 없습니다.\n\n\n\n\n\n접근 제한자:\n\n추상 클래스:\n\n클래스 및 그 멤버에 대해 모든 종류의 접근 제한자를 사용할 수 있습니다.\n필요한 접근 수준에 따라 public, protected, private, 패키지 프라이빗(아무 접근 제한자도 지정하지 않을 경우)을 적용할 수 있습니다.\n\n\n인터페이스:\n\n인터페이스 자체는 public 또는 패키지 프라이빗으로 선언할 수 있습니다.\n인터페이스의 모든 메서드는 암묵적으로 public이며, Java 9부터는 private 메서드를 선언할 수 있습니다.\n\n\n\n\n\n사용 목적:\n\n추상 클래스:\n\n클래스들 사이에 공통된 특성이나 동작을 공유하고자 할 때 사용합니다.\n상속을 통해 코드 재사용성을 높이고, 계층 구조를 형성합니다.\n클래스들 간에 강한 연관성(“is-a” 관계)이 있을 때 적합합니다.\n\n\n인터페이스:\n\n클래스들이 특정한 기능을 구현하도록 강제하고자 할 때 사용합니다.\n서로 다른 클래스들이 동일한 동작을 구현하여 다형성을 제공할 수 있습니다.\n클래스들 간에 연관성이 적거나 다양한 계층 구조에 걸쳐 있을 때 유용합니다.\n\n\n\n\n\n예시:\n\n추상 클래스 예시:\npublic abstract class Animal {\n    protected String name;\n    \n    public Animal(String name) {\n        this.name = name;\n    }\n    \n    public abstract void makeSound();\n    \n    public void sleep() {\n        System.out.println(name + &quot; is sleeping.&quot;);\n    }\n}\n\n인터페이스 예시:\npublic interface Flyable {\n    void fly();\n}\n \npublic interface Swimmable {\n    void swim();\n}\n\n\n\n\n다중 상속 문제 해결:\n\n자바는 클래스의 다중 상속을 지원하지 않지만, 인터페이스의 다중 구현을 통해 이 문제를 부분적으로 해결할 수 있습니다.\n인터페이스를 여러 개 구현함으로써 다양한 기능을 하나의 클래스에서 제공할 수 있습니다.\n\n\n\n요약하면:\n\n추상 클래스는 클래스 간의 계층 구조를 형성하고, 공통된 속성이나 메서드를 공유하며, 코드 재사용성을 높이는 데 사용됩니다.\n인터페이스는 클래스들이 특정 기능을 구현하도록 표준을 정의하고, 다형성을 제공하며, 서로 관련이 없는 클래스들이 동일한 동작을 수행하도록 할 때 사용됩니다.\n\n두 개념은 모두 추상화의 수단이지만, 그 목적과 사용 방식에서 차이가 있습니다. 개발자는 프로그램의 구조와 요구 사항에 따라 적절히 선택하여 사용해야 합니다."},"자바를-가장-효과적으로-배우는-법":{"title":"자바를 가장 효과적으로 배우는 법","links":[],"tags":[],"content":"목표 : 프로그래밍 언어를 문서 참조 없이 자유롭고 빠르게 써내려갈 수 있으며, 누가 구조에 대해서 물어볼때 자신있게 대답할 수 있을 정도\n자바를 문서를 매번 참조하지 않고 자신 있게 코딩하고, “under the hood” 부분까지 설명할 수 있는 수준으로 학습하려면 다음과 같은 접근 방식을 추천합니다.\n\n1. 기초를 탄탄히 다지기\n\n\n구조화된 강좌 수강:\n\n예를 들어, University of Helsinki의 자바 MOOC나 Oracle 공식 자바 튜토리얼 같은 체계적인 강좌를 통해 기본 개념(객체 지향, 자료형, 제어문 등)을 확실하게 익히세요.\n이유: 기초 개념이 튼튼해야 이후의 심화 학습이나 복잡한 문제 해결 시 혼란 없이 빠르게 발전할 수 있습니다.\n\n\n\n효율적인 개발 환경 사용:\n\nIntelliJ IDEA나 Eclipse 같은 강력한 IDE를 사용해 코드를 작성하고 디버깅하세요.\n이유: IDE는 코드 자동완성, 리팩토링, 디버깅 등 다양한 기능을 제공하여 학습 과정에서 문서를 참조하는 빈도를 줄이고, 자바의 문법과 내부 동작 방식에 자연스럽게 익숙해지도록 돕습니다.\n\n\n\n\n2. 심화 학습으로 실력을 끌어올리기\n\n\n권위 있는 책 읽기:\n\n“Effective Java”, “Thinking in Java” 같은 책들은 자바의 모범 사례와 설계 원칙을 깊이 있게 다룹니다.\n이유: 이러한 서적들은 단순한 문법을 넘어 자바를 효과적으로 사용하는 방법과 내부 동작 원리를 이해할 수 있게 해주어, 실무에서의 문제 해결 능력과 코드 품질을 높여줍니다.\n\n\n\nJVM 및 언어 내부 원리 학습:\n\nJVM의 메모리 관리, 가비지 컬렉션, JIT 컴파일 등 내부 작동 방식을 공부해 보세요.\n이유: 내부 메커니즘을 이해하면 “어떻게 작동하는가?”라는 질문에 대해 자신 있게 설명할 수 있고, 최적화나 디버깅 시에도 큰 도움이 됩니다.\n공식문서 참고하기 docs.oracle.com/javase/specs/\n\n\n\n\n3. 실전 경험을 통한 반복 학습\n\n\n작은 프로젝트부터 시작하기:\n\n계산기, 할 일 목록 앱 등 작은 프로젝트를 직접 만들어 보세요.\n이유: 실제 코드를 작성하며 문제를 해결하는 과정에서 이론이 자연스럽게 내재화되고, 자신만의 노하우가 축적됩니다.\n\n\n\n코딩 챌린지 참여:\n\nCodewars, HackerRank 등의 플랫폼에서 다양한 문제를 풀어보세요.\n이유: 여러 유형의 문제를 경험하면서 알고리즘과 자바의 기능을 반복 연습할 수 있어, 실력이 빠르게 향상됩니다.\n\n\n\n\n4. 좋은 코드 읽기와 커뮤니티 활동\n\n\n오픈소스 코드 분석:\n\nGitHub 등에서 좋은 자바 프로젝트의 소스 코드를 읽어보고, 구조와 설계 방식을 익혀보세요.\n이유: 다른 개발자들이 어떻게 문제를 해결하고 코드를 구성하는지 살펴보면, 자신의 코드 작성 스타일도 향상됩니다.\n\n\n\n커뮤니티 참여:\n\nJava User Group(JUG)나 r/learnjava 같은 온라인 커뮤니티에서 질문하고 토론해보세요.\n이유: 동료들과의 정보 교환을 통해 새로운 관점을 얻고, 부족한 부분을 보완할 수 있습니다.\n\n\n\n\n5. 배운 내용을 내 것으로 만들기\n\n\n핵심 패턴 암기 및 반복 연습:\n\n자주 사용하는 API나 디자인 패턴은 반복적으로 코딩하면서 자연스럽게 체득하세요.\n이유: 반복 학습을 통해 문서를 참조할 필요 없이, 중요한 개념과 함수들이 몸에 배게 됩니다.\n\n\n\n다른 사람에게 설명하기:\n\n블로그 포스팅, 코드 리뷰, 혹은 스터디 모임에서 배운 내용을 다른 사람에게 설명해보세요.\n이유: 다른 사람에게 설명하면서 자신이 제대로 이해했는지 확인할 수 있고, 이 과정에서 지식이 더욱 공고해집니다.\n\n\n\n\n결론\n자바를 문서를 매번 참조하지 않고 자유롭게 코딩하며, 내부 동작 원리까지 자신 있게 설명하려면 기초부터 심화 학습, 실전 프로젝트, 커뮤니티 활동까지 체계적으로 접근하는 것이 중요합니다. 이러한 학습 방법은 이론과 실습을 동시에 강화하여, 자바에 대한 깊은 이해와 실무 능력을 함께 향상시킬 수 있게 해줍니다."},"자바에서-클래스-상속을-단일로-제한하는-이유":{"title":"자바에서 클래스 상속을 단일로 제한하는 이유","links":[],"tags":[],"content":"자바에서 하나의 클래스가 하나의 클래스만 상속할 수 있도록 제한한 이유는 다중 상속으로 인해 발생할 수 있는 복잡성, 모호성, 예측 불가능한 동작 등을 방지하여 언어의 단순성과 안정성을 유지하기 위함입니다. 대신, 자바는 인터페이스를 통해 다형성과 유연성을 제공하며, 이러한 설계 철학은 개발자의 생산성을 높이고 안정적인 소프트웨어 개발을 가능하게 합니다.\n1. 다이아몬드 문제(Diamond Problem)의 회피\n다중 상속을 허용하면 다이아몬드 문제라고 불리는 모호성이 발생할 수 있습니다.\n\n\n상속 구조 설명:\n    클래스 A\n    /       \\\n클래스 B   클래스 C\n    \\       /\n    클래스 D\n\n\n\n문제 발생 시나리오:\n\n클래스 B와 클래스 C가 각각 클래스 A의 메서드 method()를 오버라이드한다고 가정합니다.\n클래스 D는 클래스 B와 클래스 C를 다중 상속합니다.\n이제 클래스 D의 인스턴스에서 method()를 호출하면, 클래스 B의 method()를 호출해야 할까요, 아니면 클래스 C의 method()를 호출해야 할까요?\n이와 같은 모호성은 코드의 예측 가능성을 떨어뜨리고, 디버깅을 어렵게 만듭니다.\n\n\n\n자바는 이러한 다이아몬드 문제를 근본적으로 차단하기 위해 클래스의 다중 상속을 허용하지 않습니다.\n2. 언어의 단순성과 코드의 가독성 유지\n\n단일 상속은 클래스 계층 구조를 단순하게 유지합니다.\n개발자는 클래스가 어디에서 어떤 특성과 동작을 상속받는지 명확하게 이해할 수 있습니다.\n이는 코드의 유지 보수성을 높이고, 협업 시 혼란을 줄여줍니다.\n\n3. 컴파일러 및 JVM 구현의 복잡성 감소\n\n다중 상속을 지원하려면 컴파일러와 JVM에서 메서드 탐색, 동적 바인딩, 메모리 레이아웃 등의 구현이 복잡해집니다.\n특히, 동일한 이름의 메서드나 변수가 여러 조상 클래스에 존재할 때, 이를 어떻게 처리할지에 대한 규칙이 복잡해집니다.\n이러한 복잡성은 언어의 안정성과 성능에도 영향을 줄 수 있습니다.\n\n4. 인터페이스를 통한 다형성 구현\n\n자바는 클래스의 다중 상속 대신 인터페이스의 구현을 통해 다형성을 제공합니다.\n클래스는 여러 개의 인터페이스를 구현할 수 있으므로, 필요한 메서드 시그니처를 모두 포함할 수 있습니다.\n인터페이스는 구현을 제공하지 않기 때문에(자바 8부터는 default 메서드를 통해 가능하지만, 이는 별도의 우선순위 규칙이 적용됩니다), 다중 상속에서 발생하는 모호성을 피할 수 있습니다.\n인터페이스를 사용함으로써 다중 상속의 이점을 누리면서도 복잡성과 모호성은 줄일 수 있습니다.\n\n5. C++에서의 교훈과 언어 설계 철학\n\nC++은 다중 상속을 허용하지만, 이로 인해 발생하는 복잡성과 버그로 많은 개발자들이 어려움을 겪었습니다.\n자바의 설계자들은 이러한 교훈을 받아들여 언어의 단순성, 안정성, 안전성을 추구했습니다.\n이는 자바가 개발자의 생산성을 높이고, 실수를 줄이며, 유지 보수하기 쉬운 언어로 자리매김하는 데 기여했습니다.\n\n6. 메서드 분해 및 우선순위 결정의 어려움\n\n다중 상속에서는 동일한 시그니처를 가진 메서드가 여러 상위 클래스에 존재할 수 있습니다.\n어떤 메서드를 호출해야 하는지 결정하는 로직은 복잡해지며, 이는 예측하지 못한 동작을 초래할 수 있습니다.\n자바는 이러한 문제를 미연에 방지하고자 단일 상속을 채택했습니다.\n"},"전략-디자인-패턴(Strategy-Design-Pattern)":{"title":"전략 디자인 패턴(Strategy Design Pattern)","links":[],"tags":[],"content":"**전략 패턴(Strategy Pattern)**은 객체의 행동을 변경해야 할 때, 해당 행동을 별도의 클래스로 정의하고 필요할 때 교체할 수 있도록 만드는 디자인 패턴이다. 즉, 동일한 문제를 해결하는 여러 알고리즘(전략)을 정의하고, 실행 시점에서 이를 선택할 수 있도록 한다.\n\n🔹 전략 패턴의 핵심 개념\n\n상속이 아닌 “구성(Composition)“을 활용하여 동작을 캡슐화한다.\n행동(알고리즘)을 인터페이스로 추상화하고, 이를 구현한 여러 전략(Concrete Strategy)을 정의한다.\n실행 중 전략을 쉽게 변경할 수 있도록 설계하여 유연성을 높인다.\n\n\n🔹 구조 (UML)\n┌──────────────────────┐\n│     Context         │\n│  (전략을 사용)      │\n│ ┌────────────────┐ │\n│ │ Strategy       │ │\n│ │ (인터페이스)   │ │\n│ └────────────────┘ │\n│   strategy:Strategy │\n│ ┌────────────────┐ │\n│ │ setStrategy()  │ │\n│ │ execute()      │ │\n└──────────────────────┘\n         ▲\n         │\n ┌────────────────┐  ┌────────────────┐\n │ StrategyA      │  │ StrategyB      │\n │ (구체적인 전략) │  │ (구체적인 전략) │\n │ execute() 구현 │  │ execute() 구현 │\n └────────────────┘  └────────────────┘\n\n🔹 예제 코드 (TypeScript)\n🎯 1. 전략 인터페이스 정의\ninterface Strategy {\n  execute(a: number, b: number): number;\n}\n🎯 2. 구체적인 전략 클래스 구현\nclass AddStrategy implements Strategy {\n  execute(a: number, b: number): number {\n    return a + b;\n  }\n}\n \nclass MultiplyStrategy implements Strategy {\n  execute(a: number, b: number): number {\n    return a * b;\n  }\n}\n🎯 3. 컨텍스트(Context) 클래스 구현\nclass Calculator {\n  private strategy: Strategy;\n \n  constructor(strategy: Strategy) {\n    this.strategy = strategy;\n  }\n \n  setStrategy(strategy: Strategy) {\n    this.strategy = strategy;\n  }\n \n  calculate(a: number, b: number): number {\n    return this.strategy.execute(a, b);\n  }\n}\n🎯 4. 실행 코드\nconst calculator = new Calculator(new AddStrategy());\nconsole.log(calculator.calculate(5, 3)); // 8 (덧셈)\n \ncalculator.setStrategy(new MultiplyStrategy());\nconsole.log(calculator.calculate(5, 3)); // 15 (곱셈)\n\n🔹 전략 패턴을 사용하는 이유\n✅ 유연성 증가 - 실행 중 전략을 변경할 수 있음\n✅ 코드 재사용성 증가 - 알고리즘을 별도의 클래스로 분리하여 재사용 가능\n✅ OCP(개방-폐쇄 원칙) 준수 - 기존 코드를 수정하지 않고 새로운 전략을 추가 가능\n✅ 유지보수 용이 - 각 전략을 독립적으로 수정 가능\n\n🔹 전략 패턴이 유용한 경우\n\n여러 알고리즘을 런타임에 변경해야 할 때\n\n예: 정렬 알고리즘(버블 정렬, 퀵 정렬 등) 선택\n\n\nif-else 또는 switch문이 너무 많을 때\n\n예: 결제 방식(신용카드, 페이팔, 애플페이 등) 처리\n\n\n클래스가 특정 행동에 따라 여러 버전이 필요할 때\n\n예: AI의 행동 패턴(공격적 AI, 방어적 AI)\n\n\n\n\n🔹 전략 패턴 vs 상태 패턴(State Pattern)\n전략 패턴과 상태 패턴은 비슷하지만 차이점이 있다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n비교 항목전략 패턴 (Strategy)상태 패턴 (State)목적알고리즘(전략) 변경객체의 상태 변경상태 변화외부에서 직접 변경내부적으로 변경변경 방식사용자가 직접 설정객체 내부에서 상태 변화\n💡 전략 패턴은 특정 기능(알고리즘)을 변경하는 것이고,\n💡 상태 패턴은 객체의 상태에 따라 행동이 변하는 것이다.\n\n🔹 마무리\n전략 패턴은 “동작을 객체화하여 유연성을 높이는” 패턴이다.\n특히 **“조건문이 많아지는 문제를 해결”**하고, **“알고리즘을 쉽게 교체할 수 있도록 설계”**하는 데 유용하다.\nTypeScript, Java, Python 등 다양한 언어에서 활용 가능하며, SOLID 원칙 중 **OCP(개방-폐쇄 원칙)**을 잘 준수하는 패턴이다."},"정적-타이핑(Static-Typing)":{"title":"정적 타이핑(Static Typing)","links":[],"tags":[],"content":"정적 타이핑 언어의 정의\n정적 타이핑(Static Typing)은 변수의 타입이 컴파일 타임에 결정되는 방식의 타입 시스템을 의미한다. 정적 타이핑을 지원하는 언어에서는 코드 작성 시 타입을 명시적으로 선언하거나, 타입 추론을 통해 결정되며, 컴파일 시점에 타입 오류를 검출할 수 있다.\n예시 언어:\n\nJava, C, C++, TypeScript, Kotlin, Rust, Swift 등\n\n\n정적 타이핑의 효과\n\n오류 조기 발견\n\n실행 전에 타입 관련 오류를 컴파일러가 감지하여 런타임 에러를 줄일 수 있음.\n\n\n성능 최적화\n\n타입 정보가 정적으로 결정되므로 컴파일러가 최적화하여 실행 속도를 높일 수 있음.\n\n\n코드 가독성 및 유지보수성 향상\n\n변수와 함수의 타입이 명확하게 명시되므로 코드 이해가 쉬워지고, 협업 시 오류 발생 가능성을 줄일 수 있음.\n\n\n자동 완성 및 개발 생산성 향상\n\nIDE에서 타입 정보를 바탕으로 정확한 코드 자동 완성 및 문서화를 제공함.\n\n\n대규모 코드베이스 관리 용이\n\n많은 개발자가 참여하는 프로젝트에서 예상치 못한 타입 변경으로 인한 오류를 방지할 수 있음.\n\n\n\n\n단점\n\n\n개발 속도 저하\n\n정적 타이핑 언어는 변수나 함수의 타입을 명시적으로 선언해야 하므로, 이를 관리하는 데 시간이 소요될 수 있습니다. 동적 타이핑 언어에 비해 작성해야 하는 코드가 더 길어질 수 있고, 복잡한 타입 시스템을 이해하고 설계하는 데 시간이 들 수 있습니다.\n예시:\nJava나 C++에서 클래스를 설계하고 타입을 명확히 선언해야 하기 때문에 작은 프로젝트나 빠른 프로토타입 개발에는 비효율적일 수 있습니다.\n\n\n\n유연성 부족\n\n정적 타이핑 언어는 타입이 미리 정의되어 있기 때문에 동적인 변화나 유연성을 요구하는 작업에서 불편할 수 있습니다. 예를 들어, 실행 중에 타입을 변경하거나 예상치 못한 구조를 다루는 데 어려움이 있을 수 있습니다.\n예시:\nJava에서 객체의 타입을 실행 중에 동적으로 변경하려면 리플렉션(Reflection)을 사용해야 하며, 이는 코드의 복잡도를 증가시키고 성능에 영향을 미칠 수 있습니다.\n\n\n\n코드 복잡도 증가\n\n정적 타이핑 시스템은 때때로 너무 복잡하거나 상세한 타입 정보를 요구할 수 있습니다. 복잡한 제네릭 타입, 상속, 인터페이스 등이 포함될 경우, 코드가 너무 길어지고 이해하기 어려워질 수 있습니다. 또한, 코드 작성자와 읽는 사람 모두가 이 복잡한 시스템을 이해해야 하므로 배워야 할 내용이 많습니다.\n예시:\nTypeScript의 고급 제네릭이나 타입 유니온을 사용하면 코드가 복잡해지고, 잘못된 타입을 사용할 경우 예기치 못한 오류를 발생시킬 수 있습니다.\n\n\n\n유연한 프로토타이핑 어려움\n\n초기 개발 단계에서 자주 변경되는 요구 사항이나 디자인에 맞추어 빠르게 프로토타입을 작성하려면, 정적 타이핑 언어는 부담이 될 수 있습니다. 타입을 정의하는 작업이 불필요한 제약으로 작용할 수 있으며, 초기 개발 속도가 느려질 수 있습니다.\n예시:\nPython이나 JavaScript와 같은 동적 타이핑 언어는 프로토타입을 빠르게 구현할 수 있기 때문에 MVP(Minimum Viable Product) 개발 시 더 효율적일 수 있습니다.\n\n\n\n\n정적 타이핑이 적합한 사례\n\n\n대규모 시스템 개발\n\n금융, 의료, 항공 등 높은 신뢰성이 필요한 애플리케이션 (e.g., Java 기반 은행 시스템, Rust 기반 OS 개발)\n\n\n\n멀티 스레드 환경 및 병렬 처리\n\n타입 안정성이 보장되어 동시성 이슈가 적고 안전한 시스템 개발 가능 (e.g., Rust의 소유권 시스템)\n\n\n\nAPI 및 라이브러리 개발\n\n외부에 제공되는 SDK나 API의 타입이 명확해야 사용자 경험이 좋아짐 (e.g., TypeScript로 작성된 라이브러리)\n\n\n\n고성능 애플리케이션\n\n시스템 프로그래밍, 게임 엔진, 데이터베이스 엔진 등 (e.g., C++ 기반 게임 엔진, Rust 기반 웹 서버)\n\n\n\n장기 유지보수가 필요한 프로젝트\n\n기업용 소프트웨어, 오픈소스 프로젝트 등 (e.g., Kotlin을 활용한 Android 앱 개발)\n\n\n\n\n언제 정적 타이핑을 피해야 할까?\n\n빠른 프로토타이핑이 필요한 경우 (e.g., 스타트업의 MVP 개발 → Python, JavaScript)\n코드가 짧고 간결한 스크립트일 때 (e.g., 간단한 자동화 스크립트)\n"},"추상화":{"title":"추상화","links":["코드의-유지보수성","코드의-확장성(Extensibility)","모듈화","고차-함수(higher-order-function)"],"tags":[],"content":"프로그래밍에서 **추상화(Abstraction)**는 복잡한 시스템이나 개념을 단순화하여 이해하기 쉽게 만드는 기법을 말합니다. 이는 세부 구현이나 복잡한 내부 구조를 감추고 필요한 부분만을 노출하여 프로그래머나 사용자가 시스템을 더 효율적으로 사용할 수 있게 해줍니다. 추상화는 소프트웨어 개발에서 코드의 재사용성, 유지보수성, 확장성을 향상시키는 핵심 원칙 중 하나입니다.\n추상화의 중요성\n\n복잡성 감소: 복잡한 시스템을 단순화하여 전체 구조를 이해하기 쉽게 만듭니다.\n재사용성 향상: 일반화된 인터페이스를 통해 코드의 재사용이 용이해집니다.\n유지보수성 증대: 시스템의 한 부분을 변경해도 다른 부분에 최소한의 영향만 미치도록 설계할 수 있습니다.\n모듈화 지원: 시스템을 독립적인 모듈로 나누어 관리가 쉽습니다.\n\n추상화의 유형\n1. 데이터 추상화(Data Abstraction)\n데이터 추상화는 데이터의 내부 표현이나 구현을 감추고, 데이터와 관련된 연산만을 노출하는 것입니다. 이를 통해 데이터 구조의 세부 사항에 의존하지 않고 데이터를 조작할 수 있습니다.\n\n예시: 클래스나 구조체에서 공개(public) 메서드만을 노출하고, 변수들은 비공개(private)로 선언하여 내부 데이터를 보호합니다.\n\npublic class Account {\n    private double balance;\n \n    public void deposit(double amount) {\n        balance += amount;\n    }\n \n    public double getBalance() {\n        return balance;\n    }\n}\n2. 절차적 추상화(Procedural Abstraction)\n절차적 추상화는 특정 작업을 수행하는 코드를 함수나 메서드로 캡슐화하여 그 구현 세부 사항을 감춥니다.\n\n예시: sort() 함수를 사용하여 내부 정렬 알고리즘에 대한 이해 없이도 리스트를 정렬할 수 있습니다.\n\nnumbers = [5, 3, 8, 2]\nnumbers.sort()\nprint(numbers)  # [2, 3, 5, 8]\n3. 제어 추상화(Control Abstraction)\n제어 추상화는 제어 흐름 구조를 추상화하여 복잡한 제어 흐름을 단순화합니다. 루프나 조건문 등의 구조를 사용하여 복잡한 제어 흐름을 이해하기 쉽게 만듭니다.\n\n예시: 고차 함수(higher-order function)를 사용하여 반복적인 제어 흐름을 추상화합니다.\n\ndef apply_function(func, data):\n    return [func(x) for x in data]\n \nresult = apply_function(lambda x: x * 2, [1, 2, 3])\nprint(result)  # [2, 4, 6]\n프로그래밍 패러다임에서의 추상화\n객체 지향 프로그래밍(OOP)의 추상화\n객체 지향 프로그래밍에서는 추상화를 클래스를 통해 구현합니다. 클래스는 데이터와 그 데이터를 조작하는 메서드로 구성되며, 이를 통해 복잡한 시스템을 객체로 모델링합니다.\n\n추상 클래스와 인터페이스: 추상 클래스나 인터페이스를 사용하여 공통의 인터페이스를 정의하고, 세부 구현은 서브클래스에서 담당합니다.\n\npublic interface Animal {\n    void makeSound();\n}\n \npublic class Dog implements Animal {\n    public void makeSound() {\n        System.out.println(&quot;Bark&quot;);\n    }\n}\n함수형 프로그래밍의 추상화\n함수형 프로그래밍에서는 함수를 일급 시민으로 취급하여 함수를 인자나 반환값으로 사용합니다. 이를 통해 연산을 추상화하고 코드의 재사용성을 높입니다.\n\n예시: map, filter, reduce 함수를 사용하여 데이터 처리 과정을 추상화합니다.\n\nnumbers = [1, 2, 3, 4]\nsquared = map(lambda x: x ** 2, numbers)\nprint(list(squared))  # [1, 4, 9, 16]\n추상화의 실제 적용 예시\n\nAPI 사용: API를 통해 내부 구현을 알 필요 없이 원하는 기능을 사용할 수 있습니다.\n라이브러리 및 프레임워크: 복잡한 기능을 단순한 인터페이스로 제공하여 개발 생산성을 높입니다.\n데이터베이스 ORM(Object-Relational Mapping): SQL 질의문을 직접 작성하지 않고도 객체 지향적으로 데이터베이스를 조작할 수 있습니다.\n\n결론\n추상화는 프로그래밍에서 복잡성을 관리하고 시스템을 효율적으로 설계하는 데 필수적인 개념입니다. 추상화를 적절히 활용하면 코드를 더 깔끔하고 유지보수하기 쉽게 만들 수 있으며, 개발 과정에서 발생하는 오류를 줄일 수 있습니다. 프로그래머는 추상화의 원칙을 이해하고 이를 코드에 적용함으로써 더 나은 소프트웨어를 개발할 수 있습니다."},"추상화는-어떻게-모듈화를-지원하는가":{"title":"추상화는 어떻게 모듈화를 지원하는가","links":["추상화","모듈화"],"tags":[],"content":"추상화는 프로그래밍에서 복잡한 시스템의 세부 구현을 감추고, 필요한 기능이나 인터페이스만을 노출하여 시스템을 단순ㅎ화하는 기법입니다. 이는 복잡성을 줄이고 코드의 이해와 유지보수를 쉽게 만들어줍니다.\n한편, 모듈화는 프로그램을 기능별로 나누어 독립적인 단위인 모듈로 구성하는 것을 말합니다. 모듈화된 코드는 각 모듈이 서로 독립적으로 작동하므로 개발, 테스트, 유지보수가 용이해집니다.\n그렇다면 추상화가 어떻게 모듈화를 지원할까요?\n1. 인터페이스를 통한 의존성 감소\n추상화를 통해 모듈 간의 인터페이스(약속된 기능 목록)를 정의하면, 각 모듈은 다른 모듈의 내부 구현에 의존하지 않고도 상호 작용할 수 있습니다. 이는 모듈 간의 결합도를 낮추어 변경이 발생해도 다른 모듈에 미치는 영향을 최소화합니다.\n2. 캡슐화를 통한 모듈 독립성 강화\n추상화는 데이터와 함수를 캡슐화하여 외부에 노출되지 않도록 합니다. 이를 통해 모듈 내부의 구현 세부 사항이 외부로부터 보호되고, 모듈은 자신의 역할에 집중할 수 있습니다.\n\n예시: 클래스의 private 변수를 외부에서 직접 접근하지 못하게 하고, public 메서드를 통해서만 조작하도록 합니다. 이렇게 하면 클래스 내부 구현을 변경해도 외부에는 영향을 주지 않습니다.\n\npublic class Calculator {\n    private int result;\n \n    public void add(int value) {\n        result += value;\n    }\n \n    public int getResult() {\n        return result;\n    }\n}\n3. 명확한 책임 분리\n추상화를 통해 각 모듈은 명확한 역할과 책임을 갖게 됩니다. 이는 시스템의 구조를 이해하기 쉽게 만들고, 개발 팀 내에서 작업을 분할하여 효율적으로 진행할 수 있게 합니다.\n\n예시: 웹 애플리케이션에서 사용자 인증 모듈, 데이터베이스 접근 모듈, UI 모듈 등을 각각 추상화하여 개발하면, 각 모듈은 자신의 역할에만 집중하면 됩니다.\n\n4. 재사용성 향상\n추상화된 모듈은 구체적인 구현에 의존하지 않으므로, 다른 프로젝트나 시스템에서도 쉽게 재사용할 수 있습니다.\n\n예시: 표준화된 로그 처리 모듈을 만들어두면, 다양한 애플리케이션에서 이 모듈을 가져다 사용하여 일관된 방식으로 로그를 관리할 수 있습니다.\n\n5. 유지보수성 증대\n모듈화된 시스템에서 추상화는 변경이 필요한 부분만 수정하고, 다른 부분은 손대지 않을 수 있게 해줍니다. 이는 시스템의 유지보수를 쉽게 만들어줍니다.\n\n예시: 데이터베이스를 변경해야 하는 상황에서, 데이터 접근을 추상화한 모듈만 수정하면 됩니다. 애플리케이션의 다른 부분은 이 모듈의 인터페이스를 사용하므로 영향을 받지 않습니다.\n\n쉽게 이해할 수 있는 비유\n추상화와 모듈화를 일상생활에 비유하면 다음과 같습니다.\n\n\n추상화: 자동차 운전자는 엔진이 어떻게 작동하는지 몰라도 핸들과 페달을 사용하여 운전할 수 있습니다. 여기서 핸들과 페달은 복잡한 엔진 시스템을 추상화한 인터페이스입니다.\n\n\n모듈화: 자동차는 엔진, 바퀴, 브레이크 등 여러 부품으로 이루어져 있습니다. 각 부품은 독립적으로 작동하며, 문제가 발생하면 해당 부품만 수리하거나 교체하면 됩니다.\n\n\n결론적으로, 추상화는 모듈화를 지원함으로써 시스템의 복잡성을 관리하고, 개발과 유지보수를 더욱 효율적으로 만들어줍니다. 추상화를 통해 모듈 간의 명확한 인터페이스를 정의하고, 내부 구현을 감춤으로써 모듈의 독립성과 재사용성을 높일 수 있습니다."},"코드의-안정성":{"title":"코드의 안정성","links":[],"tags":[],"content":"코드의 안전성은 소프트웨어가 예기치 않은 상황에서도 안정적으로 작동하고, 악의적인 공격이나 오류로부터 보호될 수 있도록 작성되었는지를 의미합니다. 이를 보장하기 위해 고려해야 할 주요 요소들을 자세히 살펴보면 다음과 같습니다.\n코드 안정성 주요 요소\n\n입력 검증 및 데이터 유효성 검사\n\n정의: 외부로부터 입력받는 데이터가 예상한 형식과 범위에 있는지 확인하는 과정입니다.\n중요성: 잘못된 입력이나 악의적으로 조작된 데이터는 SQL 인젝션, 크로스사이트 스크립팅(XSS) 등 보안 취약점을 유발할 수 있습니다.\n예: 사용자 입력을 받을 때 정규 표현식을 이용해 올바른 형식인지 확인하거나, 파라미터의 길이와 범위를 제한하는 방식이 있습니다.\n\n\n에러 및 예외 처리\n\n정의: 코드 실행 중 발생할 수 있는 예외 상황을 사전에 예측하고, 이를 적절하게 처리하는 방법입니다.\n중요성: 예외를 제대로 처리하지 않으면 프로그램이 중단되거나 민감한 정보(예: 스택 트레이스)를 노출할 위험이 있습니다.\n예: try-catch 블록을 활용해 예외 발생 시 안전하게 로그를 남기고, 사용자에게 친절한 오류 메시지를 제공하는 방법이 있습니다.\n\n\n메모리 안전성\n\n정의: 메모리 할당과 해제를 올바르게 관리하여 버퍼 오버플로우, 메모리 누수 등의 문제를 예방하는 것입니다.\n중요성: 특히 C/C++ 같은 언어에서는 메모리 관리를 제대로 하지 않으면 시스템 전체에 영향을 미치는 심각한 버그나 보안 취약점이 발생할 수 있습니다.\n예: 안전한 라이브러리나 현대적인 언어(예: Rust, Java)를 사용하여 메모리 안전성을 높일 수 있습니다.\n\n\n동시성 및 스레드 안전성\n\n정의: 멀티스레딩이나 병렬 처리를 사용할 때, 데이터 경쟁(race condition)이나 데드락(deadlock) 등의 문제가 발생하지 않도록 하는 것입니다.\n중요성: 동시 접근되는 자원에 대해 적절한 동기화가 이루어지지 않으면 예측하지 못한 동작이나 시스템 충돌이 발생할 수 있습니다.\n예: 뮤텍스, 세마포어 등의 동기화 도구를 활용하거나, 불변 객체(Immutable Object)를 사용하는 방법이 있습니다.\n\n\n\n코드의 안정성을 보장하는 방법\n\n코드 리뷰와 정적 분석\n\n정의: 동료 개발자와의 코드 리뷰나 자동화된 정적 분석 도구를 사용하여 코드 내 잠재적인 버그나 보안 취약점을 사전에 발견하는 과정입니다.\n중요성: 여러 사람이 함께 검토함으로써 개인이 놓칠 수 있는 실수를 보완하고, 보다 안전한 코드를 작성할 수 있습니다.\n예: SonarQube, Coverity, ESLint 등과 같은 도구를 활용해 코드를 분석할 수 있습니다.\n\n\n최소 권한 원칙 및 보안 정책 준수\n\n정의: 애플리케이션이나 프로세스가 필요한 최소한의 권한만을 가지도록 하여, 만약의 경우 피해를 최소화하는 원칙입니다.\n중요성: 불필요하게 높은 권한은 보안 침해 시 공격 범위를 넓힐 수 있으므로, 최소한의 권한으로 실행되도록 하는 것이 좋습니다.\n예: 데이터베이스 계정이나 운영체제 사용자 권한을 최소한으로 설정하여, 시스템 전체에 영향을 미치지 않도록 합니다.\n\n\n최신 보안 패치 및 의존성 관리\n\n정의: 사용 중인 라이브러리나 프레임워크의 최신 보안 패치를 적용하고, 불필요한 의존성을 제거하는 작업입니다.\n중요성: 알려진 취약점이 있는 구버전의 라이브러리를 사용하면, 해커들이 이를 악용할 위험이 있습니다.\n예: 정기적으로 의존성을 점검하고, 업데이트 가능한 부분은 신속하게 업데이트하는 것이 좋습니다.\n\n\n테스트 및 지속적 통합(CI)\n\n정의: 단위 테스트, 통합 테스트, 보안 테스트 등 다양한 테스트 과정을 통해 코드의 안전성을 검증하는 방법입니다.\n중요성: 코드를 변경할 때마다 자동화된 테스트를 통해 오류나 취약점이 새로 발생하지 않았는지 확인할 수 있습니다.\n예: Jenkins, GitHub Actions 등을 활용하여 지속적 통합 환경을 구축하고, 테스트 커버리지를 높이는 것이 도움이 됩니다.\n\n\n"},"코드의-유지보수성":{"title":"코드의 유지보수성","links":[],"tags":[],"content":"코드의 유지보수성은 프로그램이 시간이 지나면서 수정, 확장, 버그 수정 및 최적화를 얼마나 쉽게 할 수 있는가를 나타내는 소프트웨어 품질의 중요한 측면입니다. 유지보수성이 좋은 코드는 새로운 기능 추가나 문제 해결이 필요할 때 빠르고 안전하게 변경할 수 있어 전체 개발 비용과 시간을 줄이는 데 큰 도움이 됩니다.\n다음은 코드 유지보수성을 높이는 주요 요소들입니다:\n\n\n가독성 (Readability):\n\n명확한 네이밍: 변수, 함수, 클래스의 이름을 직관적으로 지어 코드를 읽는 사람이 기능과 목적을 쉽게 파악할 수 있도록 합니다.\n주석과 문서화: 복잡한 로직이나 의도된 설계 결정을 주석이나 문서에 기록하면, 다른 개발자나 미래의 자신이 코드를 이해하는 데 도움이 됩니다.\n\n\n\n모듈화 (Modularity):\n\n분리된 책임 (Separation of Concerns): 코드의 각 부분이 한 가지 역할만 수행하도록 설계하면, 특정 기능의 변경이 다른 부분에 미치는 영향을 최소화할 수 있습니다.\n재사용성: 모듈이나 함수가 재사용 가능하게 설계되면, 동일한 코드를 반복해서 작성할 필요가 없어 유지보수가 용이해집니다.\n\n\n\n코드 일관성 (Consistency):\n\n코딩 표준과 스타일 가이드: 팀 내에서 일관된 코딩 스타일과 규칙을 준수하면, 여러 명의 개발자가 작업할 때 코드의 일관성이 유지되어 이해와 수정이 쉬워집니다.\n자동화된 포매팅 도구: Prettier, ESLint, Black 등과 같은 도구를 사용하면, 코드 스타일을 자동으로 정리하여 일관성을 높일 수 있습니다.\n\n\n\n테스트와 디버깅 (Testing &amp; Debugging):\n\n자동화된 테스트: 단위 테스트, 통합 테스트, 회귀 테스트 등 자동화된 테스트를 통해 코드의 변경이 예상치 못한 부작용을 일으키지 않도록 보장합니다.\n로깅과 예외 처리: 적절한 로깅 및 예외 처리는 문제가 발생했을 때 원인을 빠르게 파악할 수 있게 도와줍니다.\n\n\n\n리팩토링 (Refactoring):\n\n지속적인 개선: 코드가 작동한다고 해서 그대로 둔다기보다는, 정기적으로 코드를 리팩토링하여 가독성, 성능, 구조 등을 개선하는 것이 유지보수성에 큰 도움이 됩니다.\n\n\n\n디자인 원칙 준수:\n\nSOLID 원칙: 단일 책임 원칙, 개방-폐쇄 원칙 등 SOLID 원칙을 따르는 코드는 변화에 유연하게 대응할 수 있습니다.\nDRY (Don’t Repeat Yourself): 중복 코드를 제거하면 유지보수가 쉬워지고, 한 곳에서의 변경이 전체 시스템에 반영되도록 할 수 있습니다.\n\n\n"},"코드의-확장성(Extensibility)":{"title":"코드의 확장성(Extensibility)","links":["SOLID-원칙"],"tags":[],"content":"1. 코드의 확장성이란 무엇인가?\n코드의 **확장성(Extensibility)**은 소프트웨어 시스템에서 새로운 기능이나 모듈을 추가하거나 기존 기능을 변경할 때, 기존 코드베이스에 대한 수정 없이 또는 최소한의 수정으로 이러한 변경을 용이하게 수행할 수 있는 능력을 말합니다. 이는 시스템이 성장하거나 변화하는 요구 사항에 유연하고 효율적으로 대응할 수 있음을 의미합니다.\n\n2. 코드 확장성이 중요한 이유\n\n유연한 대응력 향상: 비즈니스 환경과 사용자 요구사항은 지속적으로 변화합니다. 확장성 있는 코드는 이러한 변화에 신속하게 대응할 수 있도록 합니다.\n개발 효율성 증가: 새로운 기능 추가 시 기존 코드를 재사용하고 최소한의 노력으로 확장이 가능하므로 개발 시간과 비용을 절약할 수 있습니다.\n유지보수성 개선: 코드의 구조가 명확하고 모듈화되어 있어 버그 수정과 기능 개선 작업이 용이합니다.\n시스템 안정성 향상: 기존 코드에 대한 수정이 최소화되므로 새로운 기능 추가 시 발생할 수 있는 예기치 않은 오류를 줄일 수 있습니다.\n\n\n3. 코드의 확장성을 높이는 방법\na. SOLID 원칙 준수\n\n\n단일 책임 원칙 (Single Responsibility Principle): 클래스나 모듈은 하나의 책임만 가져야 합니다. 이를 통해 코드의 변경이 해당 책임 영역에 한정되며, 다른 부분에 영향을 주지 않습니다.\n\n\n개방-폐쇄 원칙 (Open/Closed Principle): 소프트웨어 구성 요소는 확장에 열려 있고 변경에 닫혀 있어야 합니다. 새로운 기능 추가 시 기존 코드를 수정하지 않고도 확장할 수 있어야 합니다.\n\n\n리스코프 치환 원칙 (Liskov Substitution Principle): 서브타입은 언제나 기반 타입으로 대체될 수 있어야 합니다. 이를 통해 객체지향 프로그래밍에서 상속과 다형성을 활용하여 코드 확장이 가능해집니다.\n\n\n인터페이스 분리 원칙 (Interface Segregation Principle): 클라이언트는 자신이 사용하지 않는 메서드에 의존하지 않도록 인터페이스를 구체적이고 작은 단위로 분리해야 합니다.\n\n\n의존 역전 원칙 (Dependency Inversion Principle): 고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 둘 다 추상화에 의존해야 합니다. 이를 통해 모듈 간 결합도를 낮추고 유연한 시스템 구성이 가능합니다.\n\n\nb. 디자인 패턴 활용\n\n\n전략 패턴 (Strategy Pattern): 알고리즘군을 정의하고 각각을 캡슐화하여 상호 교환 가능하게 만드는 패턴으로, 런타임 시 알고리즘을 변경할 수 있어 코드 확장에 유용합니다.\n\n\n데코레이터 패턴 (Decorator Pattern): 객체에 추가적인 책임을 동적으로 부여할 수 있게 해주는 패턴으로, 상속 대신 조합을 사용하여 기능을 확장합니다.\n\n\n팩토리 패턴 (Factory Pattern): 객체 생성 로직을 별도의 팩토리 클래스로 분리하여 객체 생성 과정을 캡슐화하고 유연성을 높입니다.\n\n\nc. 모듈화와 레이어드 아키텍처\n\n코드와 기능을 모듈화하여 각 모듈이 독립적으로 개발, 테스트, 배포될 수 있도록 합니다.\n레이어드 아키텍처를 적용하여 각 계층 간의 의존성을 관리하고, 변경 사항이 다른 계층에 최소한의 영향을 주도록 설계합니다.\n\nd. 추상화와 인터페이스 활용\n\n구체적인 구현에 의존하지 않고 추상화된 인터페이스를 통해 상호 작용함으로써 구현 변경 시 영향 범위를 최소화합니다.\n인터페이스와 추상 클래스는 다양한 구현체를 수용할 수 있어 확장성이 높아집니다.\n\ne. 의존성 주입 (Dependency Injection)\n\n클래스 간의 의존성을 외부에서 주입받는 방식으로 관리하여 결합도를 낮춥니다.\n이를 통해 모듈 교체나 확장이 쉬워지고, 테스트 용이성도 향상됩니다.\n\nf. 이벤트 드리븐 아키텍처\n\n시스템 간의 통신을 이벤트 기반으로 설계하여 각 컴포넌트가 느슨하게 결합되도록 합니다.\n새로운 이벤트 핸들러를 추가하여 기능을 확장할 수 있으므로 유연성이 높습니다.\n\ng. 플러그인 아키텍처\n\n핵심 시스템과 확장 기능을 분리하여, 플러그인 형태로 기능을 추가하거나 제거할 수 있도록 설계합니다.\n대표적인 예로 IDE의 플러그인 시스템이나 웹 브라우저의 확장 기능 등이 있습니다.\n\nh. 마이크로서비스 아키텍처\n\n애플리케이션을 작은 서비스 단위로 분해하여 각 서비스가 독립적으로 배포 및 확장될 수 있도록 합니다.\n서비스 간 통신은 API를 통해 이루어지며, 각 서비스는 독립적인 데이터베이스와 비즈니스 로직을 가집니다.\n\n\n4. 코드 확장성 구현 시 고려사항\n\n과도한 추상화와 설계 복잡도: 확장성을 추구하다 보면 오히려 복잡도가 높아질 수 있으므로 균형 있는 설계가 필요합니다.\n퍼포먼스 영향: 추상화 계층이 늘어나면 성능 저하가 발생할 수 있으므로 성능과 확장성 사이의 트레이드오프를 고려해야 합니다.\n팀의 이해도: 복잡한 아키텍처나 패턴을 도입할 경우 팀원들의 이해도와 숙련도가 이를 뒷받침해야 합니다.\n명확한 규약과 문서화: 확장 가능한 시스템에서는 모듈 간 인터페이스와 통신 규약이 명확해야 하며, 이에 대한 문서화가 필수적입니다.\n\n\n5. 결론\n코드의 확장성은 소프트웨어 개발에서 지속 가능한 성장과 유지보수를 가능하게 하는 핵심 요소입니다. 처음부터 확장성을 고려하여 설계하고 구현하면, 변화하는 요구 사항에 유연하게 대응할 수 있으며, 개발 효율성과 시스템 안정성을 높일 수 있습니다. 이를 위해 SOLID 원칙을 준수하고, 적절한 디자인 패턴과 아키텍처를 활용하며, 모듈화와 추상화를 통해 코드를 구조화하는 것이 중요합니다.\n\n참고자료\n\nRobert C. Martin, “Clean Code: A Handbook of Agile Software Craftsmanship”\nErich Gamma 외 3인, “Design Patterns: Elements of Reusable Object-Oriented Software”\nMartin Fowler, “Refactoring: Improving the Design of Existing Code”\n"},"클래스-기반-언어(Class-based-Language)":{"title":"클래스 기반 언어(Class-based Language)","links":["객체-지향-언어","클래스-기반-언어가-아니면서-OOP-패러다임을-따르는-언어"],"tags":[],"content":"정의\n클래스 기반 언어는 객체 지향 언어 패러다임을 따르는 언어 중에서, **클래스(class)**를 중심으로 객체(object)를 생성하고 관리하는 방식을 채택한 언어를 의미한다.\n\n클래스 : 데이터(필드,상태)와 이를 조작하는 메서드(행동, 프로시즈)를 포함하는 청사진(템플릿) 역할을 한다.\n클래스를 기반으로 인스턴스(instance, 객체)를 생성하며, 이 객체들이 프로그램의 실행 주체가 된다.\n\n관련 자료\n클래스 기반 언어가 아니면서 OOP 패러다임을 따르는 언어"},"클래스-기반-언어가-아니면서-OOP-패러다임을-따르는-언어":{"title":"클래스 기반 언어가 아니면서 OOP 패러다임을 따르는 언어","links":["프로토타입-기반-언어","클래스-기번-언어와-프로토-타입-기반-언어의-차이점","모듈-기반-OOP","클래스-없이도-객체-지향을-지원하는-이유"],"tags":[],"content":"\n프로토타입 기반 언어  - 클래스 기번 언어와 프로토 타입 기반 언어의 차이점\n모듈 기반 OOP\n\n클래스 없이도 객체 지향을 지원하는 이유"},"클래스-기번-언어와-프로토-타입-기반-언어의-차이점":{"title":"클래스 기번 언어와 프로토 타입 기반 언어의 차이점","links":["전략-디자인-패턴(Strategy-Design-Pattern)"],"tags":[],"content":"1 . 개념적 차이\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n프로토타입 기반 언어클래스 기반 언어객체 생성 방식기존 객체를 복사(Prototype)하여 새로운 객체를 생성클래스를 정의하고, 클래스를 기반으로 객체를 생성(인스턴스화)상속 구조객체 간의 직접적인 복제 및 프로토타입 체인을 통해 상속클래스를 통한 계층적 상속 구조(부모 → 자식)유연성런타임에 동적으로 속성과 메서드를 추가 가능객체 구조가 클래스 정의에 의해 제한됨코드 재사용프로토타입을 복사하여 공유상속과 추상화를 통해 재사용\n\n대표 언어\n\n프로토타입 기반 언어: JavaScript, Lua, Self 등\n클래스 기반 언어: Java, C++, Python, C#, Swift 등\n\n\n2. 장단점 비교\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n프로토타입 기반 언어클래스 기반 언어장점- 객체 간 직접적인 상속이 가능하여 유연함  - 런타임에 객체 수정이 가능하여 동적 개발이 쉬움  - 단순한 개념(클래스 없이도 객체를 만들고 사용할 수 있음)- 명확한 설계와 강력한 타입 시스템으로 유지보수 용이  - 코드 재사용성이 높고 대규모 시스템 개발에 적합  - 캡슐화, 다형성, 상속 등 OOP 원칙을 준수하여 구조적 코드 작성 가능단점- 대규모 프로젝트에서 구조적 설계가 어렵고 유지보수가 힘듦  - 객체 간 상속 구조가 복잡해질 수 있음  - 성능 최적화가 어렵고, 예측하기 어려운 동작이 발생할 수 있음- 클래스 설계가 필요하여 초기 개발 속도가 느릴 수 있음  - 유연성이 떨어지고, 실행 중 객체 수정이 어려움(전략 패턴을 사용하면 완화 가능)  - 상속 관계가 깊어질 경우 코드가 복잡해지고 유지보수가 어려울 수 있음\n\n3. 각 언어가 적합한 사례\n✅ 프로토타입 기반 언어가 적합한 경우\n\n동적인 객체 조작이 필요한 경우\n\nJavaScript의 브라우저 환경에서 동적으로 DOM을 조작하거나 이벤트 리스너를 추가하는 경우.\n\n\n빠른 프로토타이핑이 필요한 경우\n\nMVP(최소 기능 제품) 개발 시 클래스 설계 없이 빠르게 객체를 만들고 테스트 가능.\n\n\n플러그인 시스템이나 확장성이 중요한 경우\n\n예: 웹 브라우저의 확장 프로그램, 게임 엔진의 스크립팅 시스템(Lua 기반).\n\n\n\n✅ 클래스 기반 언어가 적합한 경우\n\n대규모 소프트웨어 개발\n\n엔터프라이즈 애플리케이션(Java, C#), 금융 시스템, ERP 등 유지보수가 중요한 프로젝트.\n\n\n안정성과 명확한 설계가 필요한 경우\n\n예: 은행 시스템, 의료 소프트웨어 등.\n\n\n객체지향 설계 패턴을 적용하고 싶은 경우\n\n예: Java의 Spring 프레임워크, Python의 Django 등.\n\n\n\n\n4. 정리\n\n프로토타입 기반 언어는 유연하고 동적이지만, 구조화가 어렵고 유지보수가 힘듦.\n클래스 기반 언어는 구조적이고 안정적이지만, 유연성이 떨어지고 초기 개발 속도가 느릴 수 있음.\n선택 기준은 프로젝트의 규모, 요구사항, 유지보수 용이성 등에 따라 달라짐.\n"},"클래스-없이도-객체-지향을-지원하는-이유":{"title":"클래스 없이도 객체 지향을 지원하는 이유","links":[],"tags":[],"content":"클래스 없이도 객체 지향을 지원하는 이유는 객체의 **상태(state)**와 **행동(behavior)**을 캡슐화하고, 객체들 간의 상호작용을 다루는 방식에 집중하기 때문입니다. 객체 지향의 핵심 개념인 캡슐화, 상속, 다형성은 클래스 없이도 구현할 수 있습니다. 클래스는 단지 이 개념을 표현하는 하나의 방법일 뿐입니다."},"패키지의-한계와-문제점":{"title":"패키지의 한계와 문제점","links":["자바-모듈"],"tags":[],"content":"패키지의 한계와 문제점\n자바에서 패키지는 클래스와 인터페이스를 논리적인 그룹으로 묶어주는 역할을 합니다. 이를 통해 네임스페이스를 관리하고, 클래스 간의 충돌을 방지하며, 코드의 조직화를 돕습니다. 하지만 패키지만으로는 다음과 같은 한계가 있습니다.\n1. 캡슐화의 제한\n\n공개 범위의 한계: public으로 선언된 클래스나 인터페이스는 모든 패키지에서 접근 가능합니다. 내부 구현 클래스를 외부에 노출하고 싶지 않아도, 패키지 간에 접근하려면 public으로 선언해야 합니다.\n접근 제어의 부족: 패키지 수준 접근 제어(default 접근 제어자)는 같은 패키지 내에서만 유효하며, 다른 패키지로 분리된 경우 적용되지 않습니다.\n\n2. 의존성 관리의 부족\n\n패키지 간 의존성을 명시적으로 관리할 수 없습니다.\n어떤 패키지가 어떤 패키지에 의존하는지 추적하기 어렵고, 의도하지 않은 의존성이 생길 수 있습니다.\n\n3. 중복과 충돌의 가능성\n\n동일한 이름의 패키지가 다른 라이브러리나 모듈에서 존재할 경우, 클래스 충돌이 발생할 수 있습니다.\n패키지만으로는 이러한 충돌을 효과적으로 방지하기 어렵습니다.\n\n\n예시 코드를 통한 설명\n상황 설정\n두 개의 패키지 com.example.api와 com.example.impl가 있다고 가정해봅시다.\n\ncom.example.api 패키지는 외부에 공개해야 하는 공개 API를 포함합니다.\ncom.example.impl 패키지는 내부 구현을 포함하며, 외부에서 접근하지 못하도록 하고 싶습니다.\n\n패키지만 사용한 경우\ncom/example/api/MyService.java\npackage com.example.api;\n \nimport com.example.impl.InternalLogic;\n \npublic class MyService {\n    public void performAction() {\n        InternalLogic logic = new InternalLogic();\n        logic.execute();\n    }\n}\ncom/example/impl/InternalLogic.java\npackage com.example.impl;\n \npublic class InternalLogic {\n    public void execute() {\n        System.out.println(&quot;Executing internal logic...&quot;);\n    }\n}\n\nMyService 클래스는 공개 API로서 외부에 노출되어야 하므로 public으로 선언됩니다.\nInternalLogic 클래스는 내부 구현이므로 외부에 노출되지 않기를 원하지만, MyService에서 접근하려면 public으로 선언해야 합니다.\n\n문제점\n\nInternalLogic 클래스가 public으로 선언되어 있어, 외부 패키지에서도 접근이 가능합니다.\n즉, 내부 구현이 외부에 노출되어 캡슐화가 깨집니다.\n\n외부에서 InternalLogic에 접근하는 코드\npackage com.example.external;\n \nimport com.example.impl.InternalLogic;\n \npublic class ExternalUsage {\n    public static void main(String[] args) {\n        InternalLogic logic = new InternalLogic();\n        logic.execute();  // 내부 구현에 직접 접근\n    }\n}\n위의 코드는 우리가 원치 않는 방식으로 내부 구현에 접근하고 있습니다.\n\n자바 모듈을 이용한 해결 방법\n자바 9부터 도입된 모듈 시스템을 사용하면 이 문제를 해결할 수 있습니다.\n모듈 정의\n프로젝트에 모듈을 정의하고, module-info.java 파일을 생성합니다.\nmodule-info.java\nmodule com.example.module {\n    exports com.example.api;\n    // com.example.impl 패키지는 외부에 공개하지 않음\n}\n\nexports com.example.api;를 통해 com.example.api 패키지만 외부에 공개합니다.\ncom.example.impl 패키지는 exports하지 않으므로, 모듈 외부에서 접근할 수 없습니다.\n\n수정된 코드\nInternalLogic 클래스는 이전과 동일하게 public으로 선언되어 있지만, 모듈 시스템을 통해 외부에서의 접근을 막을 수 있습니다.\ncom/example/api/MyService.java\npackage com.example.api;\n \nimport com.example.impl.InternalLogic;\n \npublic class MyService {\n    public void performAction() {\n        InternalLogic logic = new InternalLogic();\n        logic.execute();\n    }\n}\ncom/example/impl/InternalLogic.java\npackage com.example.impl;\n \npublic class InternalLogic {\n    public void execute() {\n        System.out.println(&quot;Executing internal logic...&quot;);\n    }\n}\n외부에서 접근 시도\ncom.example.external.ExternalUsage.java\npackage com.example.external;\n \nimport com.example.impl.InternalLogic;\n \npublic class ExternalUsage {\n    public static void main(String[] args) {\n        InternalLogic logic = new InternalLogic();\n        logic.execute();\n    }\n}\n컴파일 시 오류 발생\n모듈 시스템에서는 com.example.impl 패키지를 외부에 공개하지 않았기 때문에, com.example.external 패키지에서 InternalLogic 클래스에 접근할 수 없습니다.\n컴파일 시 다음과 같은 오류가 발생합니다.\ncom/example/external/ExternalUsage.java:3: error: package com.example.impl is not visible\nimport com.example.impl.InternalLogic;\n                     ^\n  (package com.example.impl is declared in module com.example.module, which does not export it)\n1 error\n\n\n모듈 시스템을 통해 내부 구현을 안전하게 숨길 수 있습니다.\n패키지 수준의 캡슐화를 넘어선 모듈 수준의 캡슐화를 제공합니다.\n\n\n모듈 시스템의 의존성 관리\n모듈 시스템은 의존성도 명시적으로 관리할 수 있습니다.\n다른 모듈이 있는 경우\n예를 들어, com.example.utils라는 별도의 모듈이 있다고 가정해봅시다.\ncom.example.utils/module-info.java\nmodule com.example.utils {\n    exports com.example.utils;\n}\ncom/example/utils/Utility.java\npackage com.example.utils;\n \npublic class Utility {\n    public void helperMethod() {\n        System.out.println(&quot;Utility helper method.&quot;);\n    }\n}\n이제 com.example.module에서 이 유틸리티 모듈을 사용하려면, 의존성을 명시적으로 선언해야 합니다.\ncom.example.module/module-info.java\nmodule com.example.module {\n    exports com.example.api;\n    requires com.example.utils;\n}\n\nrequires com.example.utils;를 통해 의존성을 선언합니다.\n\n코드에서의 사용\ncom/example/api/MyService.java\npackage com.example.api;\n \nimport com.example.impl.InternalLogic;\nimport com.example.utils.Utility;\n \npublic class MyService {\n    public void performAction() {\n        InternalLogic logic = new InternalLogic();\n        Utility util = new Utility();\n        logic.execute();\n        util.helperMethod();\n    }\n}\n\n요약\n\n패키지의 한계: 패키지 만으로는 원하는 수준의 캡슐화를 제공하기 어렵습니다. 특히, public 멤버나 클래스를 외부에서 접근하지 못하게 제어할 수 없습니다.\n모듈의 도입: 모듈 시스템을 사용하면 모듈 단위로 어떤 패키지를 외부에 공개할지 (exports) 명시적으로 결정할 수 있습니다.\n내부 구현 숨기기: 모듈에서 exports하지 않은 패키지는 모듈 외부에서 접근할 수 없으므로, 내부 구현을 안전하게 숨길 수 있습니다.\n의존성 관리: 모듈 간의 의존성을 requires 키워드를 통해 명시적으로 선언하여, 의존성 관계를 명확히 하고 충돌을 방지할 수 있습니다.\n\n\n결론\n패키지는 클래스와 인터페이스를 그룹화하고 네임스페이스를 관리하는 데 유용하지만, 대규모 애플리케이션에서 다음과 같은 문제를 해결하기에는 한계가 있습니다.\n\n캡슐화의 제한: 내부 구현을 완전히 숨길 수 없습니다.\n의존성 관리의 부족: 패키지 간 의존성을 명시적으로 관리하기 어렵습니다.\n모듈러리티 부족: 재사용성과 유지보수성을 높이기 위한 모듈 단위의 설계가 어렵습니다.\n\n모듈 시스템은 이러한 문제를 해결하기 위해 도입되었으며, 다음과 같은 이점을 제공합니다.\n\n강력한 캡슐화: 모듈 단위로 패키지의 공개 여부를 제어하여 내부 구현을 숨길 수 있습니다.\n명시적인 의존성 관리: 모듈 간의 의존성을 선언하여 관계를 명확히 합니다.\n코드 조직화 개선: 코드를 모듈 단위로 조직화하여 유지보수성과 재사용성을 높입니다.\n보안성과 안정성 향상: 내부 구현의 노출을 방지하여 보안성을 높이고, 의존성 충돌을 방지하여 애플리케이션의 안정성을 향상시킵니다.\n\n\n혹시 더 궁금한 점이나 추가로 알고 싶은 부분이 있다면 언제든지 질문해 주세요!"},"프로덕션-언어(Production-Language)":{"title":"프로덕션 언어(Production Language)","links":["코드의-안정성","코드의-유지보수성","대규모-시스템에-적합한-언어"],"tags":[],"content":"\n실제 소프트웨어 개발에서 널리 사용될 목적으로 설계된 언어. 안정성, 유지보수성, 성능이 중요하게 고려됌\n연구, 학습, 실험적인 목적보다는 상용 제품 개발을 목표로 하며, 대규모 시스템에서도 안정적으로 동작할 수 있도록 설계됌\n\n대표적인 프로덕션 언어\n\nJava: 안정성과 유지보수성이 뛰어나고, 대규모 시스템에 적합한 언어.\nC++: 성능이 중요한 곳(게임 엔진, 시스템 프로그래밍)에서 많이 사용됨.\nPython: 빠른 개발과 높은 생산성이 요구되는 곳에서 사용됨(웹, 데이터 과학, AI).\nGo: 멀티쓰레드 환경과 네트워크 프로그래밍에 강점이 있음.\nRust: 메모리 안전성을 보장하면서도 높은 성능을 제공.\nTypeScript: JavaScript의 단점을 보완하여 유지보수성이 높은 웹 애플리케이션 개발에 사용됨.\n"},"프로토타입-기반-언어":{"title":"프로토타입 기반 언어","links":[],"tags":[],"content":"프로토타입 기반 언어는 클래스를 사용하지 않고 객체를 생성하는 방식입니다. 대신, 객체는 다른 객체를 **프로토타입(prototype)**으로 하여 복제됩니다. 즉, 객체는 다른 객체를 기반으로 하여 자신의 특성(속성 및 메서드)을 상속받습니다.\n프로토타입 기반 언어의 동작 방식\n\n\n객체 생성과 프로토타입 연결\n\n프로토타입 기반 언어에서 객체는 **기존 객체를 복제(clone)**하거나 프로토타입을 설정하여 생성됩니다. 객체는 다른 객체를 프로토타입으로 설정할 수 있으며, 이를 통해 상속을 구현합니다.\n각 객체는 자신의 프로토타입을 참조하고 있으며, 프로토타입 체인을 통해 객체 간 상속이 이루어집니다.\n\n\n\n프로토타입 체인 (Prototype Chain)\n\n객체는 자기 자신의 속성이나 메서드를 찾을 수 없으면, 해당 객체의 프로토타입에서 이를 찾습니다. 만약 프로토타입에도 없다면, 그 프로토타입의 프로토타입에서 계속해서 찾습니다.\n이 과정은 프로토타입 체인(prototype chain)이라 불리며, 객체가 참조하는 모든 부모 객체를 따라가며 속성이나 메서드를 탐색하는 방식입니다.\n결국, **null**까지 탐색이 이루어지고, 만약 null에서도 찾을 수 없다면 해당 속성은 undefined가 됩니다.\n\n\n\n예시 코드 실행\n"},"개발-공부-노트-정리에-옵시디언을-사용하는-이유":{"title":"개발 공부 노트 정리에 옵시디언을 사용하는 이유","links":["옵시디언-Templater-플러그인","옵시디언-Periodic-Notes-플러그인","옵시디언-Tasks-플러그인"],"tags":[],"content":"개발자로서 새로운 기술과 지식을 습득하는 것은 일상입니다. 매일매일 쏟아지는 정보와 학습 내용을 효율적으로 정리하고 관리하는 것은 생산성을 높이는 데 필수적입니다. 여러 노트 앱과 도구들이 있지만, 그 중에서도 최근 주목받는 것이 바로 옵시디언(Obsidian) 입니다. 왜 많은 개발자들이 옵시디언을 선택하는지 그 이유를 알아보겠습니다.\n1. Markdown 기반의 편집 환경\n옵시디언은 Markdown 언어를 기반으로 합니다. 이는 가벼우면서도 가독성이 높은 문서 작성을 가능하게 합니다. 코드 스니펫, 명령어, 리스트 등을 손쉽게 작성할 수 있어 개발자들에게 친숙합니다.\n# 클래스 다이어그램\n \n- **클래스명**\n  - 속성\n  - 메서드\n위처럼 간단한 문법으로 구조화된 노트를 작성할 수 있습니다.\n2. 노트 간의 자유로운 연결\n학습 내용을 정리하다 보면, 서로 연관된 개념이나 참고할 자료들이 생깁니다. 옵시디언은 백링크(Backlink) 기능을 통해 노트 간의 유기적인 연결을 지원합니다. 이는 마치 위키피디아처럼 노트들이 서로 연결되어 지식의 맵을 형성하게 합니다.\n3. 그래프 뷰를 통한 시각화\n옵시디언의 그래프 뷰(Graph View) 기능은 노트들 간의 연결 상태를 한눈에 보여줍니다. 이를 통해 내가 어떤 분야를 집중적으로 공부했는지, 어느 부분이 부족한지 파악하기 쉽습니다.\n\n4. 플러그인으로 확장성 강화\n오픈소스 커뮤니티에서 제공하는 다양한 플러그인을 통해 기능을 확장할 수 있습니다. 코드 하이라이팅, 테이블 생성, 수학 공식 렌더링 등 개발자에게 유용한 기능들을 추가로 적용할 수 있습니다.\n아래 플러그인은 모두에게 추천하는 좋은 플러그인 입니다.\n\n옵시디언 Templater 플러그인\n옵시디언 Periodic Notes 플러그인\n옵시디언 Tasks 플러그인\n\n5. 로컬 기반으로 보안 및 소유권 확보\n옵시디언은 노트를 로컬에 저장합니다. 이는 클라우드 기반의 노트 앱에서 발생할 수 있는 보안 문제나 서비스 종료에 대한 걱정 없이 데이터를 안전하게 보관할 수 있음을 의미합니다. 또한, Git과 연동하여 버전 관리를 할 수도 있습니다.\n6. 플랫폼 간의 호환성\nWindows, macOS, Linux는 물론 모바일(Android, iOS)까지 지원하여 언제 어디서나 노트에 접근하고 편집할 수 있습니다. 이는 개발 환경에 구애받지 않고 일관된 학습이 가능하다는 장점이 있습니다.\n7. 무료로 제공되는 강력한 기능\n옵시디언은 개인 사용에 한해 무료로 제공됩니다. 강력한 기능들을 비용 부담 없이 사용할 수 있어 개인 개발자나 학생들에게 특히 유용합니다.\n결론\n개발 공부는 지속적이고 체계적인 관리가 필요합니다. 옵시디언은 이러한 요구에 부합하는 강력한 노트 정리 도구로서, 개발자들의 생산성과 학습 효율을 높여줍니다."},"attachements/Untitled":{"title":"Untitled","links":[],"tags":[],"content":""}}