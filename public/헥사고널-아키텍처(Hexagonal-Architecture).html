<!DOCTYPE html>
<html lang="ko"><head><title>헥사고널 아키텍처(Hexagonal Architecture) | Beoks Blog</title><meta charset="utf-8"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=IBM Plex Mono&amp;family=Schibsted Grotesk:wght@400;700&amp;family=Source Sans Pro:ital,wght@0,400;0,600;1,400;1,600&amp;display=swap"/><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin="anonymous"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="og:site_name" content="🪴 Beoks Blog"/><meta property="og:title" content="헥사고널 아키텍처(Hexagonal Architecture) | Beoks Blog"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="헥사고널 아키텍처(Hexagonal Architecture) | Beoks Blog"/><meta name="twitter:description" content="소프트웨어 개발 분야에서 아키텍처는 시스템의 품질, 유지보수성, 확장성을 결정짓는 매우 중요한 요소입니다. 다양한 아키텍처 패턴 중에서, 최근 몇 년간 많은 개발자에게 주목받으며 그 중요성이 강조되고 있는 패턴 중 하나가 바로 헥사고널 아키텍처(Hexagonal Architecture) 입니다."/><meta property="og:description" content="소프트웨어 개발 분야에서 아키텍처는 시스템의 품질, 유지보수성, 확장성을 결정짓는 매우 중요한 요소입니다. 다양한 아키텍처 패턴 중에서, 최근 몇 년간 많은 개발자에게 주목받으며 그 중요성이 강조되고 있는 패턴 중 하나가 바로 헥사고널 아키텍처(Hexagonal Architecture) 입니다."/><meta property="og:image:type" content="image/webp"/><meta property="og:image:alt" content="소프트웨어 개발 분야에서 아키텍처는 시스템의 품질, 유지보수성, 확장성을 결정짓는 매우 중요한 요소입니다. 다양한 아키텍처 패턴 중에서, 최근 몇 년간 많은 개발자에게 주목받으며 그 중요성이 강조되고 있는 패턴 중 하나가 바로 헥사고널 아키텍처(Hexagonal Architecture) 입니다."/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/><meta property="og:image:url" content="https://quartz.jzhao.xyz/static/og-image.png"/><meta name="twitter:image" content="https://quartz.jzhao.xyz/static/og-image.png"/><meta property="og:image" content="https://quartz.jzhao.xyz/static/og-image.png"/><meta property="twitter:domain" content="quartz.jzhao.xyz"/><meta property="og:url" content="https://quartz.jzhao.xyz/헥사고널-아키텍처(Hexagonal-Architecture)"/><meta property="twitter:url" content="https://quartz.jzhao.xyz/헥사고널-아키텍처(Hexagonal-Architecture)"/><link rel="icon" href="./static/icon.png"/><meta name="description" content="소프트웨어 개발 분야에서 아키텍처는 시스템의 품질, 유지보수성, 확장성을 결정짓는 매우 중요한 요소입니다. 다양한 아키텍처 패턴 중에서, 최근 몇 년간 많은 개발자에게 주목받으며 그 중요성이 강조되고 있는 패턴 중 하나가 바로 헥사고널 아키텍처(Hexagonal Architecture) 입니다."/><meta name="generator" content="Quartz"/><link href="./index.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><style>.expand-button {
  position: absolute;
  display: flex;
  float: right;
  padding: 0.4rem;
  margin: 0.3rem;
  right: 0;
  color: var(--gray);
  border-color: var(--dark);
  background-color: var(--light);
  border: 1px solid;
  border-radius: 5px;
  opacity: 0;
  transition: 0.2s;
}
.expand-button > svg {
  fill: var(--light);
  filter: contrast(0.3);
}
.expand-button:hover {
  cursor: pointer;
  border-color: var(--secondary);
}
.expand-button:focus {
  outline: 0;
}

pre:hover > .expand-button {
  opacity: 1;
  transition: 0.2s;
}

#mermaid-container {
  position: fixed;
  contain: layout;
  z-index: 999;
  left: 0;
  top: 0;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
  display: none;
  backdrop-filter: blur(4px);
  background: rgba(0, 0, 0, 0.5);
}
#mermaid-container.active {
  display: inline-block;
}
#mermaid-container > #mermaid-space {
  display: grid;
  width: 90%;
  height: 90vh;
  margin: 5vh auto;
  background: var(--light);
  box-shadow: 0 14px 50px rgba(27, 33, 48, 0.12), 0 10px 30px rgba(27, 33, 48, 0.16);
  overflow: hidden;
  position: relative;
}
#mermaid-container > #mermaid-space > .mermaid-header {
  display: flex;
  justify-content: flex-end;
  padding: 1rem;
  border-bottom: 1px solid var(--lightgray);
  background: var(--light);
  z-index: 2;
  max-height: fit-content;
}
#mermaid-container > #mermaid-space > .mermaid-header > .close-button {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  padding: 0;
  background: transparent;
  border: none;
  border-radius: 4px;
  color: var(--darkgray);
  cursor: pointer;
  transition: all 0.2s ease;
}
#mermaid-container > #mermaid-space > .mermaid-header > .close-button:hover {
  background: var(--lightgray);
  color: var(--dark);
}
#mermaid-container > #mermaid-space > .mermaid-content {
  padding: 2rem;
  position: relative;
  transform-origin: 0 0;
  transition: transform 0.1s ease;
  overflow: visible;
  min-height: 200px;
  min-width: 200px;
}
#mermaid-container > #mermaid-space > .mermaid-content pre {
  margin: 0;
  border: none;
}
#mermaid-container > #mermaid-space > .mermaid-content svg {
  max-width: none;
  height: auto;
}
#mermaid-container > #mermaid-space > .mermaid-controls {
  position: absolute;
  bottom: 20px;
  right: 20px;
  display: flex;
  gap: 8px;
  padding: 8px;
  background: var(--light);
  border: 1px solid var(--lightgray);
  border-radius: 6px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  z-index: 2;
}
#mermaid-container > #mermaid-space > .mermaid-controls .mermaid-control-button {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  padding: 0;
  border: 1px solid var(--lightgray);
  background: var(--light);
  color: var(--dark);
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
  font-family: var(--bodyFont);
  transition: all 0.2s ease;
}
#mermaid-container > #mermaid-space > .mermaid-controls .mermaid-control-button:hover {
  background: var(--lightgray);
}
#mermaid-container > #mermaid-space > .mermaid-controls .mermaid-control-button:active {
  transform: translateY(1px);
}
#mermaid-container > #mermaid-space > .mermaid-controls .mermaid-control-button:nth-child(2) {
  width: auto;
  padding: 0 12px;
  font-size: 14px;
}
/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiL1VzZXJzL2xlZWpzL1Byb2plY3QvYmVva3MuZ2l0aHViLmlvL3F1YXJ0ei9jb21wb25lbnRzL3N0eWxlcyIsInNvdXJjZXMiOlsibWVybWFpZC5pbmxpbmUuc2NzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtFQUNFO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBOztBQUVBO0VBQ0U7RUFDQTs7QUFHRjtFQUNFO0VBQ0E7O0FBR0Y7RUFDRTs7O0FBS0Y7RUFDRTtFQUNBOzs7QUFJSjtFQUNFO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7O0FBRUE7RUFDRTs7QUFHRjtFQUNFO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQSxZQUNFO0VBRUY7RUFDQTs7QUFFQTtFQUNFO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBOztBQUVBO0VBQ0U7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBOztBQUVBO0VBQ0U7RUFDQTs7QUFLTjtFQUNFO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBOztBQUVBO0VBQ0U7RUFDQTs7QUFHRjtFQUNFO0VBQ0E7O0FBSUo7RUFDRTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBOztBQUVBO0VBQ0U7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTs7QUFFQTtFQUNFOztBQUdGO0VBQ0U7O0FBSUY7RUFDRTtFQUNBO0VBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIuZXhwYW5kLWJ1dHRvbiB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxvYXQ6IHJpZ2h0O1xuICBwYWRkaW5nOiAwLjRyZW07XG4gIG1hcmdpbjogMC4zcmVtO1xuICByaWdodDogMDsgLy8gTk9URTogcmlnaHQgd2lsbCBiZSBzZXQgaW4gbWVybWFpZC5pbmxpbmUudHNcbiAgY29sb3I6IHZhcigtLWdyYXkpO1xuICBib3JkZXItY29sb3I6IHZhcigtLWRhcmspO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1saWdodCk7XG4gIGJvcmRlcjogMXB4IHNvbGlkO1xuICBib3JkZXItcmFkaXVzOiA1cHg7XG4gIG9wYWNpdHk6IDA7XG4gIHRyYW5zaXRpb246IDAuMnM7XG5cbiAgJiA+IHN2ZyB7XG4gICAgZmlsbDogdmFyKC0tbGlnaHQpO1xuICAgIGZpbHRlcjogY29udHJhc3QoMC4zKTtcbiAgfVxuXG4gICY6aG92ZXIge1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBib3JkZXItY29sb3I6IHZhcigtLXNlY29uZGFyeSk7XG4gIH1cblxuICAmOmZvY3VzIHtcbiAgICBvdXRsaW5lOiAwO1xuICB9XG59XG5cbnByZSB7XG4gICY6aG92ZXIgPiAuZXhwYW5kLWJ1dHRvbiB7XG4gICAgb3BhY2l0eTogMTtcbiAgICB0cmFuc2l0aW9uOiAwLjJzO1xuICB9XG59XG5cbiNtZXJtYWlkLWNvbnRhaW5lciB7XG4gIHBvc2l0aW9uOiBmaXhlZDtcbiAgY29udGFpbjogbGF5b3V0O1xuICB6LWluZGV4OiA5OTk7XG4gIGxlZnQ6IDA7XG4gIHRvcDogMDtcbiAgd2lkdGg6IDEwMHZ3O1xuICBoZWlnaHQ6IDEwMHZoO1xuICBvdmVyZmxvdzogaGlkZGVuO1xuICBkaXNwbGF5OiBub25lO1xuICBiYWNrZHJvcC1maWx0ZXI6IGJsdXIoNHB4KTtcbiAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjUpO1xuXG4gICYuYWN0aXZlIHtcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gIH1cblxuICAmID4gI21lcm1haWQtc3BhY2Uge1xuICAgIGRpc3BsYXk6IGdyaWQ7XG4gICAgd2lkdGg6IDkwJTtcbiAgICBoZWlnaHQ6IDkwdmg7XG4gICAgbWFyZ2luOiA1dmggYXV0bztcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1saWdodCk7XG4gICAgYm94LXNoYWRvdzpcbiAgICAgIDAgMTRweCA1MHB4IHJnYmEoMjcsIDMzLCA0OCwgMC4xMiksXG4gICAgICAwIDEwcHggMzBweCByZ2JhKDI3LCAzMywgNDgsIDAuMTYpO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuXG4gICAgJiA+IC5tZXJtYWlkLWhlYWRlciB7XG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcbiAgICAgIHBhZGRpbmc6IDFyZW07XG4gICAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgdmFyKC0tbGlnaHRncmF5KTtcbiAgICAgIGJhY2tncm91bmQ6IHZhcigtLWxpZ2h0KTtcbiAgICAgIHotaW5kZXg6IDI7XG4gICAgICBtYXgtaGVpZ2h0OiBmaXQtY29udGVudDtcblxuICAgICAgJiA+IC5jbG9zZS1idXR0b24ge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgd2lkdGg6IDMycHg7XG4gICAgICAgIGhlaWdodDogMzJweDtcbiAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgICAgICBjb2xvcjogdmFyKC0tZGFya2dyYXkpO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIHRyYW5zaXRpb246IGFsbCAwLjJzIGVhc2U7XG5cbiAgICAgICAgJjpob3ZlciB7XG4gICAgICAgICAgYmFja2dyb3VuZDogdmFyKC0tbGlnaHRncmF5KTtcbiAgICAgICAgICBjb2xvcjogdmFyKC0tZGFyayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAmID4gLm1lcm1haWQtY29udGVudCB7XG4gICAgICBwYWRkaW5nOiAycmVtO1xuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgdHJhbnNmb3JtLW9yaWdpbjogMCAwO1xuICAgICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMXMgZWFzZTtcbiAgICAgIG92ZXJmbG93OiB2aXNpYmxlO1xuICAgICAgbWluLWhlaWdodDogMjAwcHg7XG4gICAgICBtaW4td2lkdGg6IDIwMHB4O1xuXG4gICAgICBwcmUge1xuICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgIH1cblxuICAgICAgc3ZnIHtcbiAgICAgICAgbWF4LXdpZHRoOiBub25lO1xuICAgICAgICBoZWlnaHQ6IGF1dG87XG4gICAgICB9XG4gICAgfVxuXG4gICAgJiA+IC5tZXJtYWlkLWNvbnRyb2xzIHtcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIGJvdHRvbTogMjBweDtcbiAgICAgIHJpZ2h0OiAyMHB4O1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGdhcDogOHB4O1xuICAgICAgcGFkZGluZzogOHB4O1xuICAgICAgYmFja2dyb3VuZDogdmFyKC0tbGlnaHQpO1xuICAgICAgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tbGlnaHRncmF5KTtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDZweDtcbiAgICAgIGJveC1zaGFkb3c6IDAgMnB4IDRweCByZ2JhKDAsIDAsIDAsIDAuMSk7XG4gICAgICB6LWluZGV4OiAyO1xuXG4gICAgICAubWVybWFpZC1jb250cm9sLWJ1dHRvbiB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICB3aWR0aDogMzJweDtcbiAgICAgICAgaGVpZ2h0OiAzMnB4O1xuICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCB2YXIoLS1saWdodGdyYXkpO1xuICAgICAgICBiYWNrZ3JvdW5kOiB2YXIoLS1saWdodCk7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1kYXJrKTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIGZvbnQtc2l6ZTogMTZweDtcbiAgICAgICAgZm9udC1mYW1pbHk6IHZhcigtLWJvZHlGb250KTtcbiAgICAgICAgdHJhbnNpdGlvbjogYWxsIDAuMnMgZWFzZTtcblxuICAgICAgICAmOmhvdmVyIHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiB2YXIoLS1saWdodGdyYXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgJjphY3RpdmUge1xuICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgxcHgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3R5bGUgdGhlIHJlc2V0IGJ1dHRvbiBkaWZmZXJlbnRseVxuICAgICAgICAmOm50aC1jaGlsZCgyKSB7XG4gICAgICAgICAgd2lkdGg6IGF1dG87XG4gICAgICAgICAgcGFkZGluZzogMCAxMnB4O1xuICAgICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIl19 */</style><script src="./prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch("./static/contentIndex.json").then(data => data.json())</script></head><body data-slug="헥사고널-아키텍처(Hexagonal-Architecture)"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h2 class="page-title"><a href=".">🪴 Beoks Blog</a></h2><div class="spacer mobile-only"></div><div class="search"><button class="search-button" id="search-button"><p>검색</p><svg role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title>Search</title><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg></button><div id="search-container"><div id="search-space"><input autocomplete="off" id="search-bar" name="search" type="text" aria-label="검색어를 입력하세요" placeholder="검색어를 입력하세요"/><div id="search-layout" data-preview="true"></div></div></div></div><button class="darkmode" id="darkmode"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35" xml:space="preserve" aria-label="다크 모드"><title>다크 모드</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100" xml:space="preserve" aria-label="라이트 모드"><title>라이트 모드</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></button><div class="explorer"><button type="button" id="mobile-explorer" class="collapsed hide-until-loaded" data-behavior="collapse" data-collapsed="collapsed" data-savestate="true" data-tree="[]" data-mobile="true" aria-controls="explorer-content" aria-expanded="false"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-menu"><line x1="4" x2="20" y1="12" y2="12"></line><line x1="4" x2="20" y1="6" y2="6"></line><line x1="4" x2="20" y1="18" y2="18"></line></svg></button><button type="button" id="desktop-explorer" class="title-button" data-behavior="collapse" data-collapsed="collapsed" data-savestate="true" data-tree="[]" data-mobile="false" aria-controls="explorer-content" aria-expanded="true"><h2>탐색기</h2><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="explorer-content"><ul class="overflow" id="explorer-ul"><li><div class="folder-outer open"><ul style="padding-left:0;" class="content" data-folderul><li><div class="folder-outer "><ul style="padding-left:0;" class="content" data-folderul></ul></div></li><li><a href="./-Spring-데이터베이스-커넥션-관리" data-for="-Spring-데이터베이스-커넥션-관리"> Spring 데이터베이스 커넥션 관리</a></li><li><a href="./값-객체(Value-Objects)" data-for="값-객체(Value-Objects)">값 객체(Value Objects)</a></li><li><a href="./개발-공부-노트-정리에-옵시디언을-사용하는-이유" data-for="개발-공부-노트-정리에-옵시디언을-사용하는-이유">개발 공부 노트 정리에 옵시디언을 사용하는 이유</a></li><li><a href="./개방-폐쇄-원칙-(Open-Closed-Principle)" data-for="개방-폐쇄-원칙-(Open-Closed-Principle)">개방-폐쇄 원칙 (Open-Closed Principle)</a></li><li><a href="./객체-지향-프로그래밍-실전-적용법" data-for="객체-지향-프로그래밍-실전-적용법">객체 지향 프로그래밍 실전 적용법</a></li><li><a href="./객체-지향-프로그래밍(OOP)" data-for="객체-지향-프로그래밍(OOP)">객체 지향 프로그래밍(OOP)</a></li><li><a href="./객체-지향-프로그래밍의-4대-원칙" data-for="객체-지향-프로그래밍의-4대-원칙">객체 지향 프로그래밍의 4대 원칙</a></li><li><a href="./경계-값-분석(Boundary-Value-Analysis)" data-for="경계-값-분석(Boundary-Value-Analysis)">경계 값 분석(Boundary Value Analysis)</a></li><li><a href="./경쟁-상태(Race-Condition)" data-for="경쟁-상태(Race-Condition)">경쟁 상태(Race Condition)</a></li><li><a href="./계약-테스트(Contract-Test)" data-for="계약-테스트(Contract-Test)">계약 테스트(Contract Test)</a></li><li><a href="./고가용성(High-Availability)" data-for="고가용성(High-Availability)">고가용성(High Availability)</a></li><li><a href="./고성능-처리-언어" data-for="고성능-처리-언어">고성능 처리 언어</a></li><li><a href="./고수준-언어(High-Level-Language)" data-for="고수준-언어(High-Level-Language)">고수준 언어(High-Level Language)</a></li><li><a href="./공개-키-암호화-(Public-Key-Cryptography)" data-for="공개-키-암호화-(Public-Key-Cryptography)">공개 키 암호화 (Public Key Cryptography)</a></li><li><a href="./공개-키-인프라-(PKI)" data-for="공개-키-인프라-(PKI)">공개 키 인프라 (PKI)</a></li><li><a href="./관심사-분리-(Separation-of-Concerns)" data-for="관심사-분리-(Separation-of-Concerns)">관심사 분리 (Separation of Concerns)</a></li><li><a href="./구매자-페르소나" data-for="구매자-페르소나">구매자 페르소나</a></li><li><a href="./구성-기반-개발(Configuration-Driven-Development)" data-for="구성-기반-개발(Configuration-Driven-Development)">구성 기반 개발(Configuration Driven Development)</a></li><li><a href="./구조-패턴(Structural-Patterns)" data-for="구조-패턴(Structural-Patterns)">구조 패턴(Structural Patterns)</a></li><li><a href="./기능-추가에-따른-RBAC-관리-비용-절감-전략" data-for="기능-추가에-따른-RBAC-관리-비용-절감-전략">기능 추가에 따른 RBAC 관리 비용 절감 전략</a></li><li><a href="./기능-협상(Capability-Negotiation)" data-for="기능-협상(Capability-Negotiation)">기능 협상(Capability Negotiation)</a></li><li><a href="./기술-부채-측정-및-시각화" data-for="기술-부채-측정-및-시각화">기술 부채 측정 및 시각화</a></li><li><a href="./기술-부채(Technical-Debt)" data-for="기술-부채(Technical-Debt)">기술 부채(Technical Debt)</a></li><li><a href="./논블로킹-소켓(Nonblocking-Socket)" data-for="논블로킹-소켓(Nonblocking-Socket)">논블로킹 소켓(Nonblocking Socket)</a></li><li><a href="./논블로킹(Non-blocking)" data-for="논블로킹(Non-blocking)">논블로킹(Non-blocking)</a></li><li><a href="./다형성(Polymorphism)" data-for="다형성(Polymorphism)">다형성(Polymorphism)</a></li><li><a href="./단위-테스트-(Unit-Test)-vs-통합-테스트(Integration-Test)" data-for="단위-테스트-(Unit-Test)-vs-통합-테스트(Integration-Test)">단위 테스트 (Unit Test) vs 통합 테스트(Integration Test)</a></li><li><a href="./단위-테스트(Unit-Test)" data-for="단위-테스트(Unit-Test)">단위 테스트(Unit Test)</a></li><li><a href="./단일-책임-원칙(Single-Responsibility-Principle)" data-for="단일-책임-원칙(Single-Responsibility-Principle)">단일 책임 원칙(Single Responsibility Principle)</a></li><li><a href="./대규모-시스템에-적합한-언어" data-for="대규모-시스템에-적합한-언어">대규모 시스템에 적합한 언어</a></li><li><a href="./데이터-웨어하우스" data-for="데이터-웨어하우스">데이터 웨어하우스</a></li><li><a href="./데코레이터-패턴-(Decorator-Pattern)" data-for="데코레이터-패턴-(Decorator-Pattern)">데코레이터 패턴 (Decorator Pattern)</a></li><li><a href="./데코레이터-패턴(Decorator-Pattern)" data-for="데코레이터-패턴(Decorator-Pattern)">데코레이터 패턴(Decorator Pattern)</a></li><li><a href="./도메인-모델(Domain-Model)" data-for="도메인-모델(Domain-Model)">도메인 모델(Domain Model)</a></li><li><a href="./도메인-주도-설계(DDD,Domain-Driven-Design)" data-for="도메인-주도-설계(DDD,Domain-Driven-Design)">도메인 주도 설계(DDD,Domain Driven Design)</a></li><li><a href="./도메인(Domain)" data-for="도메인(Domain)">도메인(Domain)</a></li><li><a href="./동기-논블로킹(Synchronous-Non-Blocking)" data-for="동기-논블로킹(Synchronous-Non-Blocking)">동기 논블로킹(Synchronous Non-Blocking)</a></li><li><a href="./동기(Synchronous)" data-for="동기(Synchronous)">동기(Synchronous)</a></li><li><a href="./동기와-블로킹의-차이" data-for="동기와-블로킹의-차이">동기와 블로킹의 차이</a></li><li><a href="./동기와-비동기의-차이" data-for="동기와-비동기의-차이">동기와 비동기의 차이</a></li><li><a href="./동등-분할(Equivalence-Partitioning)" data-for="동등-분할(Equivalence-Partitioning)">동등 분할(Equivalence Partitioning)</a></li><li><a href="./동시성-언어(Concurrent-Language)" data-for="동시성-언어(Concurrent-Language)">동시성 언어(Concurrent Language)</a></li><li><a href="./동시성(Concurrency)" data-for="동시성(Concurrency)">동시성(Concurrency)</a></li><li><a href="./동시성과-병렬성의-차이" data-for="동시성과-병렬성의-차이">동시성과 병렬성의 차이</a></li><li><a href="./디자인-패턴(Design-Pattern)" data-for="디자인-패턴(Design-Pattern)">디자인 패턴(Design Pattern)</a></li><li><a href="./디지털-서명-(Digital-Signature)" data-for="디지털-서명-(Digital-Signature)">디지털 서명 (Digital Signature)</a></li><li><a href="./로드-밸런서(Load-Balancer)" data-for="로드-밸런서(Load-Balancer)">로드 밸런서(Load Balancer)</a></li><li><a href="./리스코프-치환-원칙-(Liskov-Substitution-Principle)" data-for="리스코프-치환-원칙-(Liskov-Substitution-Principle)">리스코프 치환 원칙 (Liskov Substitution Principle)</a></li><li><a href="./리액티브-스트림-인터페이스(Reactive-Stream-Interface)" data-for="리액티브-스트림-인터페이스(Reactive-Stream-Interface)">리액티브 스트림 인터페이스(Reactive Stream Interface)</a></li><li><a href="./리액티브-스트림(Reactive-Streams)" data-for="리액티브-스트림(Reactive-Streams)">리액티브 스트림(Reactive Streams)</a></li><li><a href="./리팩토링(Refactoring)" data-for="리팩토링(Refactoring)">리팩토링(Refactoring)</a></li><li><a href="./마이크로서비스-아키텍처(Microservice-Architecture)" data-for="마이크로서비스-아키텍처(Microservice-Architecture)">마이크로서비스 아키텍처(Microservice Architecture)</a></li><li><a href="./멀티스레딩(Multithreading)" data-for="멀티스레딩(Multithreading)">멀티스레딩(Multithreading)</a></li><li><a href="./메멘토-패턴-(Memento-Pattern)" data-for="메멘토-패턴-(Memento-Pattern)">메멘토 패턴 (Memento Pattern)</a></li><li><a href="./메시지-기반-아키텍처(Message-Based-Architecture)" data-for="메시지-기반-아키텍처(Message-Based-Architecture)">메시지 기반 아키텍처(Message-Based Architecture)</a></li><li><a href="./메시지-브로커(Message-Broker)" data-for="메시지-브로커(Message-Broker)">메시지 브로커(Message Broker)</a></li><li><a href="./메시지-지향-미들웨어(Message-Oriented-Middleware,-MOM)" data-for="메시지-지향-미들웨어(Message-Oriented-Middleware,-MOM)">메시지 지향 미들웨어(Message-Oriented Middleware, MOM)</a></li><li><a href="./메시지(Message)" data-for="메시지(Message)">메시지(Message)</a></li><li><a href="./메시지와-이벤트의-차이" data-for="메시지와-이벤트의-차이">메시지와 이벤트의 차이</a></li><li><a href="./모놀리식-아키텍처" data-for="모놀리식-아키텍처">모놀리식 아키텍처</a></li><li><a href="./모놀리식에서-마이크로서비스로의-전환-전략" data-for="모놀리식에서-마이크로서비스로의-전환-전략">모놀리식에서 마이크로서비스로의 전환 전략</a></li><li><a href="./모델-주도-설계(Model-Driven-Design)" data-for="모델-주도-설계(Model-Driven-Design)">모델 주도 설계(Model-Driven Design)</a></li><li><a href="./모델(Model)" data-for="모델(Model)">모델(Model)</a></li><li><a href="./모듈(Module)" data-for="모듈(Module)">모듈(Module)</a></li><li><a href="./모듈화" data-for="모듈화">모듈화</a></li><li><a href="./모범적인-개발-계획서-예시" data-for="모범적인-개발-계획서-예시">모범적인 개발 계획서 예시: 쇼핑몰 리뷰 기능 개발</a></li><li><a href="./바운디드-컨텍스트(Bounded-Context)" data-for="바운디드-컨텍스트(Bounded-Context)">바운디드 컨텍스트(Bounded Context)</a></li><li><a href="./반응형-프로그래밍(Reactive-Programming)" data-for="반응형-프로그래밍(Reactive-Programming)">반응형 프로그래밍(Reactive Programming)</a></li><li><a href="./범용-언어(general-purpose)" data-for="범용-언어(general-purpose)">범용 언어(general-purpose)</a></li><li><a href="./병렬-프로그래밍(Parallel-Programming)" data-for="병렬-프로그래밍(Parallel-Programming)">병렬 프로그래밍(Parallel Programming)</a></li><li><a href="./분산-시스템(Distributed-System)" data-for="분산-시스템(Distributed-System)">분산 시스템(Distributed System)</a></li><li><a href="./브리지-패턴-(Bridge-Pattern)" data-for="브리지-패턴-(Bridge-Pattern)">브리지 패턴 (Bridge Pattern)</a></li><li><a href="./브리지-패턴(Bridge-Pattern)" data-for="브리지-패턴(Bridge-Pattern)">브리지 패턴(Bridge Pattern)</a></li><li><a href="./블로킹-소켓(Blocking-Socket)" data-for="블로킹-소켓(Blocking-Socket)">블로킹 소켓(Blocking Socket)</a></li><li><a href="./블로킹(blocking)" data-for="블로킹(blocking)">블로킹(blocking)</a></li><li><a href="./비동기(Asynchronous)" data-for="비동기(Asynchronous)">비동기(Asynchronous)</a></li><li><a href="./비동기가-필요하지만-이벤트-기반-아키텍처를-사용하면-안되는-경우" data-for="비동기가-필요하지만-이벤트-기반-아키텍처를-사용하면-안되는-경우">비동기가 필요하지만 이벤트 기반 아키텍처를 사용하면 안되는 경우</a></li><li><a href="./비지터-패턴-(Visitor-Pattern)" data-for="비지터-패턴-(Visitor-Pattern)">비지터 패턴 (Visitor Pattern)</a></li><li><a href="./빅뱅-통합-테스트" data-for="빅뱅-통합-테스트">빅뱅 통합 테스트</a></li><li><a href="./빌더-패턴(Builder-Pattern)" data-for="빌더-패턴(Builder-Pattern)">빌더 패턴(Builder Pattern)</a></li><li><a href="./상세-설계(저수준-설계)" data-for="상세-설계(저수준-설계)">상세 설계(저수준 설계)</a></li><li><a href="./상속(Inheritance)" data-for="상속(Inheritance)">상속(Inheritance)</a></li><li><a href="./상태-검증(State-Verification)" data-for="상태-검증(State-Verification)">상태 검증(State Verification)</a></li><li><a href="./상태-패턴-(State-Pattern)" data-for="상태-패턴-(State-Pattern)">상태 패턴 (State Pattern)</a></li><li><a href="./상향식-통합-테스트" data-for="상향식-통합-테스트">상향식 통합 테스트</a></li><li><a href="./샌드위치-통합-테스트" data-for="샌드위치-통합-테스트">샌드위치 통합 테스트</a></li><li><a href="./샌드위치-통합-테스트-정의-및-특징" data-for="샌드위치-통합-테스트-정의-및-특징">샌드위치 통합 테스트 정의 및 특징</a></li><li><a href="./생성-패턴-(Creational-Pattern)" data-for="생성-패턴-(Creational-Pattern)">생성 패턴 (Creational Pattern)</a></li><li><a href="./생성-패턴-(Creational-Patterns)" data-for="생성-패턴-(Creational-Patterns)">생성 패턴 (Creational Patterns)</a></li><li><a href="./생성-패턴(Creational-Pattern)" data-for="생성-패턴(Creational-Pattern)">생성 패턴(Creational Pattern)</a></li><li><a href="./생성형-AI-활용으로-인한-인지-능력-저하" data-for="생성형-AI-활용으로-인한-인지-능력-저하">생성형 AI 활용으로 인한 인지 능력 저하</a></li><li><a href="./생성형-AI,-활용과-한계점" data-for="생성형-AI,-활용과-한계점">생성형 AI, 활용과 한계점</a></li><li><a href="./생성형-AI의-활용" data-for="생성형-AI의-활용">생성형 AI의 활용</a></li><li><a href="./서비스(Service)" data-for="서비스(Service)">서비스(Service)</a></li><li><a href="./서킷-브레이커(Circuit-Breaker)-패턴" data-for="서킷-브레이커(Circuit-Breaker)-패턴">서킷 브레이커(Circuit Breaker) 패턴</a></li><li><a href="./성숙도-프레임워크(Maturity-Framework)" data-for="성숙도-프레임워크(Maturity-Framework)">성숙도 프레임워크(Maturity Framework)</a></li><li><a href="./세션-스토리지(Session-Storage)" data-for="세션-스토리지(Session-Storage)">세션 스토리지(Session Storage)</a></li><li><a href="./세션(Session)" data-for="세션(Session)">세션(Session)</a></li><li><a href="./세션(Session)과-JWT(JSON-Web-Token)의-비교" data-for="세션(Session)과-JWT(JSON-Web-Token)의-비교">세션(Session)과 JWT(JSON Web Token)의 비교</a></li><li><a href="./소켓-이벤트-기반-처리-방식" data-for="소켓-이벤트-기반-처리-방식">소켓 이벤트 기반 처리 방식</a></li><li><a href="./개발-계획서-작성-가이드" data-for="개발-계획서-작성-가이드">소프트웨어 개발 계획</a></li><li><a href="./소프트웨어-설계의-유연성(Flexibility)" data-for="소프트웨어-설계의-유연성(Flexibility)">소프트웨어 설계의 유연성(Flexibility)</a></li><li><a href="./소프트웨어-테스트-생명주기(STLC)" data-for="소프트웨어-테스트-생명주기(STLC)">소프트웨어 테스트 생명주기(STLC)</a></li><li><a href="./속성-기반-접근-제어" data-for="속성-기반-접근-제어">속성 기반 접근 제어 (ABAC: Attribute-Based Access Control)</a></li><li><a href="./순서-보장-메시징-패턴" data-for="순서-보장-메시징-패턴">순서 보장 메시징 패턴</a></li><li><a href="./스레드(Thread)" data-for="스레드(Thread)">스레드(Thread)</a></li><li><a href="./스타-스키마" data-for="스타-스키마">스타 스키마</a></li><li><a href="./스프링-부트-네이티브-지원" data-for="스프링-부트-네이티브-지원">스프링 부트 네이티브 지원</a></li><li><a href="./스프링-이벤트(Spring-Event)" data-for="스프링-이벤트(Spring-Event)">스프링 이벤트(Spring Event)</a></li><li><a href="./스프링-프레임워크(Spring-Framework)" data-for="스프링-프레임워크(Spring-Framework)">스프링 프레임워크(Spring Framework)</a></li><li><a href="./시스템-요구사항-명세서-(SRS)-예시,-회의실-예약-시스템" data-for="시스템-요구사항-명세서-(SRS)-예시,-회의실-예약-시스템">시스템 요구사항 명세서 (SRS) 예시, 회의실 예약 시스템</a></li><li><a href="./시스템-테스트(System-Test)" data-for="시스템-테스트(System-Test)">시스템 테스트(System Test)</a></li><li><a href="./실시간-데이터-처리" data-for="실시간-데이터-처리">실시간 데이터 처리</a></li><li><a href="./심리적-안정감(Psychological-Safety)" data-for="심리적-안정감(Psychological-Safety)">심리적 안정감(Psychological Safety)</a></li><li><a href="./싱글톤-패턴-vs-유틸리티-클래스" data-for="싱글톤-패턴-vs-유틸리티-클래스">싱글톤 패턴 vs 유틸리티 클래스</a></li><li><a href="./싱글톤-패턴(Singleton-Pattern)" data-for="싱글톤-패턴(Singleton-Pattern)">싱글톤 패턴(Singleton Pattern)</a></li><li><a href="./아키텍처" data-for="아키텍처">아키텍처</a></li><li><a href="./아키텍처-설계(Architecture-Design)" data-for="아키텍처-설계(Architecture-Design)">아키텍처 설계(Architecture Design)</a></li><li><a href="./아파치-카프카(Apache-Kafka)" data-for="아파치-카프카(Apache-Kafka)">아파치 카프카(Apache Kafka)</a></li><li><a href="./애그리게이트(Aggregate)" data-for="애그리게이트(Aggregate)">애그리게이트(Aggregate)</a></li><li><a href="./어댑터-패턴-(Adapter-Pattern)" data-for="어댑터-패턴-(Adapter-Pattern)">어댑터 패턴 (Adapter Pattern)</a></li><li><a href="./어댑터-패턴(Adapter-Pattern)" data-for="어댑터-패턴(Adapter-Pattern)">어댑터 패턴(Adapter Pattern)</a></li><li><a href="./에러-핸들링(Error-Handling)" data-for="에러-핸들링(Error-Handling)">에러 핸들링(Error Handling)</a></li><li><a href="./에러코드" data-for="에러코드">에러코드</a></li><li><a href="./엔티티-관계(Entity-Relationship)" data-for="엔티티-관계(Entity-Relationship)">엔티티 관계(Entity Relationship)</a></li><li><a href="./엔티티(Entity)" data-for="엔티티(Entity)">엔티티(Entity)</a></li><li><a href="./엔티티(Entity)-와-Value-Objects-의-차이" data-for="엔티티(Entity)-와-Value-Objects-의-차이">엔티티(Entity) 와 Value Objects 의 차이</a></li><li><a href="./역-인덱스(Inverted-Index)" data-for="역-인덱스(Inverted-Index)">역 인덱스(Inverted Index)</a></li><li><a href="./역압력(back-pressure)" data-for="역압력(back-pressure)">역압력(back pressure)</a></li><li><a href="./역할-기반-접근-제어(RBAC)" data-for="역할-기반-접근-제어(RBAC)">역할 기반 접근 제어 (RBAC: Role-Based Access Control)</a></li><li><a href="./연구-언어-vs-프로덕션-언어" data-for="연구-언어-vs-프로덕션-언어">연구 언어 vs 프로덕션 언어</a></li><li><a href="./연구-언어(Research-Language)" data-for="연구-언어(Research-Language)">연구 언어(Research Language)</a></li><li><a href="./옵서버-패턴-(Observer-Pattern)" data-for="옵서버-패턴-(Observer-Pattern)">옵서버 패턴 (Observer Pattern)</a></li><li><a href="./옵시디언-기본-일일-노트-플러그인-사용법" data-for="옵시디언-기본-일일-노트-플러그인-사용법">옵시디언 기본 일일 노트 플러그인 사용법</a></li><li><a href="./옵시디언-노트-바로-열기" data-for="옵시디언-노트-바로-열기">옵시디언 노트 바로 열기</a></li><li><a href="./옵시디언-세팅" data-for="옵시디언-세팅">옵시디언 세팅</a></li><li><a href="./옵시디언-Periodic-Notes-플러그인" data-for="옵시디언-Periodic-Notes-플러그인">옵시디언 Periodic Notes 플러그인</a></li><li><a href="./옵시디언-Tasks-플러그인" data-for="옵시디언-Tasks-플러그인">옵시디언 Tasks 플러그인</a></li><li><a href="./옵시디언-Templater-플러그인" data-for="옵시디언-Templater-플러그인">옵시디언 Templater 플러그인</a></li><li><a href="./옵시디언-Templater-플러그인-새-노트-생성시-활성화" data-for="옵시디언-Templater-플러그인-새-노트-생성시-활성화">옵시디언 Templater 플러그인 새 노트 생성시 활성화</a></li><li><a href="./옵시디언에서-이미지를-특정-디렉토리-하위에-모으는-방법" data-for="옵시디언에서-이미지를-특정-디렉토리-하위에-모으는-방법">옵시디언에서 이미지를 특정 디렉토리 하위에 모으는 방법</a></li><li><a href="./옵시디언에서-일일-노트를-만드는-방법" data-for="옵시디언에서-일일-노트를-만드는-방법">옵시디언에서 일일 노트를 만드는 방법</a></li><li><a href="./옵시디언에서-현재-폴더에-새-노트를-만드는-방법" data-for="옵시디언에서-현재-폴더에-새-노트를-만드는-방법">옵시디언에서 현재 폴더에 새 노트를 만드는 방법</a></li><li><a href="./요구사항-명세서(Software-Requirements-Specification,-SRS)" data-for="요구사항-명세서(Software-Requirements-Specification,-SRS)">요구사항 명세서(Software Requirements Specification, SRS)</a></li><li><a href="./웹훅(Webhook)" data-for="웹훅(Webhook)">웹훅(Webhook)</a></li><li><a href="./유비쿼터스-언어(Ubiquitous-Language)" data-for="유비쿼터스-언어(Ubiquitous-Language)">유비쿼터스 언어(Ubiquitous Language)</a></li><li><a href="./유비쿼터스-언어의-적용-사례" data-for="유비쿼터스-언어의-적용-사례">유비쿼터스 언어의 적용 사례</a></li><li><a href="./의존성-역전-원칙-(Dependency-Inversion-Principle)" data-for="의존성-역전-원칙-(Dependency-Inversion-Principle)">의존성 역전 원칙 (Dependency Inversion Principle)</a></li><li><a href="./의존성-역전-원칙-적용-전략" data-for="의존성-역전-원칙-적용-전략">의존성 역전 원칙 적용 전략</a></li><li><a href="./이벤트-기반-아키텍처(Event-Driven-Architecture)" data-for="이벤트-기반-아키텍처(Event-Driven-Architecture)">이벤트 기반 아키텍처(Event-Driven Architecture)</a></li><li><a href="./이벤트-루프(Event-Loop)" data-for="이벤트-루프(Event-Loop)">이벤트 루프(Event Loop)</a></li><li><a href="./이벤트-소싱(Event-Sourcing)" data-for="이벤트-소싱(Event-Sourcing)">이벤트 소싱(Event Sourcing)</a></li><li><a href="./이벤트-스트리밍(Event-Streaming)" data-for="이벤트-스트리밍(Event-Streaming)">이벤트 스트리밍(Event Streaming)</a></li><li><a href="./이벤트(Event)" data-for="이벤트(Event)">이벤트(Event)</a></li><li><a href="./이벤트와-명령의-차이" data-for="이벤트와-명령의-차이">이벤트와 명령의 차이</a></li><li><a href="./이상적인-고객-프로필(ICP)" data-for="이상적인-고객-프로필(ICP)">이상적인 고객 프로필(ICP)</a></li><li><a href="./이상적인-Spring-MVC-디렉토리-구조" data-for="이상적인-Spring-MVC-디렉토리-구조">이상적인 Spring MVC 디렉토리 구조</a></li><li><a href="./이터레이터-패턴-(Iterator-Pattern)" data-for="이터레이터-패턴-(Iterator-Pattern)">이터레이터 패턴 (Iterator Pattern)</a></li><li><a href="./Authorization" data-for="Authorization">인가(Authorization)란 무엇일까?</a></li><li><a href="./인메모리-데이터-구조-저장소" data-for="인메모리-데이터-구조-저장소">인메모리 데이터 구조 저장소</a></li><li><a href="./인수-테스트(Acceptance-Test)" data-for="인수-테스트(Acceptance-Test)">인수 테스트(Acceptance Test)</a></li><li><a href="./인증-기관-(CA)" data-for="인증-기관-(CA)">인증 기관 (CA)</a></li><li><a href="./Authentication" data-for="Authentication">인증(Authentication)이란 무엇인가?</a></li><li><a href="./인증서-폐기-목록-(CRL)" data-for="인증서-폐기-목록-(CRL)">인증서 폐기 목록 (CRL)</a></li><li><a href="./인터페이스" data-for="인터페이스">인터페이스</a></li><li><a href="./인터페이스-분리-원칙(Interface-Segregation-Principle)" data-for="인터페이스-분리-원칙(Interface-Segregation-Principle)">인터페이스 분리 원칙(Interface Segregation Principle)</a></li><li><a href="./인터페이스(Interface)" data-for="인터페이스(Interface)">인터페이스(Interface)</a></li><li><a href="./자바-추상-클래스와-인터페이스와의-차이" data-for="자바-추상-클래스와-인터페이스와의-차이">자바 추상 클래스와 인터페이스와의 차이</a></li><li><a href="./자바에서-클래스-상속을-단일로-제한하는-이유" data-for="자바에서-클래스-상속을-단일로-제한하는-이유">자바에서 클래스 상속을 단일로 제한하는 이유</a></li><li><a href="./자카르타-EE-표준-서비스(Jakarta-EE-Standard-Services)" data-for="자카르타-EE-표준-서비스(Jakarta-EE-Standard-Services)">자카르타 EE 표준 서비스(Jakarta EE Standard Services)</a></li><li><a href="./작업-이력-기능-개발" data-for="작업-이력-기능-개발">작업 이력 기능 개발</a></li><li><a href="./전략-디자인-패턴(Strategy-Design-Pattern)" data-for="전략-디자인-패턴(Strategy-Design-Pattern)">전략 디자인 패턴(Strategy Design Pattern)</a></li><li><a href="./전략-패턴-(Strategy-Pattern)" data-for="전략-패턴-(Strategy-Pattern)">전략 패턴 (Strategy Pattern)</a></li><li><a href="./접근-제어-모델" data-for="접근-제어-모델">접근 제어 모델 (Access Control Model)</a></li><li><a href="./정적-타이핑(Static-Typing)" data-for="정적-타이핑(Static-Typing)">정적 타이핑(Static Typing)</a></li><li><a href="./제로-트러스트" data-for="제로-트러스트">제로 트러스트 (Zero Trust) 보안 모델</a></li><li><a href="./제품-시장-적합성(Product-Market-Fit)" data-for="제품-시장-적합성(Product-Market-Fit)">제품-시장 적합성(Product-Market Fit)</a></li><li><a href="./좋은-글쓰기" data-for="좋은-글쓰기">좋은 글쓰기</a></li><li><a href="./좋은-코드-리뷰의-조건" data-for="좋은-코드-리뷰의-조건">좋은 코드 리뷰의 조건</a></li><li><a href="./주제영역(Subject-Area)" data-for="주제영역(Subject-Area)">주제영역(Subject Area)</a></li><li><a href="./중재자-패턴-(Mediator-Pattern)" data-for="중재자-패턴-(Mediator-Pattern)">중재자 패턴 (Mediator Pattern)</a></li><li><a href="./책임-연쇄-패턴-(Chain-of-Responsibility-Pattern)" data-for="책임-연쇄-패턴-(Chain-of-Responsibility-Pattern)">책임 연쇄 패턴 (Chain of Responsibility Pattern)</a></li><li><a href="./청크드-전송-인코딩(Chunked-Transfer-Encoding)" data-for="청크드-전송-인코딩(Chunked-Transfer-Encoding)">청크드 전송 인코딩(Chunked Transfer Encoding)</a></li><li><a href="./초개인화-UI" data-for="초개인화-UI">초개인화 UI</a></li><li><a href="./최소-권한-원칙" data-for="최소-권한-원칙">최소 권한 원칙 (Principle of Least Privilege)</a></li><li><a href="./추상-팩토리-패턴(Abstract-Factory-Pattern)" data-for="추상-팩토리-패턴(Abstract-Factory-Pattern)">추상 팩토리 패턴(Abstract Factory Pattern)</a></li><li><a href="./추상화-수준-결정-방법론" data-for="추상화-수준-결정-방법론">추상화 수준 결정 방법론</a></li><li><a href="./추상화(Abstraction)" data-for="추상화(Abstraction)">추상화(Abstraction)</a></li><li><a href="./추상화는-어떻게-모듈화를-지원하는가" data-for="추상화는-어떻게-모듈화를-지원하는가">추상화는 어떻게 모듈화를 지원하는가</a></li><li><a href="./카프카-토픽(Topic)" data-for="카프카-토픽(Topic)">카프카 토픽(Topic)</a></li><li><a href="./카프카-파티션(Partition)" data-for="카프카-파티션(Partition)">카프카 파티션(Partition)</a></li><li><a href="./캐싱(Caching)" data-for="캐싱(Caching)">캐싱(Caching)</a></li><li><a href="./캡슐화(Encapsulation)" data-for="캡슐화(Encapsulation)">캡슐화(Encapsulation)</a></li><li><a href="./커맨드-패턴-(Command-Pattern)" data-for="커맨드-패턴-(Command-Pattern)">커맨드 패턴 (Command Pattern)</a></li><li><a href="./컨텍스트-맵핑(Context-Mapping)" data-for="컨텍스트-맵핑(Context-Mapping)">컨텍스트 맵핑(Context Mapping)</a></li><li><a href="./컨텐트-협상(Content-Negotiation)" data-for="컨텐트-협상(Content-Negotiation)">컨텐트 협상(Content Negotiation)</a></li><li><a href="./컴포지트-패턴-(Composite-Pattern)" data-for="컴포지트-패턴-(Composite-Pattern)">컴포지트 패턴 (Composite Pattern)</a></li><li><a href="./컴포지트-패턴(Composite-Pattern)" data-for="컴포지트-패턴(Composite-Pattern)">컴포지트 패턴(Composite Pattern)</a></li><li><a href="./코드-스멜" data-for="코드-스멜">코드 스멜</a></li><li><a href="./코드의-안정성" data-for="코드의-안정성">코드의 안정성</a></li><li><a href="./코드의-유지보수성" data-for="코드의-유지보수성">코드의 유지보수성</a></li><li><a href="./코드의-확장성(Extensibility)" data-for="코드의-확장성(Extensibility)">코드의 확장성(Extensibility)</a></li><li><a href="./코루틴-(Coroutines)" data-for="코루틴-(Coroutines)">코루틴 (Coroutines)</a></li><li><a href="./코루틴-동작-방식-(하드웨어-및-OS-레벨)" data-for="코루틴-동작-방식-(하드웨어-및-OS-레벨)">코루틴 동작 방식 (하드웨어 및 OS 레벨)</a></li><li><a href="./콘텐츠-보안-정책(Content-Security-Policy)-설정" data-for="콘텐츠-보안-정책(Content-Security-Policy)-설정">콘텐츠 보안 정책(Content Security Policy) 설정</a></li><li><a href="./콜-스택(Call-Stack)" data-for="콜-스택(Call-Stack)">콜 스택(Call Stack)</a></li><li><a href="./콜백-체인(Callback-Chain)" data-for="콜백-체인(Callback-Chain)">콜백 체인(Callback Chain)</a></li><li><a href="./클라이언트-서버-모델" data-for="클라이언트-서버-모델">클라이언트-서버 모델</a></li><li><a href="./클래스-기반-언어(Class-based-Language)" data-for="클래스-기반-언어(Class-based-Language)">클래스 기반 언어(Class-based Language)</a></li><li><a href="./클래스-기반-언어가-아니면서-OOP-패러다임을-따르는-언어" data-for="클래스-기반-언어가-아니면서-OOP-패러다임을-따르는-언어">클래스 기반 언어가 아니면서 OOP 패러다임을 따르는 언어</a></li><li><a href="./클래스-기번-언어와-프로토-타입-기반-언어의-차이점" data-for="클래스-기번-언어와-프로토-타입-기반-언어의-차이점">클래스 기번 언어와 프로토 타입 기반 언어의 차이점</a></li><li><a href="./클래스-없이도-객체-지향을-지원하는-이유" data-for="클래스-없이도-객체-지향을-지원하는-이유">클래스 없이도 객체 지향을 지원하는 이유</a></li><li><a href="./테스트-(Testing)" data-for="테스트-(Testing)">테스트 (Testing)</a></li><li><a href="./테스트-더블(Test-Double)" data-for="테스트-더블(Test-Double)">테스트 더블(Test Double)</a></li><li><a href="./테스트-스텁(Test-Stub)" data-for="테스트-스텁(Test-Stub)">테스트 스텁(Test Stub)</a></li><li><a href="./테스트-자동화(Test-Automation)" data-for="테스트-자동화(Test-Automation)">테스트 자동화(Test Automation)</a></li><li><a href="./테스트-주도-개발(TDD)" data-for="테스트-주도-개발(TDD)">테스트 주도 개발(TDD)</a></li><li><a href="./테스트-케이스" data-for="테스트-케이스">테스트 케이스</a></li><li><a href="./테스트-피라미드(Test-Pyramid)" data-for="테스트-피라미드(Test-Pyramid)">테스트 피라미드(Test Pyramid)</a></li><li><a href="./테스트는-미래의-비용을-막는-가장-확실한-보험입니다" data-for="테스트는-미래의-비용을-막는-가장-확실한-보험입니다">테스트는 미래의 비용을 막는 가장 확실한 보험입니다</a></li><li><a href="./테스트를-위한-인터페이스-설계" data-for="테스트를-위한-인터페이스-설계">테스트를 위한 인터페이스 설계</a></li><li><a href="./테스트를-저해하는-인터페이스-안티패턴" data-for="테스트를-저해하는-인터페이스-안티패턴">테스트를 저해하는 인터페이스 안티패턴</a></li><li><a href="./템플릿-메서드-패턴-(Template-Method-Pattern)" data-for="템플릿-메서드-패턴-(Template-Method-Pattern)">템플릿 메서드 패턴 (Template Method Pattern)</a></li><li><a href="./통합-테스트(Integration-Test)" data-for="통합-테스트(Integration-Test)">통합 테스트(Integration Test)</a></li><li><a href="./통합-테스트의-다양한-접근-방식" data-for="통합-테스트의-다양한-접근-방식">통합 테스트의 다양한 접근 방식</a></li><li><a href="./트랜잭션(Transaction)" data-for="트랜잭션(Transaction)">트랜잭션(Transaction)</a></li><li><a href="./패키지의-한계와-문제점" data-for="패키지의-한계와-문제점">패키지의 한계와 문제점</a></li><li><a href="./팩토리-메소드-패턴(Factory-Method-Pattern)" data-for="팩토리-메소드-패턴(Factory-Method-Pattern)">팩토리 메소드 패턴(Factory Method Pattern)</a></li><li><a href="./퍼사드-패턴-(Facade-Pattern)" data-for="퍼사드-패턴-(Facade-Pattern)">퍼사드 패턴 (Facade Pattern)</a></li><li><a href="./프레임워크" data-for="프레임워크">프레임워크</a></li><li><a href="./프로덕션-언어(Production-Language)" data-for="프로덕션-언어(Production-Language)">프로덕션 언어(Production Language)</a></li><li><a href="./프로세스-메모리-구조" data-for="프로세스-메모리-구조">프로세스 메모리 구조</a></li><li><a href="./프로세스(Process)" data-for="프로세스(Process)">프로세스(Process)</a></li><li><a href="./프로세스와-스레드의-차이" data-for="프로세스와-스레드의-차이">프로세스와 스레드의 차이</a></li><li><a href="./프로토타입-기반-언어" data-for="프로토타입-기반-언어">프로토타입 기반 언어</a></li><li><a href="./프로토타입-패턴(Prototype-Pattern)" data-for="프로토타입-패턴(Prototype-Pattern)">프로토타입 패턴(Prototype Pattern)</a></li><li><a href="./프록시-패턴-(Proxy-Pattern)" data-for="프록시-패턴-(Proxy-Pattern)">프록시 패턴 (Proxy Pattern)</a></li><li><a href="./프록시(Proxy)" data-for="프록시(Proxy)">프록시(Proxy)</a></li><li><a href="./플라이웨이트-패턴-(Flyweight-Pattern)" data-for="플라이웨이트-패턴-(Flyweight-Pattern)">플라이웨이트 패턴 (Flyweight Pattern)</a></li><li><a href="./플라이웨이트-패턴(Flyweight-Pattern)" data-for="플라이웨이트-패턴(Flyweight-Pattern)">플라이웨이트 패턴(Flyweight Pattern)</a></li><li><a href="./피라미드-원칙" data-for="피라미드-원칙">피라미드 원칙</a></li><li><a href="./하향식-통합-테스트" data-for="하향식-통합-테스트">하향식 통합 테스트</a></li><li><a href="./하향식-통합-테스트(Top-Down-Integration-Testing)" data-for="하향식-통합-테스트(Top-Down-Integration-Testing)">하향식 통합 테스트(Top-Down Integration Testing)</a></li><li><a href="./한-달-차이와-30일-차이" data-for="한-달-차이와-30일-차이">한 달 차이와 30일 차이</a></li><li><a href="./행위-검증(Behavior-Verification)" data-for="행위-검증(Behavior-Verification)">행위 검증(Behavior Verification)</a></li><li><a href="./행위-주도-개발(BDD)" data-for="행위-주도-개발(BDD)">행위 주도 개발(BDD)</a></li><li><a href="./행위-패턴(Behavioral-Patterns)" data-for="행위-패턴(Behavioral-Patterns)">행위 패턴(Behavioral Patterns)</a></li><li><a href="./헥사고널-아키텍처(Hexagonal-Architecture)" data-for="헥사고널-아키텍처(Hexagonal-Architecture)">헥사고널 아키텍처(Hexagonal Architecture)</a></li><li><a href="./회고(Retrospective)" data-for="회고(Retrospective)">회고(Retrospective)</a></li><li><a href="./회의실-예약-기능-상세-설계-예시" data-for="회의실-예약-기능-상세-설계-예시">회의실 예약 기능 상세 설계 예시</a></li><li><a href="./효과적인-통합-테스트-구축-전략" data-for="효과적인-통합-테스트-구축-전략">효과적인 통합 테스트 구축 전략</a></li><li><a href="./ABAC-개발-가이드" data-for="ABAC-개발-가이드">ABAC 개발 가이드 (Attribute-Based Access Control Development Guide)</a></li><li><a href="./ACID-원칙" data-for="ACID-원칙">ACID 원칙</a></li><li><a href="./Agent-Experience" data-for="Agent-Experience">Agent Experience</a></li><li><a href="./AI-시대,-벡엔드-개발자의-생존과-진화" data-for="AI-시대,-벡엔드-개발자의-생존과-진화">AI 시대, 벡엔드 개발자의 생존과 진화</a></li><li><a href="./AOT(Ahead-of-Time)-컴파일" data-for="AOT(Ahead-of-Time)-컴파일">AOT(Ahead-of-Time) 컴파일</a></li><li><a href="./API-단위-테스트" data-for="API-단위-테스트">API 단위 테스트</a></li><li><a href="./B-Tree" data-for="B-Tree">B Tree</a></li><li><a href="./B+-Tree" data-for="B+-Tree">B+ Tree</a></li><li><a href="./Cache-Aside" data-for="Cache-Aside">Cache Aside</a></li><li><a href="./CAP-이론" data-for="CAP-이론">CAP 이론</a></li><li><a href="./CompletableFuture" data-for="CompletableFuture">CompletableFuture</a></li><li><a href="./ComponentScan과-EntityScan의-차이점" data-for="ComponentScan과-EntityScan의-차이점">ComponentScan과 EntityScan의 차이점</a></li><li><a href="./Confluence-문서-검색-API-개발" data-for="Confluence-문서-검색-API-개발">Confluence 문서 검색 API 개발</a></li><li><a href="./CPU-바운드-vs-IO-바운드-작업" data-for="CPU-바운드-vs-IO-바운드-작업">CPU 바운드 vs IO 바운드 작업</a></li><li><a href="./CSRF(Cross-Site-Request-Forgery)" data-for="CSRF(Cross-Site-Request-Forgery)">CSRF(Cross-Site Request Forgery)</a></li><li><a href="./Cucumber" data-for="Cucumber">Cucumber</a></li><li><a href="./DataJpaTest-어노테이션" data-for="DataJpaTest-어노테이션">DataJpaTest 어노테이션</a></li><li><a href="./Docker-로-Redis-설치하기" data-for="Docker-로-Redis-설치하기">Docker 로 Redis 설치하기</a></li><li><a href="./Docker-Compose로-Redis-설정하기" data-for="Docker-Compose로-Redis-설정하기">Docker Compose로 Redis 설정하기</a></li><li><a href="./EIS(Enterprise-Information-Systems)" data-for="EIS(Enterprise-Information-Systems)">EIS(Enterprise Information Systems)</a></li><li><a href="./EntityScan-어노테이션" data-for="EntityScan-어노테이션">EntityScan 어노테이션</a></li><li><a href="./ETL-프로세스" data-for="ETL-프로세스">ETL 프로세스</a></li><li><a href="./Future-인터페이스" data-for="Future-인터페이스">Future 인터페이스</a></li><li><a href="./Gherkin" data-for="Gherkin">Gherkin</a></li><li><a href="./Gherkin-문법-기초" data-for="Gherkin-문법-기초">Gherkin 문법 기초</a></li><li><a href="./Given-When-Then-패턴-(Arrange-Act-Assert-패턴)" data-for="Given-When-Then-패턴-(Arrange-Act-Assert-패턴)">Given-When-Then 패턴 (Arrange-Act-Assert 패턴)</a></li><li><a href="./GoF(Gang-of-Four)" data-for="GoF(Gang-of-Four)">GoF(Gang of Four)</a></li><li><a href="./GraalVM" data-for="GraalVM">GraalVM</a></li><li><a href="./GraalVM-Native-Image" data-for="GraalVM-Native-Image">GraalVM Native Image</a></li><li><a href="./GraphQL의-배신-1분-타임아웃을-6초로-단축시킨-엑셀-다운로드-성능-개선기" data-for="GraphQL의-배신-1분-타임아웃을-6초로-단축시킨-엑셀-다운로드-성능-개선기">GraphQL의 배신? 1분 타임아웃을 6초로 단축시킨 엑셀 다운로드 성능 개선기</a></li><li><a href="./GTM(Go-to-Market)-전략" data-for="GTM(Go-to-Market)-전략">GTM(Go-to-Market) 전략</a></li><li><a href="./Hands-On-Modelers" data-for="Hands-On-Modelers">Hands-On Modelers</a></li><li><a href="./HAProxy" data-for="HAProxy">HAProxy</a></li><li><a href="./Hibernate-를-이용한-Soft-Delete-구현" data-for="Hibernate-를-이용한-Soft-Delete-구현">Hibernate 를 이용한 Soft Delete 구현</a></li><li><a href="./Hibernate-엔티티-상태-관리" data-for="Hibernate-엔티티-상태-관리">Hibernate 엔티티 상태 관리</a></li><li><a href="./Hibernate-캐싱-전략" data-for="Hibernate-캐싱-전략">Hibernate 캐싱 전략</a></li><li><a href="./Hibernate-트랜잭션-관리-전략" data-for="Hibernate-트랜잭션-관리-전략">Hibernate 트랜잭션 관리 전략</a></li><li><a href="./Hibernate-Session" data-for="Hibernate-Session">Hibernate Session</a></li><li><a href="./Hibernate-Session-관리-전략" data-for="Hibernate-Session-관리-전략">Hibernate Session 관리 전략</a></li><li><a href="./Hibernate에서-Cascade=&quot;all-delete-orphan&quot;-오류-해결하기" data-for="Hibernate에서-Cascade=&quot;all-delete-orphan&quot;-오류-해결하기">Hibernate에서 Cascade=&quot;all-delete-orphan&quot; 오류 해결하기</a></li><li><a href="./HMAC(Hash-based-Message-Authentication-Code)" data-for="HMAC(Hash-based-Message-Authentication-Code)">HMAC(Hash-based Message Authentication Code)</a></li><li><a href="./HTTP-1.0" data-for="HTTP-1.0">HTTP 1.0</a></li><li><a href="./HTTP-1.1" data-for="HTTP-1.1">HTTP 1.1</a></li><li><a href="./HTTP-2.0" data-for="HTTP-2.0">HTTP 2.0</a></li><li><a href="./HTTP-Archive-(HAR)" data-for="HTTP-Archive-(HAR)">HTTP Archive (HAR)</a></li><li><a href="./HTTP(HyperText-Transfer-Protocol)" data-for="HTTP(HyperText-Transfer-Protocol)">HTTP(HyperText Transfer Protocol)</a></li><li><a href="./HttpOnly-쿠키" data-for="HttpOnly-쿠키">HttpOnly 쿠키</a></li><li><a href="./IO-멀티플렉싱(IO-Multiplexing)" data-for="IO-멀티플렉싱(IO-Multiplexing)">IO 멀티플렉싱(IO Multiplexing)</a></li><li><a href="./IPC(Inter-Process-Communication)" data-for="IPC(Inter-Process-Communication)">IPC(Inter-Process Communication)</a></li><li><a href="./ISO_IEC_IEEE-29148" data-for="ISO_IEC_IEEE-29148">ISO_IEC_IEEE 29148</a></li><li><a href="./Jakarta-EE-Platform" data-for="Jakarta-EE-Platform">Jakarta EE Platform</a></li><li><a href="./Java-언어-소개" data-for="Java-언어-소개">Java 언어 소개</a></li><li><a href="./Java-타입,-값,-변수" data-for="Java-타입,-값,-변수">Java 타입, 값, 변수</a></li><li><a href="./Java-패키지-vs-Gradle-모듈" data-for="Java-패키지-vs-Gradle-모듈">Java 패키지 vs Gradle 모듈</a></li><li><a href="./Java-패키지,-모듈" data-for="Java-패키지,-모듈">Java 패키지, 모듈</a></li><li><a href="./Java-abstract-keword" data-for="Java-abstract-keword">Java abstract keword</a></li><li><a href="./Java-EE(Java-Enterprise-Edition)" data-for="Java-EE(Java-Enterprise-Edition)">Java EE(Java Enterprise Edition)</a></li><li><a href="./Java-Flow-API" data-for="Java-Flow-API">Java Flow API</a></li><li><a href="./Java-Keyword" data-for="Java-Keyword">Java Keyword</a></li><li><a href="./Java-Transaction-API-(JTA)" data-for="Java-Transaction-API-(JTA)">Java Transaction API (JTA)</a></li><li><a href="./JIT(Just-In-Time)-컴파일" data-for="JIT(Just-In-Time)-컴파일">JIT(Just-In-Time) 컴파일</a></li><li><a href="./JMS(Java-Message-Service)" data-for="JMS(Java-Message-Service)">JMS(Java Message Service)</a></li><li><a href="./JPA-Criteria-API" data-for="JPA-Criteria-API">JPA Criteria API</a></li><li><a href="./JPA-Fetch-Join과-컬렉션-필터링의-함정" data-for="JPA-Fetch-Join과-컬렉션-필터링의-함정">JPA Fetch Join과 컬렉션 필터링의 함정</a></li><li><a href="./JPA-Specification" data-for="JPA-Specification">JPA Specification</a></li><li><a href="./JPA에서-Soft-Delete와-유니크-제약조건-처리하기" data-for="JPA에서-Soft-Delete와-유니크-제약조건-처리하기">JPA에서 Soft Delete와 유니크 제약조건 처리하기</a></li><li><a href="./JSON-RPC" data-for="JSON-RPC">JSON-RPC</a></li><li><a href="./JSON-RPC와-REST-API의-차이점" data-for="JSON-RPC와-REST-API의-차이점">JSON-RPC와 REST API의 차이점</a></li><li><a href="./JWT(JSON-Web-Token)" data-for="JWT(JSON-Web-Token)">JWT(JSON Web Token)</a></li><li><a href="./Kotlin" data-for="Kotlin">Kotlin</a></li><li><a href="./Kotlin-Spring-Boot-프로젝트에-Cucumber-실전-도입" data-for="Kotlin-Spring-Boot-프로젝트에-Cucumber-실전-도입">Kotlin Spring Boot 프로젝트에 Cucumber 실전 도입</a></li><li><a href="./KPT" data-for="KPT">KPT</a></li><li><a href="./LLM을-활용한-효과적인-개발-계획서-작성법" data-for="LLM을-활용한-효과적인-개발-계획서-작성법">LLM을 활용한 효과적인 개발 계획서 작성법</a></li><li><a href="./Mac-에서-Redis-설치하기" data-for="Mac-에서-Redis-설치하기">Mac 에서 Redis 설치하기</a></li><li><a href="./MCP-리소스-공유-(Resource-Sharing)" data-for="MCP-리소스-공유-(Resource-Sharing)">MCP 리소스 공유 (Resource Sharing)</a></li><li><a href="./MCP-메시지-구조-(Message-Structure)" data-for="MCP-메시지-구조-(Message-Structure)">MCP 메시지 구조 (Message Structure)</a></li><li><a href="./MCP-서버-도구-등록-및-관리" data-for="MCP-서버-도구-등록-및-관리">MCP 서버 도구 등록 및 관리</a></li><li><a href="./MCP-아키텍처" data-for="MCP-아키텍처">MCP 아키텍처</a></li><li><a href="./MCP-역방향-LLM-샘플링-(Reverse-LLM-Sampling)" data-for="MCP-역방향-LLM-샘플링-(Reverse-LLM-Sampling)">MCP 역방향 LLM 샘플링 (Reverse LLM Sampling)</a></li><li><a href="./MCP-원격-도구-호출-(Remote-Tool-Calling)" data-for="MCP-원격-도구-호출-(Remote-Tool-Calling)">MCP 원격 도구 호출 (Remote Tool Calling)</a></li><li><a href="./MCP-전송-계층-(Transport-Layer)" data-for="MCP-전송-계층-(Transport-Layer)">MCP 전송 계층 (Transport Layer)</a></li><li><a href="./MCP-클라이언트-초기화-및-기능-협상" data-for="MCP-클라이언트-초기화-및-기능-협상">MCP 클라이언트 초기화 및 기능 협상</a></li><li><a href="./MCP-프로토콜-계층-(Protocol-Layer)" data-for="MCP-프로토콜-계층-(Protocol-Layer)">MCP 프로토콜 계층 (Protocol Layer)</a></li><li><a href="./MCP-프롬프트-관리-(Prompt-Management)" data-for="MCP-프롬프트-관리-(Prompt-Management)">MCP 프롬프트 관리 (Prompt Management)</a></li><li><a href="./MCP-Client" data-for="MCP-Client">MCP Client</a></li><li><a href="./MCP-Server" data-for="MCP-Server">MCP Server</a></li><li><a href="./MCP-Tools" data-for="MCP-Tools">MCP Tools</a></li><li><a href="./MCP프롬프트-등록-및-관리" data-for="MCP프롬프트-등록-및-관리">MCP프롬프트 등록 및 관리</a></li><li><a href="./MECE-원칙" data-for="MECE-원칙">MECE 원칙</a></li><li><a href="./Memcached" data-for="Memcached">Memcached</a></li><li><a href="./Memcached-vs.-Redis" data-for="Memcached-vs.-Redis">Memcached vs. Redis</a></li><li><a href="./Mockito-Strict-Stubbing" data-for="Mockito-Strict-Stubbing">Mockito Strict Stubbing</a></li><li><a href="./Model-Context-Protocol-(MCP)" data-for="Model-Context-Protocol-(MCP)">Model Context Protocol (MCP)</a></li><li><a href="./MySQL-ROLLUP-성능-개선" data-for="MySQL-ROLLUP-성능-개선">MySQL ROLLUP 성능 개선</a></li><li><a href="./OAuth-2.0" data-for="OAuth-2.0">OAuth 2.0</a></li><li><a href="./OLAP" data-for="OLAP">OLAP</a></li><li><a href="./OLTP" data-for="OLTP">OLTP</a></li><li><a href="./Oracle-삽입-시-유니크-제약조건-무시" data-for="Oracle-삽입-시-유니크-제약조건-무시">Oracle 삽입 시 유니크 제약조건 무시</a></li><li><a href="./ORM(Object-Relational-Mapping)" data-for="ORM(Object-Relational-Mapping)">ORM(Object-Relational Mapping)</a></li><li><a href="./Passkey-개념-이해하기" data-for="Passkey-개념-이해하기">Passkey 개념 이해하기</a></li><li><a href="./Passkey-개발자-가이드" data-for="Passkey-개발자-가이드">Passkey 개발자 가이드</a></li><li><a href="./Passkey-도입하기" data-for="Passkey-도입하기">Passkey 도입하기</a></li><li><a href="./Permission-인터페이스-정의" data-for="Permission-인터페이스-정의">Permission 인터페이스 정의</a></li><li><a href="./Public-함수-작성-원칙" data-for="Public-함수-작성-원칙">Public 함수 작성 원칙</a></li><li><a href="./Publisher(Reactive-Stream)" data-for="Publisher(Reactive-Stream)">Publisher(Reactive Stream)</a></li><li><a href="./RBAC-개발-가이드" data-for="RBAC-개발-가이드">RBAC 개발 가이드 (Role-Based Access Control Development Guide)</a></li><li><a href="./RBAC-인터페이스-정의" data-for="RBAC-인터페이스-정의">RBAC 인터페이스 정의</a></li><li><a href="./Read-Through-캐싱-전략" data-for="Read-Through-캐싱-전략">Read Through 캐싱 전략</a></li><li><a href="./Redis" data-for="Redis">Redis</a></li><li><a href="./Redis-기본-명령어" data-for="Redis-기본-명령어">Redis 기본 명령어</a></li><li><a href="./Redis-설치하기" data-for="Redis-설치하기">Redis 설치하기</a></li><li><a href="./Redis를-활용한-실시간-데이터-처리-방법" data-for="Redis를-활용한-실시간-데이터-처리-방법">Redis를 활용한 실시간 데이터 처리 방법</a></li><li><a href="./RESTful-API" data-for="RESTful-API">RESTful API</a></li><li><a href="./Role-인터페이스-정의" data-for="Role-인터페이스-정의">Role 인터페이스 정의</a></li><li><a href="./Rust" data-for="Rust">Rust</a></li><li><a href="./SDLC(Sofware-Development-Life-Cycle)" data-for="SDLC(Sofware-Development-Life-Cycle)">SDLC(Sofware Development Life Cycle)</a></li><li><a href="./Soft-Delete" data-for="Soft-Delete">Soft Delete</a></li><li><a href="./Soft-Delete-의-시스템-복잡성" data-for="Soft-Delete-의-시스템-복잡성">Soft Delete 의 시스템 복잡성</a></li><li><a href="./SOLID-원칙" data-for="SOLID-원칙">SOLID 원칙</a></li><li><a href="./Spring-@ContextConfiguration-어노테이션" data-for="Spring-@ContextConfiguration-어노테이션">Spring @ContextConfiguration 어노테이션</a></li><li><a href="./Spring-@TestConfiguration-어노테이션" data-for="Spring-@TestConfiguration-어노테이션">Spring @TestConfiguration 어노테이션</a></li><li><a href="./Spring-엑셀-다운로드-기능-구현" data-for="Spring-엑셀-다운로드-기능-구현">Spring 엑셀 다운로드 기능 구현</a></li><li><a href="./Spring-Async" data-for="Spring-Async">Spring Async</a></li><li><a href="./Spring-Bean-Validation-공용-사용-가이드" data-for="Spring-Bean-Validation-공용-사용-가이드">Spring Bean Validation 공용 사용 가이드</a></li><li><a href="./Spring-Boot-Session-Redis-연동하기" data-for="Spring-Boot-Session-Redis-연동하기">Spring Boot Session Redis 연동하기</a></li><li><a href="./Spring-Cloud-Config" data-for="Spring-Cloud-Config">Spring Cloud Config</a></li><li><a href="./Spring-Cloud-Stream" data-for="Spring-Cloud-Stream">Spring Cloud Stream</a></li><li><a href="./Spring-Redis-Session-저장-방식" data-for="Spring-Redis-Session-저장-방식">Spring Redis Session 저장 방식</a></li><li><a href="./Spring-Statemachine" data-for="Spring-Statemachine">Spring Statemachine</a></li><li><a href="./SseClientTransport" data-for="SseClientTransport">SseClientTransport</a></li><li><a href="./Subscriber(Reactive-Stream)" data-for="Subscriber(Reactive-Stream)">Subscriber(Reactive Stream)</a></li><li><a href="./Subscription(Reactive-Stream)" data-for="Subscription(Reactive-Stream)">Subscription(Reactive Stream)</a></li><li><a href="./SW-개발-사이클" data-for="SW-개발-사이클">SW 개발 사이클</a></li><li><a href="./Untitled" data-for="Untitled">Untitled</a></li><li><a href="./WebSocketClientTransport" data-for="WebSocketClientTransport">WebSocketClientTransport</a></li><li><a href="./Write-Through" data-for="Write-Through">Write Through</a></li><li><a href="./XSS(Cross-Site-Scripting)" data-for="XSS(Cross-Site-Scripting)">XSS(Cross-Site Scripting)</a></li></ul></div></li><li id="explorer-end"></li></ul></div></div></div><div class="center"><div class="page-header"><div class="popover-hint"><nav class="breadcrumb-container" aria-label="breadcrumbs"><div class="breadcrumb-element"><a href="./">Home</a><p> ❯ </p></div><div class="breadcrumb-element"><a href>헥사고널 아키텍처(Hexagonal Architecture)</a></div></nav><h1 class="article-title">헥사고널 아키텍처(Hexagonal Architecture)</h1><p show-comma="true" class="content-meta"><time datetime="2025-06-11T05:36:48.000Z">2025년 6월 11일</time><span>90 min read</span></p></div></div><article class="popover-hint"><p>소프트웨어 개발 분야에서 아키텍처는 시스템의 품질, 유지보수성, 확장성을 결정짓는 매우 중요한 요소입니다. 다양한 아키텍처 패턴 중에서, 최근 몇 년간 많은 개발자에게 주목받으며 그 중요성이 강조되고 있는 패턴 중 하나가 바로 <strong>헥사고널 아키텍처(Hexagonal Architecture)</strong> 입니다. 이 아키텍처는 <strong>포트와 어댑터(Ports and Adapters)</strong> 아키텍처라는 이름으로도 잘 알려져 있으며, 애플리케이션의 핵심 로직을 외부 환경의 변화로부터 보호하고, 유연하며 테스트하기 쉬운 시스템을 구축하는 데 강력한 기반을 제공합니다.</p>
<p>본 문서는 헥사고널 아키텍처의 탄생 배경부터 핵심 구성 요소, 장단점, 그리고 실제 프로젝트에 적용하기 위한 구체적인 가이드라인까지 심도 있게 다루고자 합니다. 독자 여러분이 이 글을 통해 헥사고널 아키텍처에 대한 정확하고 깊이 있는 이해를 얻고, 실제 프로젝트에 성공적으로 적용하는 데 도움을 받을 수 있기를 바랍니다.</p>
<h2 id="i-들어가며-헥사고널-아키텍처란-무엇인가">I. 들어가며: 헥사고널 아키텍처란 무엇인가?<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#i-들어가며-헥사고널-아키텍처란-무엇인가" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>헥사고널 아키텍처는 2005년 앨리스터 콕번(Alistair Cockburn) 박사에 의해 공식적으로 제안된 소프트웨어 아키텍처 패턴입니다.1 이 아키텍처의 가장 근본적인 목표는 애플리케이션의 핵심 비즈니스 로직(도메인 로직)을 사용자 인터페이스(UI), 데이터베이스, 외부 API와 같은 외부 기술적 관심사로부터 철저히 분리(decoupling)하는 것입니다.1</p>
<p>이러한 분리를 통해 얻을 수 있는 핵심적인 이점은 애플리케이션의 코어가 외부 환경의 변화에 영향을 받지 않고 독립적으로 개발되고 테스트될 수 있다는 점입니다. 예를 들어, 데이터베이스 기술을 교체하거나 새로운 UI 프레임워크를 도입하더라도, 잘 설계된 헥사고널 아키텍처에서는 핵심 비즈니스 로직의 수정 없이 이러한 변경을 수용할 수 있습니다. 이는 애플리케이션의 생명주기 동안 발생할 수 있는 다양한 기술적 변화에 대한 적응력을 높이고, 시스템의 장기적인 유지보수 비용을 절감하는 데 크게 기여합니다. 결국 헥사고널 아키텍처는 애플리케이션의 핵심 가치인 비즈니스 로직을 외부의 기술적인 변화나 복잡성으로부터 ‘보호’하고, 그 자체로 온전히 테스트 가능하며 독립적으로 진화할 수 있도록 만드는 것을 지향합니다.</p>
<h2 id="ii-헥사고널-아키텍처의-탄생-배경과-핵심-구성-요소">II. 헥사고널 아키텍처의 탄생 배경과 핵심 구성 요소<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#ii-헥사고널-아키텍처의-탄생-배경과-핵심-구성-요소" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>헥사고널 아키텍처를 깊이 이해하기 위해서는 이 아키텍처가 어떤 문제의식을 바탕으로 등장했으며, 그 핵심을 이루는 구성 요소들이 무엇인지 명확히 파악하는 것이 중요합니다.</p>
<h3 id="앨리스터-콕번이-헥사고널-아키텍처를-제안한-이유">앨리스터 콕번이 헥사고널 아키텍처를 제안한 이유<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#앨리스터-콕번이-헥사고널-아키텍처를-제안한-이유" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>앨리스터 콕번은 기존의 소프트웨어 개발 방식에서 반복적으로 나타나는 문제점들을 해결하고자 헥사고널 아키텍처를 고안했습니다. 전통적인 아키텍처에서는 종종 애플리케이션의 핵심 비즈니스 로직이 사용자 인터페이스(UI) 코드나 데이터베이스 접근 로직과 강하게 결합되는 경향이 있었습니다. 이러한 결합은 다음과 같은 실질적인 어려움을 야기했습니다 5</p>
<ol>
<li><strong>자동화된 테스트의 어려움</strong>: 비즈니스 로직의 일부가 UI의 시각적 세부 사항(예: 버튼 위치, 필드 크기)에 의존하게 되면, UI 변경 시 테스트 코드도 함께 수정해야 하는 등 자동화된 테스트 스위트를 안정적으로 구축하고 유지하기 어려웠습니다.</li>
<li><strong>시스템 구동 방식 전환의 어려움</strong>: 사람이 직접 UI를 통해 시스템을 사용하는 방식에서 배치(batch) 작업이나 다른 프로그램에 의해 시스템이 구동되는 방식으로 전환하는 것이 매우 복잡하거나 불가능해졌습니다.</li>
<li><strong>외부 프로그램과의 연동 제약</strong>: 다른 애플리케이션이 현재 시스템의 기능을 호출하거나 연동하려고 할 때, UI에 종속된 로직 때문에 API를 통한 깔끔한 연동이 어려웠습니다.</li>
</ol>
<p>콕번은 이러한 문제들이 본질적으로 애플리케이션의 내부 로직과 외부 세계와의 상호작용 방식이 서로 뒤섞여 발생하는 대칭적인 문제임을 간파했습니다. 즉, UI와의 결합 문제나 데이터베이스와의 결합 문제 모두 핵심 로직이 특정 외부 기술에 종속됨으로써 발생하는 유사한 성격의 문제라는 것입니다.5 헥사고널 아키텍처는 이러한 문제들을 해결하기 위해, 애플리케이션이 제공하는 모든 기능이 외부 인터페이스(API)를 통해 동등하게 접근 가능하도록 설계하는 아이디어에서 출발했습니다. 이는 단순히 학문적인 탐구를 넘어, 개발 현장에서 겪는 실제적인 고통을 줄이고, 변화에 유연하며 테스트하기 쉬운 소프트웨어를 만들고자 하는 실질적인 필요성에서 비롯된 해결책이었습니다.</p>
<h3 id="헥사고널hexagonal이라는-이름의-유래">”헥사고널(Hexagonal)“이라는 이름의 유래<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#헥사고널hexagonal이라는-이름의-유래" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>앨리스터 콕번이 이 아키텍처를 설명하면서 육각형(hexagon) 모양의 다이어그램을 사용한 데에는 특별한 이유가 있습니다. 전통적인 아키텍처 다이어그램은 주로 사각형을 사용하여 계층을 표현했는데, 이는 종종 위-아래 또는 왼쪽-오른쪽과 같은 방향성을 암시하며 특정 계층(예: UI는 위, 데이터베이스는 아래)에 대한 고정관념을 갖게 했습니다.5 콕번은 이러한 고정관념에서 벗어나고자 했습니다.</p>
<p>육각형을 선택한 주된 이유는 다음과 같습니다 5:</p>
<ul>
<li><strong>방향성 탈피</strong>: 육각형은 특정 방향(상하좌우)을 강요하지 않아, 애플리케이션 코어를 중심으로 다양한 외부 요소들이 대등하게 연결될 수 있음을 시각적으로 표현하기에 적합했습니다.</li>
<li><strong>다수의 연결점 표현</strong>: 육각형은 여러 개의 변을 가지고 있어, 애플리케이션이 다양한 종류의 외부 장치나 시스템과 여러 개의 포트(연결점)를 통해 상호작용할 수 있음을 나타내는 데 충분한 공간을 제공했습니다.</li>
<li><strong>시각적 편의성</strong>: 오각형이나 칠각형보다 그리기가 용이하면서도 사각형과는 다른 새로운 시각적 메타포를 제공할 수 있었습니다.</li>
</ul>
<p>중요한 것은 육각형의 ‘6’이라는 숫자가 아키텍처적으로 특별한 의미를 가지는 것은 아니라는 점입니다.5 애플리케이션이 필요로 하는 포트의 개수는 2개가 될 수도, 4개가 될 수도, 혹은 그 이상이 될 수도 있습니다. 육각형은 단지 애플리케이션 코어가 여러 외부 요소와 다양한 인터페이스를 통해 상호작용한다는 개념을 시각적으로 강조하기 위한 장치입니다. 이처럼 육각형이라는 시각적 표현은 단순한 그림을 넘어, 아키텍처의 핵심 철학인 ‘내부와 외부의 분리’, 그리고 ‘다양한 외부 요소와의 동등한 연결’을 직관적으로 전달하는 강력한 메타포로 작용합니다.</p>
<h3 id="핵심-구성-요소-포트ports와-어댑터adapters">핵심 구성 요소: 포트(Ports)와 어댑터(Adapters)<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#핵심-구성-요소-포트ports와-어댑터adapters" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>헥사고널 아키텍처는 크게 애플리케이션 코어(또는 헥사곤), 포트, 그리고 어댑터라는 세 가지 핵심 구성 요소로 이루어집니다.</p>
<h4 id="1-애플리케이션-코어-application-core--hexagon">1. 애플리케이션 코어 (Application Core / Hexagon)<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#1-애플리케이션-코어-application-core--hexagon" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>애플리케이션 코어는 시스템의 심장부로, 순수한 비즈니스 로직과 도메인 규칙을 담고 있습니다.2 이 코어는 UI, 데이터베이스, 특정 프레임워크와 같은 외부 기술이나 인프라스트럭처의 세부 사항으로부터 완전히 독립적이어야 합니다. 즉, 코어 로직은 외부 세계가 어떻게 변화하든 그 자체로 완전하고 일관성 있게 유지되어야 합니다. 이것이 바로 헥사고널 아키텍처가 보호하고자 하는 가장 중요한 부분이며, 외부 환경의 변화에 흔들리지 않고 애플리케이션의 본질적인 기능을 안정적으로 수행하는, 시스템의 가장 중요한 자산이라고 할 수 있습니다.</p>
<h4 id="2-포트-ports">2. 포트 (Ports)<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#2-포트-ports" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>포트는 애플리케이션 코어가 외부 세계와 상호작용하는 방법을 정의하는 인터페이스입니다.3 포트는 특정 기술에 대한 약속이 아니라, 코어가 외부와 어떤 종류의 데이터를 주고받을지, 어떤 기능을 제공하거나 사용할지에 대한 ‘계약(contract)’ 또는 API(Application Programming Interface)를 명세합니다.5 포트는 그 목적과 방향에 따라 인바운드 포트와 아웃바운드 포트로 구분됩니다.</p>
<ul>
<li><strong>인바운드 포트</strong>: 외부의 요청을 받아 애플리케이션 코어의 기능을 실행하기 위한 인터페이스입니다.3 예를 들어, 사용자의 요청을 처리하는 유스케이스(Use Case) 인터페이스나 서비스 인터페이스가 인바운드 포트에 해당할 수 있습니다. 이러한 포트는 외부의 ‘주도 어댑터(Driving Adapter)‘에 의해 호출됩니다.</li>
<li><strong>아웃바운드 포트</strong>: 애플리케이션 코어가 외부 시스템의 기능을 사용하기 위해 필요한 인터페이스입니다.3 예를 들어, 데이터베이스에 데이터를 저장하거나 조회하기 위한 리포지토리(Repository) 인터페이스, 또는 외부 서비스 API를 호출하기 위한 인터페이스가 아웃바운드 포트에 해당합니다. 이러한 포트는 애플리케이션 코어에 의해 호출되며, 외부의 ‘피주도 어댑터(Driven Adapter)‘에 의해 구현됩니다.</li>
</ul>
<p>포트는 단순한 기술적 인터페이스가 아니라, 애플리케이션 코어가 외부 세계와 ‘어떤 목적을 위해 어떻게 상호작용할 것인가’를 정의하는 의도적인 계약(Intentional Contract)입니다. 잘 정의된 포트는 시스템의 기능을 명확하게 드러내고, 코어와 외부 요소 간의 결합도를 낮추는 데 핵심적인 역할을 합니다.</p>
<h4 id="3-어댑터-adapters">3. 어댑터 (Adapters)<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#3-어댑터-adapters" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>어댑터는 포트 인터페이스와 실제 외부 기술 또는 시스템 사이를 연결하는 다리 역할을 합니다.3 어댑터는 포트에서 정의한 추상적인 약속(API)을 특정 기술이 이해할 수 있는 구체적인 방식으로 변환하거나, 그 반대의 변환을 수행합니다.5 어댑터 역시 포트와 마찬가지로 주도 어댑터와 피주도 어댑터로 나뉩니다.</p>
<ul>
<li><strong>]:</strong> 외부 세계로부터의 요청을 받아 애플리케이션 코어의 인바운드 포트를 호출하는 역할을 합니다.10 예를 들어, 웹 요청을 처리하는] 컨트롤러, GUI 이벤트 핸들러, 자동화된 테스트 스크립트 등이 주도 어댑터에 해당합니다.</li>
<li><strong>]:</strong> 애플리케이션 코어의 아웃바운드 포트 인터페이스를 구현하여, 코어가 필요로 하는 외부 기능을 실제로 제공합니다.10 예를 들어, JPA를 사용하여 데이터베이스와 통신하는 리포지토리 구현체, 외부 REST API를 호출하는 클라이언트, 메시지 큐에 메시지를 발행하는 구현체 등이 피주도 어댑터에 해당합니다.</li>
</ul>
<p>어댑터는 애플리케이션 코어의 언어(포트 인터페이스)와 외부 세계의 특정 기술 언어 사이를 번역하고 연결하는 ‘플러그 앤 플레이’ 방식의 중개자라고 생각할 수 있습니다. 특정 데이터베이스를 사용하기 위한 어댑터, 특정 메시징 시스템을 위한 어댑터, 특정 UI 프레임워크를 위한 어댑터 등 다양한 어댑터가 존재할 수 있으며, 필요에 따라 어댑터를 교체하거나 추가함으로써 시스템의 유연성을 확보할 수 있습니다.</p>
<p>다음은 헥사고널 아키텍처의 주요 구성 요소와 상호작용을 보여주는 Mermaid 다이어그램입니다.</p>
<pre><button class="expand-button" aria-label="Expand mermaid diagram" aria-hidden="true" data-view-component="true"><svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><path fill-rule="evenodd" d="M3.72 3.72a.75.75 0 011.06 1.06L2.56 7h10.88l-2.22-2.22a.75.75 0 011.06-1.06l3.5 3.5a.75.75 0 010 1.06l-3.5 3.5a.75.75 0 11-1.06-1.06l2.22-2.22H2.56l2.22 2.22a.75.75 0 11-1.06 1.06l-3.5-3.5a.75.75 0 010-1.06l3.5-3.5z"></path></svg></button><code class="mermaid" data-clipboard="&quot;graph LR\n    subgraph 외부 [External World]\n        UI_Adapter\n        Test_Adapter\n        DB_Adapter\n        API_Adapter\n    end\n\n    subgraph 헥사곤 [Application Hexagon]\n        direction LR\n        subgraph 코어 [Application Core]\n            BusinessLogic\n        end\n        InboundPort[\&quot;Inbound Port (API/UseCase)\&quot;]\n        OutboundPort_DB\n        OutboundPort_API\n    end\n\n    UI_Adapter -- invokes --> InboundPort\n    Test_Adapter -- invokes --> InboundPort\n    InboundPort -- uses --> BusinessLogic\n    BusinessLogic -- uses --> OutboundPort_DB\n    BusinessLogic -- uses --> OutboundPort_API\n    OutboundPort_DB -- implemented by --> DB_Adapter\n    OutboundPort_API -- implemented by --> API_Adapter\n\n    style BusinessLogic fill:#f9f,stroke:#333,stroke-width:2px\n    style InboundPort fill:#ccf,stroke:#333,stroke-width:2px\n    style OutboundPort_DB fill:#ccf,stroke:#333,stroke-width:2px\n    style OutboundPort_API fill:#ccf,stroke:#333,stroke-width:2px&quot;">graph LR
    subgraph 외부 [External World]
        UI_Adapter
        Test_Adapter
        DB_Adapter
        API_Adapter
    end

    subgraph 헥사곤 [Application Hexagon]
        direction LR
        subgraph 코어 [Application Core]
            BusinessLogic
        end
        InboundPort[&quot;Inbound Port (API/UseCase)&quot;]
        OutboundPort_DB
        OutboundPort_API
    end

    UI_Adapter -- invokes --> InboundPort
    Test_Adapter -- invokes --> InboundPort
    InboundPort -- uses --> BusinessLogic
    BusinessLogic -- uses --> OutboundPort_DB
    BusinessLogic -- uses --> OutboundPort_API
    OutboundPort_DB -- implemented by --> DB_Adapter
    OutboundPort_API -- implemented by --> API_Adapter

    style BusinessLogic fill:#f9f,stroke:#333,stroke-width:2px
    style InboundPort fill:#ccf,stroke:#333,stroke-width:2px
    style OutboundPort_DB fill:#ccf,stroke:#333,stroke-width:2px
    style OutboundPort_API fill:#ccf,stroke:#333,stroke-width:2px
</code><div id="mermaid-container"><div id="mermaid-space"><div class="mermaid-header"><button class="close-button" aria-label="close button"><svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg></button></div><div class="mermaid-content"></div></div></div></pre>
<p>이 다이어그램은 헥사고널 아키텍처의 핵심 원칙 중 하나인 “의존성 흐름”을 명확하게 보여줍니다. 주도 어댑터(UI Adapter, Test Adapter)는 인바운드 포트를 호출하고, 이 인바운드 포트는 코어 비즈니스 로직을 사용합니다. 코어 비즈니스 로직은 다시 아웃바운드 포트(Repository Interface, External Service Interface)를 사용하며, 이 아웃바운드 포트는 외부의 피주도 어댑터(Database Adapter, External API Adapter)에 의해 구현됩니다. 중요한 점은 모든 의존성이 외부에서 내부(코어)를 향하거나, 코어가 정의한 추상화(포트)에 의존한다는 것입니다. 이는 전통적인 계층형 아키텍처에서 흔히 볼 수 있는, 비즈니스 로직이 데이터베이스와 같은 하위 계층의 구체적인 구현에 직접 의존하는 것과는 대조적입니다. 이러한 시각화는 헥사고널 아키텍처의 의존성 관리 방식을 직관적으로 이해하는 데 큰 도움을 줍니다.</p>
<h3 id="의존성-역전-원칙-dependency-inversion-principle과-헥사고널-아키텍처"><a href="./의존성-역전-원칙-(Dependency-Inversion-Principle)" class="internal alias" data-slug="의존성-역전-원칙-(Dependency-Inversion-Principle)">의존성 역전 원칙 (Dependency Inversion Principle)</a>과 헥사고널 아키텍처<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#의존성-역전-원칙-dependency-inversion-principle과-헥사고널-아키텍처" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>헥사고널 아키텍처의 핵심적인 설계 원리 중 하나는 <strong>의존성 역전 원칙(Dependency Inversion Principle, DIP)</strong> 을 적극적으로 활용한다는 것입니다.4</p>
<p>DIP의 핵심 내용은 다음과 같습니다 4:</p>
<ul>
<li>고수준 모듈은 저수준 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다.</li>
<li>추상화는 세부 사항에 의존해서는 안 된다. 세부 사항이 추상화에 의존해야 한다.</li>
</ul>
<p>헥사고널 아키텍처에서 이 원칙은 다음과 같이 적용됩니다:</p>
<ul>
<li>**애플리케이션 코어(고수준 모듈)**는 자신이 필요로 하는 기능(예: 데이터 저장, 알림 발송)을 **포트(추상화)**라는 인터페이스로 정의합니다.</li>
<li>**어댑터(저수준 모듈)**는 이 포트 인터페이스를 **구현(세부 사항)**합니다.</li>
<li>결과적으로, 애플리케이션 코어는 어댑터의 구체적인 기술(예: MySQL, Kafka, SMTP)이나 구현 방식에 대해 전혀 알 필요 없이, 오직 자신이 정의한 포트 인터페이스에만 의존하게 됩니다.</li>
</ul>
<p>이러한 의존성 역전은 매우 중요합니다. 만약 DIP가 적용되지 않는다면, 애플리케이션 코어가 특정 데이터베이스 라이브러리나 UI 프레임워크의 구체적인 클래스를 직접 참조하게 될 것입니다. 이는 코어를 외부 기술에 종속시키고, 헥사고널 아키텍처가 추구하는 유연성과 테스트 용이성을 심각하게 저해합니다. 따라서 의존성 역전 원칙은 단순히 좋은 설계 지침을 넘어, 헥사고널 아키텍처가 그 목적을 달성할 수 있도록 하는 근본적인 메커니즘입니다. 의존성의 방향이 전통적인 방식(코어 <span>→</span> 외부 기술)과 반대로, 외부(어댑터)에서 내부(코어가 정의한 포트)로 향하게 함으로써 코어의 독립성과 순수성을 지킬 수 있게 되는 것입니다.</p>
<h2 id="iii-헥사고널-아키텍처의-장점">III. 헥사고널 아키텍처의 장점<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#iii-헥사고널-아키텍처의-장점" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>헥사고널 아키텍처를 올바르게 적용했을 때 얻을 수 있는 이점은 다양하며, 이는 시스템의 품질과 개발 생산성에 긍정적인 영향을 미칩니다.</p>
<h3 id="향상된-테스트-용이성-improved-testability">향상된 테스트 용이성 (Improved Testability)<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#향상된-테스트-용이성-improved-testability" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>헥사고널 아키텍처의 가장 두드러진 장점 중 하나는 테스트 용이성의 향상입니다.1 애플리케이션 코어가 UI, 데이터베이스, 외부 API와 같은 외부 기술로부터 완전히 분리되어 있기 때문에, 핵심 비즈니스 로직을 이러한 외부 요소 없이도 독립적으로, 그리고 매우 신속하게 테스트할 수 있습니다.</p>
<p>테스트 시에는 실제 어댑터 대신 목(Mock) 어댑터나 스텁(Stub) 어댑터를 사용하여 포트 인터페이스를 구현함으로써 테스트 환경을 손쉽게 제어할 수 있습니다.8 예를 들어, 데이터베이스에 접근하는 아웃바운드 포트에 대해 메모리 기반의 목 리포지토리를 구현하여 사용하면, 실제 데이터베이스를 구동하지 않고도 데이터 영속성 관련 로직을 제외한 순수 비즈니스 로직을 빠르게 테스트할 수 있습니다. 이는 특히 단위 테스트와 통합 테스트 작성에 매우 유리합니다.</p>
<p>이러한 테스트 용이성 향상은 단순히 테스트 코드 작성이 쉬워지는 것을 넘어, 개발 과정에서 훨씬 빠르고 안정적인 피드백 루프를 구축할 수 있게 합니다. 이는 애자일(Agile) 개발 방식이나],]2와 같은 현대적인 개발 방법론과 매우 잘 부합합니다. 버그를 조기에 발견하고 수정함으로써 전체 개발 비용을 절감하고, 최종적으로 소프트웨어의 품질을 높이는 데 크게 기여합니다.</p>
<h3 id="유연성-및-확장성-flexibility-and-extensibility">유연성 및 확장성 (Flexibility and Extensibility)<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#유연성-및-확장성-flexibility-and-extensibility" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>애플리케이션 코어가 외부 기술로부터 분리되어 있기 때문에, 시스템의 유연성과 확장성이 크게 향상됩니다. 외부 시스템이나 기술(예: 데이터베이스 종류 변경, UI 프레임워크 교체, 새로운 메시징 시스템 도입)을 변경하거나 새로운 기술을 도입해야 할 때, 애플리케이션 코어 로직에는 거의 또는 전혀 영향을 주지 않고 해당 기술과 관련된 어댑터만 수정하거나 새로 추가하면 됩니다.8</p>
<p>또한, 새로운 비즈니스 기능이나 외부 시스템과의 연동 요구사항이 발생했을 때, 기존 코어 로직을 최대한 재사용하면서 새로운 포트와 그에 맞는 어댑터를 추가하는 방식으로 시스템을 비교적 쉽게 확장할 수 있습니다.2 이러한 “플러그인 스타일” 아키텍처 13는 시스템이 변화하는 비즈니스 요구사항과 기술 환경에 민첩하게 대응할 수 있도록 합니다.</p>
<p>이러한 유연성은 애플리케이션을 장기적으로 “미래 경쟁력 있는(future-proof)” 상태로 유지하는 데 도움을 줍니다. 특정 기술에 종속되지 않음으로써, 새로운 기술 트렌드가 등장하거나 기존 기술이 노후화되었을 때 보다 쉽게 시스템을 현대화하고 발전시킬 수 있습니다. 이는 특히 마이크로서비스 아키텍처4와 같이 여러 독립적인 서비스로 구성된 분산 시스템 환경에서 각 서비스의 독립성을 유지하며 발전시키는 데 매우 유리한 특성입니다.</p>
<h3 id="기술적-변화로부터-비즈니스-로직-보호">기술적 변화로부터 비즈니스 로직 보호<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#기술적-변화로부터-비즈니스-로직-보호" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>헥사고널 아키텍처는 애플리케이션의 핵심 자산인 비즈니스 로직을 외부의 기술적인 변화로부터 효과적으로 보호합니다. 애플리케이션 코어는 외부 기술의 세부 사항(예: 특정 데이터베이스의 SQL 문법, 특정 프레임워크의 API)으로부터 완전히 격리되어 있기 때문에, 사용 중인 프레임워크의 버전 업데이트, 라이브러리 변경, 혹은 인프라스트럭처 교체와 같은 기술적인 변화가 핵심 비즈니스 로직에 미치는 영향을 최소화할 수 있습니다.2</p>
<p>비즈니스 로직이 이처럼 기술 변화로부터 보호된다는 것은 시스템 변경 시 발생할 수 있는 예기치 않은 버그나 기능 회귀(regression)의 위험을 크게 줄여줍니다.2 또한, 특정 기술에 대한 의존성이 낮아지므로 해당 기술의 변화에 따른 유지보수 작업 범위가 줄어들어 전체적인 유지보수 비용도 절감될 수 있습니다. 이는 개발팀이 비즈니스 가치를 창출하는 핵심 로직 개발에 더 집중할 수 있도록 돕습니다.</p>
<h3 id="외부-시스템-교체의-용이성">외부 시스템 교체의 용이성<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#외부-시스템-교체의-용이성" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>위에서 언급된 유연성의 한 측면으로, 헥사고널 아키텍처는 외부 시스템을 교체하는 작업을 상대적으로 용이하게 만듭니다. 예를 들어, 현재 사용 중인 관계형 데이터베이스를 NoSQL 데이터베이스로 교체하거나, 특정 외부 서비스 제공자(예: 이메일 발송 서비스, 결제 서비스)를 다른 제공자로 변경해야 하는 상황이 발생할 수 있습니다. 헥사고널 아키텍처에서는 이러한 변경이 필요할 때, 해당 외부 시스템과 연동되는 어댑터만 새로 구현하거나 수정하면 됩니다.4 애플리케이션 코어는 포트 인터페이스를 통해 일관된 방식으로 외부 시스템과 상호작용하므로, 코어 로직의 변경은 최소화됩니다.</p>
<p>이러한 외부 시스템 교체의 용이성은 기업이 특정 벤더나 기술에 종속되는 것을 방지하고(vendor lock-in 방지), 비용 효율적이거나 더 나은 성능을 제공하는 새로운 솔루션으로 유연하게 전환할 수 있는 전략적 민첩성을 제공합니다. 이는 빠르게 변화하는 비즈니스 환경과 기술 트렌드에 효과적으로 적응하는 데 매우 중요한 요소입니다.</p>
<h3 id="관심사-분리-separation-of-concerns"><a href="./관심사-분리-(Separation-of-Concerns)" class="internal alias" data-slug="관심사-분리-(Separation-of-Concerns)">관심사 분리 (Separation of Concerns)</a><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#관심사-분리-separation-of-concerns" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>헥사고널 아키텍처는 애플리케이션 코어(비즈니스 로직), 포트(애플리케이션 인터페이스), 어댑터(외부 연동 기술) 간의 역할과 책임을 명확하게 구분합니다.3 이러한 명확한 관심사 분리는 코드의 가독성, 이해도, 그리고 궁극적으로 유지보수성을 높이는 데 크게 기여합니다.4</p>
<p>각 구성 요소는 자신만의 명확한 책임을 가지므로, 개발자는 특정 기능을 수정하거나 추가할 때 시스템의 어느 부분을 변경해야 할지 쉽게 파악할 수 있습니다. 예를 들어, UI 표시 방식 변경은 UI 어댑터에, 데이터베이스 스키마 변경은 데이터베이스 어댑터에, 핵심 비즈니스 규칙 변경은 애플리케이션 코어에 집중하여 작업할 수 있습니다.</p>
<p>이처럼 명확한 관심사 분리는 서로 다른 기술 스택이나 전문성을 가진 개발팀 간의 협업을 용이하게 합니다. 프론트엔드 개발자는 UI 어댑터에, 백엔드 개발자는 애플리케이션 코어와 데이터베이스 어댑터에 집중할 수 있으며, 각 컴포넌트의 경계가 명확하므로 독립적인 개발과 테스트, 심지어 배포까지도 더 용이해질 수 있습니다. 이는 코드의 모듈성을 높여 전체 시스템의 복잡성을 효과적으로 관리하는 데 도움을 줍니다.12</p>
<h3 id="의사결정-지연-deferring-decisions">의사결정 지연 (Deferring Decisions)<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#의사결정-지연-deferring-decisions" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>헥사고널 아키텍처를 적용하면 개발 초기 단계에서 특정 기술 선택에 대한 의사결정을 뒤로 미룰 수 있는 장점이 있습니다.13 개발팀은 우선 애플리케이션의 핵심 비즈니스 로직을 정의하고 구현하는 데 집중할 수 있으며, 이 로직을 어떤 UI 프레임워크로 보여줄지, 어떤 데이터베이스에 저장할지, 어떤 메시징 시스템과 연동할지에 대한 구체적인 결정은 프로젝트의 후반부나 필요성이 명확해지는 시점까지 연기할 수 있습니다.</p>
<p>프로젝트 초기에 모든 기술 스택을 확정하는 것은 상당한 위험을 수반할 수 있습니다. 프로젝트가 진행됨에 따라 요구사항이 변경될 수도 있고, 초기에 선택했던 기술보다 더 적합하거나 효율적인 새로운 기술이 등장할 수도 있기 때문입니다. 헥사고널 아키텍처는 이러한 기술 의존적인 결정을 “마지막 책임 있는 순간(last responsible moment)“까지 미룰 수 있게 함으로써, 초기 단계의 불확실성에 대한 대응력을 높이고 변화하는 요구사항에 더욱 유연하게 적응할 수 있도록 지원합니다.13 이는 불필요한 재작업을 줄이고, 프로젝트의 성공 가능성을 높이는 데 기여합니다.</p>
<h2 id="iv-헥사고널-아키텍처의-단점-및-고려사항">IV. 헥사고널 아키텍처의 단점 및 고려사항<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#iv-헥사고널-아키텍처의-단점-및-고려사항" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>모든 아키텍처 패턴과 마찬가지로 헥사고널 아키텍처 역시 장점만 있는 것은 아닙니다. 성공적인 도입을 위해서는 몇 가지 단점과 고려사항을 충분히 인지하고 대비해야 합니다.</p>
<h3 id="초기-학습-곡선-steeper-learning-curve">초기 학습 곡선 (Steeper Learning Curve)<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#초기-학습-곡선-steeper-learning-curve" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>전통적인 계층형 아키텍처에 익숙한 개발자들에게는 포트, 어댑터, 의존성 역전과 같은 헥사고널 아키텍처의 핵심 개념들이 다소 생소하고 복잡하게 느껴질 수 있습니다.8 특히, 애플리케이션의 기능을 추상적인 포트 인터페이스로 정의하고, 이를 다양한 어댑터로 구현하여 연결하는 방식은 처음 접하는 개발자에게 직관적이지 않을 수 있습니다.</p>
<p>올바른 포트와 어댑터를 설계하고, 의존성 관계를 명확하게 설정하기 위해서는 아키텍처 원리에 대한 충분한 이해와 경험이 필요합니다.8 따라서 헥사고널 아키텍처를 성공적으로 도입하기 위해서는 팀 전체의 학습과 이해가 필수적입니다. 단순히 패턴의 구조를 모방하는 것을 넘어, 그 기본 원리와 철학을 공유하고, 필요한 경우 경험이 풍부한 개발자의 멘토링이나 가이드가 도움이 될 수 있습니다. 특히 초기 설계 단계에서 포트의 역할과 경계를 어떻게 설정할 것인지에 대한 신중한 계획과 검토가 중요하며, 이는 추가적인 설계 노력을 요구할 수 있습니다.8</p>
<h3 id="증가된-코드-복잡성-및-간접-참조-increased-code-complexity-and-indirection">증가된 코드 복잡성 및 간접 참조 (Increased Code Complexity and Indirection)<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#증가된-코드-복잡성-및-간접-참조-increased-code-complexity-and-indirection" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>헥사고널 아키텍처는 포트와 어댑터를 통해 여러 계층의 간접 참조(indirection)를 도입합니다. 이로 인해 단순한 기능을 가진 애플리케이션의 경우, 전통적인 방식보다 코드의 양이 더 많아지고 전체적인 구조가 더 복잡해 보일 수 있습니다.13 예를 들어, 간단한 CRUD(Create, Read, Update, Delete) 연산만을 수행하는 애플리케이션에 헥사고널 아키텍처를 완전하게 적용하면, 포트 인터페이스, 서비스 구현체, 어댑터 구현체 등 여러 클래스와 인터페이스가 추가로 필요하게 됩니다.</p>
<p>컴퓨터 과학 분야의 격언 중 “모든 문제는 또 다른 간접 참조 계층으로 해결할 수 있다. 너무 많은 간접 참조 계층 문제만 빼고”라는 말이 있듯이 13, 과도하거나 불필요한 간접 참조는 오히려 코드의 흐름을 파악하기 어렵게 만들고 시스템의 복잡성을 증가시킬 수 있습니다.</p>
<p>따라서 헥사고널 아키텍처의 장점을 살리면서도 불필요한 복잡성을 피하기 위해서는 추상화 수준에 대한 신중한 균형 감각이 필요합니다. 모든 외부 상호작용에 대해 엄격하게 포트와 어댑터를 적용하기보다는, 실제로 분리가 필요하고 유연성이 요구되는 중요한 경계에 선택적으로 적용하는 실용적인 접근 방식이 중요할 수 있습니다. 프로젝트의 규모와 복잡도, 팀의 성숙도 등을 종합적으로 고려하여 적절한 수준의 추상화를 적용해야 합니다.</p>
<h3 id="모델-간-번역-오버헤드-translation-overhead-between-models">모델 간 번역 오버헤드 (Translation Overhead between models)<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#모델-간-번역-오버헤드-translation-overhead-between-models" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>애플리케이션 코어는 자체적인 <a href="./도메인-모델(Domain-Model)" class="internal alias" data-slug="도메인-모델(Domain-Model)">도메인 모델(Domain Model)</a>을 사용하여 비즈니스 로직을 표현합니다. 반면, 어댑터는 외부 시스템과 통신하기 위해 각 시스템에 특화된 데이터 모델을 사용할 수 있습니다. 예를 들어, 웹 어댑터(컨트롤러)는 HTTP 요청/응답을 위한 데이터 전송 객체를 사용하고, 영속성 어댑터(리포지토리 구현체)는 데이터베이스 스키마에 매핑되는 엔티티(Entity) 객체를 사용할 수 있습니다.13</p>
<p>이로 인해 애플리케이션 코어의 도메인 모델과 어댑터에서 사용하는 외부 모델 간의 데이터 변환(mapping) 작업이 필요하게 됩니다. 이러한 매핑 로직은 추가적인 개발 노력을 요구하며, 경우에 따라 약간의 런타임 오버헤드를 발생시킬 수도 있습니다.13 모델이 복잡하거나 변환 로직이 많아질 경우, 이 작업은 번거롭고 오류 발생 가능성이 있는 부분이 될 수 있습니다.</p>
<p>하지만 이러한 모델 간 매핑은 단순히 번거로운 작업으로만 볼 것은 아닙니다. 각 계층의 관심사를 명확히 분리하고, 각 모델이 해당 계층의 목적에 최적화되도록 하는 중요한 역할을 수행하기 때문입니다. 예를 들어, API DTO는 API 클라이언트와의 계약을 안정적으로 유지하는 데 중점을 두고, 도메인 모델은 순수한 비즈니스 규칙을 표현하는 데 집중하며, 데이터베이스 엔티티는 영속성 메커니즘과의 효율적인 상호작용을 고려하여 설계될 수 있습니다. 이러한 분리는 일종의 안티코럽션 계층 (Anti-Corruption Layer)처럼 작용하여, 외부 시스템의 모델 변경이 애플리케이션 코어의 도메인 모델에 직접적인 영향을 미치는 것을 방지하고 도메인 모델의 순수성과 안정성을 유지하는 데 기여합니다.]을 통해 이러한 매핑 오버헤드를 최소화하고 가치를 극대화하는 방안(예: 자동 매퍼 라이브러리 활용)을 고려하는 것이 좋습니다.</p>
<h3 id="과도한-엔지니어링-가능성-potential-for-over-engineering-in-simple-projects">과도한 엔지니어링 가능성 (Potential for Over-engineering in simple projects)<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#과도한-엔지니어링-가능성-potential-for-over-engineering-in-simple-projects" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>모든 프로젝트에 헥사고널 아키텍처가 최적의 선택은 아닙니다. 비교적 단순하고 단기적으로 운영될 프로젝트, 또는 외부 시스템과의 연동이 거의 없거나 매우 제한적인 소규모 애플리케이션의 경우, 헥사고널 아키텍처를 도입하는 것이 불필요한 복잡성만 가중시키는 과도한 엔지니어링(over-engineering)이 될 수 있습니다.14 추가적인 인터페이스와 클래스, 그리고 모델 간 매핑 로직을 작성하는 데 드는 노력은 프로젝트의 규모나 복잡도에 비해 그 이점이 크지 않을 수 있습니다.15</p>
<p>아키텍처 선택은 항상 프로젝트의 구체적인 맥락(규모, 복잡도, 팀의 역량, 예상되는 변경 빈도, 장기적인 비전 등)을 종합적으로 고려하여 이루어져야 합니다. 헥사고널 아키텍처가 제공하는 유연성, 테스트 용이성 등의 장점이 프로젝트가 직면한 문제 해결에 실질적으로 기여하고, 그로 인해 발생하는 추가적인 복잡성이나 개발 노력을 상쇄할 수 있다고 판단될 때 선택하는 것이 현명합니다. 무조건적으로 특정 아키텍처 패턴을 따르기보다는, 실용적인 관점에서 그 효용성을 평가하는 자세가 필요합니다.</p>
<h3 id="디버깅의-어려움-debugging">디버깅의 어려움 (Debugging)<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#디버깅의-어려움-debugging" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>포트와 어댑터를 통한 간접 참조 계층이 많아지면, 특정 로직의 실행 흐름을 추적하거나 디버깅하는 것이 다소 어려워질 수 있습니다.13 예를 들어, 사용자 요청이 컨트롤러(주도 어댑터)를 통해 서비스 인터페이스(인바운드 포트)로 전달되고, 다시 서비스 구현체에서 리포지토리 인터페이스(아웃바운드 포트)를 호출하여 데이터베이스 어댑터(피주도 어댑터)로 이어지는 과정을 디버깅할 때, 여러 인터페이스와 구현체를 넘나들며 실행 경로를 따라가야 할 수 있습니다.</p>
<p>이러한 디버깅의 어려움을 완화하기 위해서는 몇 가지 전략을 고려할 수 있습니다. 첫째, 각 어댑터와 포트의 경계에서 명확하고 유용한 정보를 담은 로깅(logging) 전략을 수립하는 것이 중요합니다. 둘째, IDE(통합 개발 환경)에서 제공하는 디버깅 도구(예: 스택 트레이스 분석, 조건부 중단점 설정)를 효과적으로 활용하는 능력을 갖추는 것이 도움이 됩니다. 마지막으로, 헥사고널 아키텍처의 주요 장점인 테스트 용이성을 적극 활용하여, 각 컴포넌트에 대한 잘 작성된 단위 테스트와 통합 테스트를 충분히 확보하는 것입니다. 이는 시스템의 각 부분이 예상대로 작동함을 보장하여 복잡한 전체 시스템 디버깅의 필요성을 줄여주는 데 기여할 수 있습니다.</p>
<h2 id="v-헥사고널-아키텍처-vs-계층형-아키텍처layered-architecture">V. 헥사고널 아키텍처 vs. <a href="./계층형-아키텍처(Layered-Architecture)" class="internal alias" data-slug="계층형-아키텍처(Layered-Architecture)">계층형 아키텍처(Layered Architecture)</a><a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#v-헥사고널-아키텍처-vs-계층형-아키텍처layered-architecture" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>헥사고널 아키텍처를 이해하는 데 있어 전통적인 계층형 아키텍처와의 비교는 매우 유용합니다. 두 아키텍처 모두 시스템을 구성하는 요소들을 분리하려는 목적을 가지고 있지만, 그 방식과 철학에는 중요한 차이점이 있습니다.</p>
<h3 id="전통적인-계층형-아키텍처-소개">전통적인 계층형 아키텍처 소개<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#전통적인-계층형-아키텍처-소개" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>전통적인 계층형 아키텍처(Layered Architecture 또는 N-Tier Architecture)는 시스템을 논리적인 계층으로 분리하는 가장 널리 알려진 방식 중 하나입니다. 일반적으로 다음과 같은 계층으로 구성됩니다 8:</p>
<ul>
<li><strong>프레젠테이션 계층 (Presentation Layer)</strong>: 사용자 인터페이스(UI)를 담당하며, 사용자와의 상호작용을 처리합니다. 웹 애플리케이션의 경우 웹 페이지, API 엔드포인트 등이 여기에 해당합니다.</li>
<li><strong>비즈니스 로직 계층 (Business Logic Layer / Service Layer)</strong>: 애플리케이션의 핵심 비즈니스 규칙과 로직을 수행합니다. 사용자의 요청을 받아 데이터를 처리하고, 비즈니스 규칙에 따라 결과를 반환합니다.</li>
<li><strong>데이터 접근 계층 (Data Access Layer / Persistence Layer)</strong>: 데이터베이스나 다른 영속성 저장소와의 상호작용을 담당합니다. 데이터의 저장, 조회, 수정, 삭제(CRUD) 작업을 수행합니다.</li>
</ul>
<p>계층형 아키텍처의 핵심적인 특징 중 하나는 각 계층이 일반적으로 자신의 바로 아래 계층에만 의존하는 선형적인 의존성 구조를 가진다는 것입니다.8 예를 들어, 프레젠테이션 계층은 비즈니스 로직 계층에 의존하고, 비즈니스 로직 계층은 데이터 접근 계층에 의존하는 형태입니다.</p>
<h3 id="주요-차이점-비교">주요 차이점 비교<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#주요-차이점-비교" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>헥사고널 아키텍처와 전통적인 계층형 아키텍처의 주요 차이점은 다음과 같습니다.</p>
<ul>
<li>
<p><strong>의존성 방향</strong>:</p>
<ul>
<li><strong>계층형</strong>: 일반적으로 상위 계층이 하위 계층에 의존합니다 (예: UI → 비즈니스 로직 → 데이터 접근).8 이러한 의존성은 단방향으로 흐르는 경향이 있습니다.</li>
<li><strong>헥사고널</strong>:]을 통해 외부(어댑터)가 내부(애플리케이션 코어의 포트)로 의존합니다. 즉, 모든 의존성이 애플리케이션 코어를 향하거나, 코어가 정의한 추상화(포트)를 향합니다.2 이는 의존성의 흐름이 계층형과 반대되거나 중심 지향적임을 의미합니다.</li>
</ul>
</li>
<li>
<p><strong>결합도 (Coupling)</strong>:</p>
<ul>
<li><strong>계층형</strong>: 하위 계층의 변경이 상위 계층에 영향을 미칠 수 있는 단방향의 강한 결합(tight coupling)이 발생하기 쉽습니다.8 예를 들어, 데이터 접근 계층의 인터페이스가 변경되면 비즈니스 로직 계층도 영향을 받을 수 있습니다.</li>
<li><strong>헥사고널</strong>: 포트와 어댑터를 통해 느슨한 결합(loose coupling)을 지향합니다. 애플리케이션 코어는 포트라는 추상화된 인터페이스에만 의존하므로, 외부 어댑터의 구체적인 구현 변경으로부터 상대적으로 자유롭습니다.8</li>
</ul>
</li>
<li>
<p><strong>유연성 및 테스트 용이성</strong>:</p>
<ul>
<li><strong>계층형</strong>: 계층 간의 직접적인 의존성으로 인해 특정 계층만 독립적으로 교체하거나 테스트하기 어려울 수 있습니다.8 예를 들어, 비즈니스 로직을 테스트하기 위해서는 실제 데이터 접근 계층이나 목(mock) 객체가 필요하며, 이는 테스트 환경 구성을 복잡하게 만들 수 있습니다.</li>
<li><strong>헥사고널</strong>: 애플리케이션 코어 로직과 외부 요소(UI, DB 등)가 명확히 분리되어 있어 유연성이 높습니다. 특정 어댑터를 다른 구현으로 교체하기 용이하며, 코어 로직은 목 어댑터를 활용하여 외부 의존성 없이 독립적으로 테스트할 수 있습니다.8</li>
</ul>
</li>
<li>
<p><strong>중심 사상</strong>:</p>
<ul>
<li><strong>계층형</strong>: 종종 데이터베이스나 UI를 아키텍처의 기반 또는 중심으로 간주하고 계층을 구성하는 경향이 있습니다.18 즉, 기술적인 관심사가 아키텍처 구조에 큰 영향을 미칠 수 있습니다.</li>
<li><strong>헥사고널</strong>:]의 영향을 받아 비즈니스 도메인 로직을 아키텍처의 절대적인 중심으로 둡니다.2 다른 모든 외부 요소(UI, DB, 외부 API 등)는 이 핵심 도메인을 지원하는 주변부 역할로 간주되며, 어댑터를 통해 연결됩니다.</li>
</ul>
</li>
</ul>
<h3 id="표-헥사고널-아키텍처-vs-계층형-아키텍처-비교">표: 헥사고널 아키텍처 vs. 계층형 아키텍처 비교<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#표-헥사고널-아키텍처-vs-계층형-아키텍처-비교" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>두 아키텍처의 핵심적인 차이점을 한눈에 비교하여 독자의 이해를 돕기 위해 다음 표를 제시합니다. 이 표는 특히 8과 18의 내용을 기반으로 구성되었습니다.</p>


















































<div class="table-container"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>특징</strong></td><td><strong>전통적인 계층형 아키텍처</strong></td><td><strong>헥사고널 아키텍처 (포트와 어댑터)</strong></td></tr><tr><td><strong>주요 관심사</strong></td><td>기술 계층 분리 (UI, 비즈니스, 데이터)</td><td>비즈니스 로직 중심, 외부 관심사로부터의 분리</td></tr><tr><td><strong>의존성 방향</strong></td><td>상위 계층 → 하위 계층 (선형적)</td><td>외부 (어댑터) → 내부 (코어의 포트) (중심 지향적, 의존성 역전)</td></tr><tr><td><strong>결합도</strong></td><td>상대적으로 강한 결합 (Tightly coupled)</td><td>느슨한 결합 (Loosely coupled)</td></tr><tr><td><strong>유연성</strong></td><td>낮음 (하위 계층 변경이 상위 계층에 영향)</td><td>높음 (외부 요소 교체 용이, 코어 로직 영향 최소화)</td></tr><tr><td><strong>테스트 용이성</strong></td><td>상대적으로 어려움 (계층 간 의존성으로 독립 테스트 제약)</td><td>높음 (코어 로직 독립 테스트 용이, 목(Mock) 어댑터 활용)</td></tr><tr><td><strong>주요 구조</strong></td><td>계층 (Layers)</td><td>코어 (Hexagon), 포트 (Ports), 어댑터 (Adapters)</td></tr><tr><td><strong>데이터베이스/UI 위치</strong></td><td>종종 아키텍처의 기반 또는 최하위/최상위 계층으로 간주</td><td>애플리케이션 코어의 외부, 어댑터를 통해 연결되는 주변 요소</td></tr></tbody></table></div>
<p>이러한 비교를 통해 알 수 있듯이, 헥사고널 아키텍처는 전통적인 계층형 사고방식에서 벗어나, 애플리케이션 코어를 중심으로 “내부(inside)“와 “외부(outside)“라는 명확한 경계를 설정하고, 이 경계를 통해 어떻게 상호작용할 것인지(포트와 어댑터)에 집중하는 관점의 전환을 요구합니다.18 이는 단순히 계층을 나누는 것을 넘어, 시스템의 핵심 가치인 비즈니스 로직을 보호하고 외부 환경의 변화에 유연하게 대응하기 위한 전략적인 접근 방식이라고 할 수 있습니다.</p>
<h2 id="vi-헥사고널-아키텍처와-다른-아키텍처들">VI. 헥사고널 아키텍처와 다른 아키텍처들<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#vi-헥사고널-아키텍처와-다른-아키텍처들" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>헥사고널 아키텍처는 그 자체로도 중요하지만, 유사한 목표를 추구하는 다른 현대적인 아키텍처 패턴들과의 관계를 이해하는 것도 중요합니다. 대표적으로 클린 아키텍처(Clean Architecture)와 어니언 아키텍처(Onion Architecture)가 있습니다.</p>
<h3 id="클린-아키텍처-clean-architecture와의-관계">클린 아키텍처 (Clean Architecture)와의 관계<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#클린-아키텍처-clean-architecture와의-관계" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>클린 아키텍처는 로버트 C. 마틴(Robert C. Martin, 일명 Uncle Bob)에 의해 제안된 아키텍처 패턴으로, 헥사고널 아키텍처의 핵심 원칙들을 수용하고 이를 더욱 구체화하거나 확장한 개념으로 볼 수 있습니다.7</p>
<p><strong>공통 목표</strong>: 두 아키텍처 모두 다음과 같은 핵심 목표를 공유합니다:</p>
<ul>
<li><strong>도메인 중심</strong>: 애플리케이션의 핵심 비즈니스 로직(도메인)을 시스템의 가장 안쪽, 중심에 둡니다.</li>
<li><strong>외부 의존성으로부터의 독립</strong>: 프레임워크, UI, 데이터베이스, 외부 API 등 외부 기술적 세부 사항으로부터 핵심 로직을 독립적으로 유지합니다.</li>
<li><strong>의존성 규칙</strong>: 모든 의존성은 외부에서 내부를 향해야 합니다. 즉, 내부의 코어 로직은 외부의 구체적인 구현에 대해 알지 못해야 합니다.7</li>
</ul>
<p><strong>차이점 (관점에 따라)</strong>:</p>
<ul>
<li><strong>계층 구조의 명시성</strong>: 클린 아키텍처는 동심원 형태의 다이어그램을 사용하여 보다 세분화된 계층(예: Entities, Use Cases, Interface Adapters, Frameworks &amp; Drivers)을 명시적으로 제시하는 경향이 있습니다.7 각 계층 간의 의존성 규칙 또한 엄격하게 정의됩니다.</li>
<li><strong>초점의 차이</strong>: 헥사고널 아키텍처는 애플리케이션 코어와 외부 세계 간의 상호작용 지점인 “포트”와 이를 구체화하는 “어댑터”를 통한 “내부”와 “외부”의 분리에 더 큰 초점을 맞추는 반면, 클린 아키텍처는 애플리케이션 내부 구조 자체의 계층화와 각 계층의 역할 정의에 더 중점을 둘 수 있습니다.20</li>
</ul>
<p>실제로 로버트 C. 마틴은 클린 아키텍처가 헥사고널 아키텍처를 포함한 여러 유사 아키텍처들의 아이디어를 통합하려는 시도라고 언급한 바 있습니다.20 따라서 클린 아키텍처는 헥사고널 아키텍처의 핵심 아이디어를 기반으로, 애플리케이션 내부 구조를 엔티티, 유스케이스 등과 같은 더 구체적인 역할로 나누어 제시함으로써, 헥사고널 아키텍처를 더욱 구체화하거나 확장한 형태로 이해할 수 있습니다. 많은 경우, 두 용어는 실질적으로 매우 유사한 아키텍처 스타일을 지칭하는 데 혼용되기도 하며, 중요한 것은 이들이 공유하는 핵심 원칙(도메인 중심, 의존성 역전)을 이해하고 적용하는 것입니다.</p>
<h3 id="어니언-아키텍처-onion-architecture와의-유사점">어니언 아키텍처 (Onion Architecture)와의 유사점<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#어니언-아키텍처-onion-architecture와의-유사점" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>제프리 팔레르모(Jeffrey Palermo)가 제안한 어니언 아키텍처 또한 헥사고널 아키텍처 및 클린 아키텍처와 매우 유사한 목표와 원칙을 공유합니다.13 이름에서 알 수 있듯이, 양파 껍질처럼 여러 계층이 애플리케이션 코어를 감싸는 형태로 시각화됩니다.</p>
<p><strong>핵심 유사점</strong>:</p>
<ul>
<li><strong>애플리케이션 코어(도메인 모델) 중심</strong>: 어니언 아키텍처 역시 시스템의 가장 중심부에 애플리케이션 코어(도메인 모델, 도메인 서비스)를 위치시킵니다.</li>
<li><strong>인터페이스를 통한 외부 의존성 분리</strong>: 외부 의존성(UI, 인프라스트럭처, 테스트 등)은 이 코어를 둘러싼 외부 계층에 위치하며, 내부 계층은 외부 계층에 직접 의존하지 않습니다.</li>
<li><strong>의존성 역전 원칙 적용</strong>: 모든 의존성은 외부 계층에서 내부 계층을 향하도록, 즉 의존성 역전 원칙을 엄격하게 따릅니다.18 내부 계층은 인터페이스를 정의하고, 외부 계층이 이를 구현하는 방식입니다.</li>
</ul>
<p>결론적으로 헥사고널 아키텍처, 클린 아키텍처, 어니언 아키텍처는 모두 “도메인 중심, 의존성 역전, 외부 관심사 분리”라는 핵심 철학을 공유합니다. 각 아키텍처가 사용하는 시각적 메타포(육각형, 동심원, 양파 껍질)나 세부적인 계층 구분 방식에는 약간의 차이가 있을 수 있지만, 근본적으로 지향하는 바는 매우 유사합니다.16 따라서 개발자는 특정 명칭이나 다이어그램의 형태에 얽매이기보다는, 이들 아키텍처가 공통적으로 강조하는 핵심 원칙들을 깊이 이해하고 자신의 프로젝트 상황에 맞게 적용하는 것이 더욱 중요합니다.</p>
<h2 id="vii-헥사고널-아키텍처-실제-적용-가이드">VII. 헥사고널 아키텍처 실제 적용 가이드<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#vii-헥사고널-아키텍처-실제-적용-가이드" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>헥사고널 아키텍처의 개념을 이해했다면, 이제 실제 프로젝트에 어떻게 적용할 수 있을지에 대한 구체적인 가이드가 필요합니다. 여기서는 패키지 구조화 전략과 Java 및 Spring 프레임워크를 활용한 간단한 구현 예시, 그리고 도메인 모델과 DTO 간의 매핑 전략에 대해 살펴보겠습니다.</p>
<h3 id="헥사고널-아키텍처-패키지-구조화-전략">헥사고널 아키텍처 패키지 구조화 전략<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#헥사고널-아키텍처-패키지-구조화-전략" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>헥사고널 아키텍처를 코드 레벨에서 구현할 때, 패키지 구조는 아키텍처의 원칙을 반영하고 강제하는 중요한 역할을 합니다. 일반적으로 다음과 같은 기준으로 패키지를 구성할 수 있습니다 21:</p>
<ul>
<li><strong>도메인 (Domain) / 코어 (Core)</strong>: 애플리케이션의 핵심 비즈니스 로직을 담습니다. 순수한 도메인 엔티티, 값 객체(Value Objects), 도메인 서비스 인터페이스 및 구현체 (필요시) 등이 위치합니다. 이 패키지는 다른 어떤 기술적인 패키지에도 의존하지 않아야 합니다.</li>
<li><strong>애플리케이션 (Application)</strong>: 유스케이스(Use Cases) 또는 애플리케이션 서비스를 정의하고 구현합니다. 인바운드 포트(Inbound Ports) 인터페이스와 그 구현체가 여기에 해당하며, 아웃바운드 포트(Outbound Ports) 인터페이스도 이 패키지 내에 정의될 수 있습니다. 이 계층은 도메인 계층에 의존하여 비즈니스 로직을 오케스트레이션합니다.</li>
<li><strong>어댑터 (Adapter) / 인프라스트럭처 (Infrastructure)</strong>: 외부 세계와의 실제 연동을 담당하는 어댑터 구현체들이 위치합니다.
<ul>
<li><strong>인바운드 어댑터 (Inbound/Driving Adapters)</strong>: 외부로부터의 요청을 받아 애플리케이션 계층의 인바운드 포트를 호출합니다. 예: 웹 컨트롤러(Spring MVC), 메시지 리스너.</li>
<li><strong>아웃바운드 어댑터 (Outbound/Driven Adapters)</strong>: 애플리케이션 계층에서 정의한 아웃바운드 포트 인터페이스를 구현하여 실제 외부 시스템(DB, 외부 API 등)과의 통신을 처리합니다. 예: JPA 리포지토리 구현체, REST API 클라이언트 구현체.</li>
</ul>
</li>
<li><strong>(선택적) 인프라스트럭처 (Infrastructure)</strong>: 위의 어댑터 패키지에 포함될 수도 있지만, 별도로 분리하여 애플리케이션 전반의 설정, 공통 유틸리티, 프레임워크 관련 설정 등을 관리할 수 있습니다.21</li>
</ul>
<p>다음은 일반적인 Java/Spring 프로젝트에서의 예시 패키지 구조입니다:</p>
<pre><code>com.example.service
└── user                     // 특정 도메인 (예: 사용자)
    ├── domain               // 도메인 계층: 순수 비즈니스 로직
    │   ├── model            //   User 엔티티, 값 객체 등
    │   └── service          //   (선택적) 도메인 서비스 인터페이스 및 구현
    ├── application          // 애플리케이션 계층: 유스케이스, 포트 정의
    │   ├── port             //   포트 인터페이스 정의
    │   │   ├── in           //     인바운드 포트 (예: CreateUserUseCase, GetUserQuery)
    │   │   └── out          //     아웃바운드 포트 (예: SaveUserPort, LoadUserPort, NotifyUserPort)
    │   └── service          //   인바운드 포트 구현체 (애플리케이션 서비스)
    ├── adapter              // 어댑터 계층: 외부 연동 구현
    │   ├── in               //   주도 어댑터 (Driving Adapters)
    │   │   └── web          //     예: UserController (Spring MVC)
    │   ├── out              //   피주도 어댑터 (Driven Adapters)
    │   │   ├── persistence  //     예: UserPersistenceAdapter (JPA Repository 구현)
    │   │   └── notification //     예: EmailNotificationAdapter (이메일 발송 구현)
    └── infrastructure       // (선택적) 설정, DI 구성, 공통 유틸리티 등
</code></pre>
<p>이러한 패키지 구조화의 핵심은 <strong>의존성 방향</strong>을 명확히 하는 것입니다. 의존성은 항상 외부(어댑터)에서 내부(애플리케이션 또는 도메인)를 향해야 합니다. 즉, <code>adapter</code> 패키지는 <code>application</code> 패키지(특히 포트 인터페이스)에 의존할 수 있고, <code>application</code> 패키지는 <code>domain</code> 패키지에 의존할 수 있습니다. 그러나 <code>domain</code> 패키지는 <code>application</code>이나 <code>adapter</code> 패키지에 절대 의존해서는 안 됩니다. 마찬가지로 <code>application</code> 패키지도 <code>adapter</code> 패키지에 의존해서는 안 됩니다 (단, <code>application</code>이 정의한 아웃바운드 포트를 <code>adapter</code>가 구현하는 경우는 의존성 역전에 해당).</p>
<p>잘 설계된 패키지 구조는 단순히 파일을 정리하는 것을 넘어, 헥사고널 아키텍처의 핵심 원칙인 관심사 분리와 의존성 역전을 코드 수준에서 강제하고 시각화하는 역할을 합니다. 이는 개발자가 아키텍처를 올바르게 이해하고 따르도록 유도하며, 코드의 응집도(cohesion)를 높이고 결합도(coupling)를 낮추는 데 기여합니다. ArchUnit과 같은 도구를 사용하면 이러한 패키지 간 의존성 규칙이 잘 지켜지고 있는지 자동으로 검증할 수도 있습니다.21</p>
<h3 id="java-및-spring을-활용한-간단한-어댑터-구현-예시">Java 및 Spring을 활용한 간단한 어댑터 구현 예시<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#java-및-spring을-활용한-간단한-어댑터-구현-예시" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>헥사고널 아키텍처의 개념을 구체적으로 이해하는 데 도움을 주기 위해, Java와 Spring 프레임워크를 사용한 간단한 코드 예시를 살펴보겠습니다. 이 예시들은 핵심 아이디어를 전달하는 데 초점을 맞추며, 모든 상황에 적용되는 유일한 정답은 아님을 유념해주시기 바랍니다.10 중요한 것은 포트와 어댑터의 역할, 그리고 의존성 방향의 원칙을 이해하고 프로젝트의 특성에 맞게 적용하는 것입니다.</p>
<h4 id="1-인바운드-포트-구현">1. 인바운드 포트 구현<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#1-인바운드-포트-구현" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>인바운드 포트는 애플리케이션이 외부(주도 어댑터)에 제공하는 기능의 명세입니다. 주로 유스케이스 인터페이스 형태로 정의됩니다.</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="java" data-theme="github-light github-dark"><code data-language="java" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// src/main/java/com/example/user/application/port/in/CreateUserUseCase.java</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> com.example.user.application.port.in;</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> com.example.user.domain.model.User; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 도메인 모델 참조</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CreateUserUseCase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    User </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createUser</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(CreateUserCommand </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">command</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Command 객체 사용</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Command 객체 (데이터 전달용)</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// src/main/java/com/example/user/application/port/in/CreateUserCommand.java</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> com.example.user.application.port.in;</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CreateUserCommand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> final</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String name;</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> final</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String email;</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CreateUserCommand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, String </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">email</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span data-line><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name;</span></span>
<span data-line><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.email </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> email;</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name; }</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getEmail</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> email; }</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></figure>
<p>애플리케이션 서비스는 이 인바운드 포트를 구현하며, 필요한 아웃바운드 포트를 통해 외부 기능(예: 데이터 저장)을 사용합니다.</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="java" data-theme="github-light github-dark"><code data-language="java" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// src/main/java/com/example/user/application/service/CreateUserService.java</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> com.example.user.application.service;</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> com.example.user.application.port.in.CreateUserCommand;</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> com.example.user.application.port.in.CreateUserUseCase;</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> com.example.user.application.port.out.SaveUserPort; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 아웃바운드 포트</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> com.example.user.domain.model.User;</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> org.springframework.stereotype.Service; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Spring의 @Service 사용 가능</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> org.springframework.transaction.annotation.Transactional; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Spring의 @Transactional 사용 가능</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Service</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Spring 컴포넌트로 등록</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CreateUserService</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CreateUserUseCase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> final</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SaveUserPort saveUserPort; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 아웃바운드 포트 의존성 주입</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CreateUserService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(SaveUserPort </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">saveUserPort</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span data-line><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.saveUserPort </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> saveUserPort;</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Transactional</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 트랜잭션 관리 (Spring AOP 활용)</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> User </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createUser</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(CreateUserCommand </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">command</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 1. Command 객체로부터 도메인 객체 생성</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        User newUser </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, command.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), command.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getEmail</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ID는 생성 시 null</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 2. (필요시) 비즈니스 유효성 검사 또는 도메인 로직 수행</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 예: newUser.validate();</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 3. 아웃바운드 포트를 통해 도메인 객체 저장 요청</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        User savedUser </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> saveUserPort.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">saveUser</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newUser);</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 4. (필요시) 이벤트 발행 등 추가 작업</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 예: userEventPublisherPort.publishUserCreatedEvent(savedUser);</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> savedUser;</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></figure>
<h4 id="2-아웃바운드-포트-구현">2. 아웃바운드 포트 구현<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#2-아웃바운드-포트-구현" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>아웃바운드 포트는 애플리케이션 코어가 외부 시스템(예: 데이터베이스)에 요청하는 기능의 명세입니다. 리포지토리 인터페이스가 대표적입니다.</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="java" data-theme="github-light github-dark"><code data-language="java" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// src/main/java/com/example/user/application/port/out/SaveUserPort.java</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> com.example.user.application.port.out;</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> com.example.user.domain.model.User;</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SaveUserPort</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    User </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">saveUser</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(User </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">user</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></figure>
<p>영속성 어댑터는 이 아웃바운드 포트를 구현하여 실제 데이터베이스 연동을 처리합니다. Spring Data JPA를 사용하는 예시입니다.</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="java" data-theme="github-light github-dark"><code data-language="java" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// src/main/java/com/example/user/adapter/out/persistence/UserPersistenceAdapter.java</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> com.example.user.adapter.out.persistence;</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> com.example.user.application.port.out.SaveUserPort;</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> com.example.user.domain.model.User;</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> org.springframework.stereotype.Repository; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Spring의 @Repository 사용 가능</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lombok.RequiredArgsConstructor; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Lombok 사용 예시</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// JPA Entity (별도 파일에 정의)</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// package com.example.user.adapter.out.persistence;</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// import javax.persistence.*;</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// @Entity @Table(name = &quot;users&quot;)</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// public class UserJpaEntity { /*... 필드, 생성자, getter... */ }</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// JPA Repository Interface (Spring Data JPA, 별도 파일에 정의)</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// package com.example.user.adapter.out.persistence;</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// import org.springframework.data.jpa.repository.JpaRepository;</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// public interface UserJpaRepository extends JpaRepository&lt;UserJpaEntity, Long> {}</span></span>
<span data-line> </span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Repository</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Spring 컴포넌트로 등록</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RequiredArgsConstructor</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Lombok: final 필드에 대한 생성자 자동 생성</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UserPersistenceAdapter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SaveUserPort</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> final</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UserJpaRepository userJpaRepository; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Spring Data JPA Repository 주입</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // private final UserMapper userMapper; // 도메인-엔티티 매퍼 (선택적)</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> User </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">saveUser</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(User </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">user</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 1. 도메인 모델 User 객체를 JPA 엔티티 UserJpaEntity 객체로 변환</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //    (여기서는 UserMapper를 사용한다고 가정하거나, 직접 변환 로직 작성)</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        UserJpaEntity userEntity </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mapDomainToJpaEntity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(user); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 예시 매핑 메서드</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 2. JPA Repository를 사용하여 엔티티 저장</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        UserJpaEntity savedEntity </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> userJpaRepository.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">save</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(userEntity);</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 3. 저장된 JPA 엔티티를 다시 도메인 모델 User 객체로 변환하여 반환</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mapJpaEntityToDomain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(savedEntity); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 예시 매핑 메서드</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 예시 매핑 메서드 (실제로는 UserMapper 클래스 등으로 분리하는 것이 좋음)</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UserJpaEntity </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mapDomainToJpaEntity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(User </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">user</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // User -> UserJpaEntity 변환 로직</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // return new UserJpaEntity(user.getId(), user.getName(), user.getEmail());</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Mapping Domain to JPA Entity for: &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> user.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 임시 구현</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        UserJpaEntity entity </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UserJpaEntity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        entity.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(user.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        entity.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(user.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        entity.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setEmail</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(user.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getEmail</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> entity;</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> User </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mapJpaEntityToDomain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(UserJpaEntity </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">entity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // UserJpaEntity -> User 변환 로직</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // return new User(entity.getId(), entity.getName(), entity.getEmail());</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Mapping JPA Entity to Domain for ID: &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> entity.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(entity.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), entity.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), entity.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getEmail</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// UserJpaEntity와 UserJpaRepository는 설명을 위해 주석 처리된 형태로 포함했습니다.</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 실제 프로젝트에서는 각자의 파일에 정의되어야 합니다.</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// UserJpaEntity.java</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// package com.example.user.adapter.out.persistence;</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// import javax.persistence.*;</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// import lombok.AllArgsConstructor;</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// import lombok.Data;</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// import lombok.NoArgsConstructor;</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// @Entity</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// @Table(name = &quot;users&quot;)</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// @Data</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// @NoArgsConstructor</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// @AllArgsConstructor</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// public class UserJpaEntity {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//    private Long id;</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//    private String name;</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//    private String email;</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// }</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// UserJpaRepository.java</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// package com.example.user.adapter.out.persistence;</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// import org.springframework.data.jpa.repository.JpaRepository;</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// public interface UserJpaRepository extends JpaRepository&lt;UserJpaEntity, Long> {}</span></span></code></pre></figure>
<h4 id="3-인바운드-어댑터-예시-controller">3. 인바운드 어댑터 예시 (Controller)<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#3-인바운드-어댑터-예시-controller" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>인바운드 어댑터는 외부(예: 웹)로부터의 요청을 받아 인바운드 포트를 호출합니다. Spring MVC 컨트롤러 예시입니다.</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="java" data-theme="github-light github-dark"><code data-language="java" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// src/main/java/com/example/user/adapter/in/web/UserController.java</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> com.example.user.adapter.in.web;</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> com.example.user.application.port.in.CreateUserCommand;</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> com.example.user.application.port.in.CreateUserUseCase;</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> com.example.user.domain.model.User;</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> org.springframework.http.ResponseEntity;</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> org.springframework.web.bind.annotation.PostMapping;</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> org.springframework.web.bind.annotation.RequestBody;</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> org.springframework.web.bind.annotation.RequestMapping;</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> org.springframework.web.bind.annotation.RestController;</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lombok.RequiredArgsConstructor;</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 요청 DTO (별도 파일에 정의)</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// package com.example.user.adapter.in.web;</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// public class UserRegistrationRequest { /*... 필드, 생성자, getter... */ }</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RestController</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RequestMapping</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/api/users&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RequiredArgsConstructor</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UserController</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> final</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> CreateUserUseCase createUserUseCase; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 인바운드 포트(유스케이스) 주입</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">PostMapping</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ResponseEntity&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">UserResponse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">> </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">registerUser</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RequestBody</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UserRegistrationRequest </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">request</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 1. 웹 요청 DTO(UserRegistrationRequest)를 애플리케이션 계층의 Command 객체로 변환</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        CreateUserCommand command </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CreateUserCommand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(request.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), request.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getEmail</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 2. 인바운드 포트(유스케이스) 호출</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        User createdUser </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> createUserUseCase.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createUser</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(command);</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 3. 결과(도메인 객체)를 웹 응답 DTO(UserResponse)로 변환하여 반환</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        UserResponse response </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UserResponse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(createdUser.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), createdUser.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), createdUser.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getEmail</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ResponseEntity.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ok</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(response);</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 요청 DTO (UserRegistrationRequest.java)</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// package com.example.user.adapter.in.web;</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// import lombok.Data;</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// @Data</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// public class UserRegistrationRequest {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//    private String name;</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//    private String email;</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// }</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 응답 DTO (UserResponse.java)</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// package com.example.user.adapter.in.web;</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// import lombok.AllArgsConstructor;</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// import lombok.Data;</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// @Data</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// @AllArgsConstructor</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// public class UserResponse {</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//    private Long id;</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//    private String name;</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//    private String email;</span></span>
<span data-line><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// }</span></span></code></pre></figure>
<p>위 코드 예시들은 헥사고널 아키텍처의 주요 구성 요소들이 어떻게 상호작용하는지 보여줍니다. <code>UserController</code>(인바운드 어댑터)는 <code>CreateUserUseCase</code>(인바운드 포트)에 의존하고, <code>CreateUserService</code>(인바운드 포트 구현체)는 <code>SaveUserPort</code>(아웃바운드 포트)에 의존하며, <code>UserPersistenceAdapter</code>(아웃바운드 어댑터)가 <code>SaveUserPort</code>를 구현합니다. 이를 통해 관심사가 분리되고 의존성 역전이 이루어짐을 알 수 있습니다. 실제 프로젝트에서는 예외 처리, 상세한 유효성 검사, 매퍼 클래스 분리 등이 추가로 고려되어야 합니다.</p>
<h3 id="모델-간-변환">모델 간 변환<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#모델-간-변환" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>헥사고널 아키텍처에서는 각 계층이 자신만의 데이터 표현 방식을 가질 수 있기 때문에, 계층 간 데이터 전달 시 모델 간 변환(매핑)이 필요합니다.13</p>
<ul>
<li>
<p><strong>필요성</strong>:</p>
<ul>
<li><strong>애플리케이션 코어의 도메인 모델</strong>: 비즈니스 규칙과 상태를 표현하는 데 최적화되어 있으며, 풍부한 행위(behavior)를 가질 수 있습니다.</li>
<li><strong>인바운드 어댑터 (예: 웹 컨트롤러)</strong>: 외부 클라이언트와의 통신을 위한]를 사용합니다. DTO는 주로 데이터 전달에 목적을 두며, API 명세(contract)를 나타냅니다.</li>
<li><strong>아웃바운드 어댑터 (예: 영속성 어댑터)</strong>: 데이터베이스 스키마에 맞춰진 엔티티(Entity) 객체를 사용하거나, 외부 API가 요구하는 형식의 데이터를 사용합니다.</li>
</ul>
</li>
<li>
<p><strong>매핑 위치</strong>:</p>
<ul>
<li><strong>인바운드 어댑터</strong>: 외부로부터 받은 요청 DTO를 애플리케이션 코어가 이해할 수 있는 커맨드(Command) 객체나 도메인 모델로 변환합니다. 또한, 애플리케이션 코어로부터 받은 결과(도메인 모델)를 응답 DTO로 변환하여 외부로 전달합니다.</li>
<li><strong>아웃바운드 어댑터</strong>: 애플리케이션 코어로부터 전달받은 도메인 모델을 외부 시스템(예: 데이터베이스 엔티티, 외부 API 요청 DTO)에 맞는 형태로 변환합니다. 반대로, 외부 시스템으로부터 받은 데이터를 도메인 모델로 변환하여 애플리케이션 코어에 전달합니다.</li>
</ul>
</li>
<li>
<p><strong>매핑 방법</strong>:</p>
<ul>
<li><strong>수동 매핑</strong>: 생성자, 정적 팩토리 메서드, 빌더 패턴 등을 사용하여 개발자가 직접 매핑 코드를 작성합니다. 모델이 단순하거나 특정 로직이 필요한 경우 유용하지만, 모델이 복잡해지면 반복적이고 오류 발생 가능성이 높은 코드가 많아질 수 있습니다.</li>
<li><strong>매퍼 라이브러리 사용</strong>: MapStruct, ModelMapper와 같은 라이브러리를 사용하면 반복적인 매핑 코드를 크게 줄일 수 있습니다. 어노테이션 기반으로 매핑 규칙을 정의하거나, 규칙 기반으로 자동 매핑을 지원하여 개발 생산성을 높일 수 있습니다.</li>
</ul>
</li>
</ul>
<p>도메인 모델과 외부 모델(DTO, 엔티티) 간의 매핑은 단순한 데이터 복사를 넘어, 일종의 안티코럽션 계층 (Anti-Corruption Layer) 역할을 수행합니다. 이를 통해 외부 시스템의 모델 변경(예: API 응답 필드 변경, 데이터베이스 컬럼 추가)이 애플리케이션 코어의 도메인 모델에 직접적인 영향을 미치는 것을 방지하고, 도메인 모델의 순수성과 안정성을 유지할 수 있습니다.17 DTO는 API 계약의 안정성을, 엔티티는 데이터베이스 스키마와의 정합성을 보장하는 등 각 모델이 자신의 책임 영역에 집중할 수 있도록 돕는 중요한 과정입니다.</p>
<h2 id="viii-마무리-헥사고널-아키텍처-언제-선택해야-할까요">VIII. 마무리: 헥사고널 아키텍처, 언제 선택해야 할까요?<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#viii-마무리-헥사고널-아키텍처-언제-선택해야-할까요" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>헥사고널 아키텍처는 많은 장점을 제공하지만, 모든 프로젝트에 적합한 만능 해결책은 아닙니다. 이 아키텍처를 선택할지 여부는 프로젝트의 특성, 팀의 역량, 그리고 장기적인 목표를 신중하게 고려하여 결정해야 합니다.</p>
<h3 id="적합한-프로젝트-유형">적합한 프로젝트 유형<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#적합한-프로젝트-유형" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>다음과 같은 특징을 가진 프로젝트에서 헥사고널 아키텍처의 도입을 고려해볼 수 있습니다:</p>
<ul>
<li><strong>장기적으로 유지보수하고 발전시켜야 하는 복잡한 비즈니스 로직을 가진 애플리케이션</strong>: 핵심 비즈니스 로직이 안정적이고 복잡하며, 기술 변화로부터 이를 보호해야 할 필요성이 클 때 유리합니다.2</li>
<li><strong>다양한 종류의 클라이언트가 동일한 핵심 로직을 사용해야 하는 경우</strong>: 예를 들어, 웹 UI, 모바일 앱, 배치 작업, 외부 시스템 API 등 여러 경로로 동일한 비즈니스 기능을 제공해야 할 때, 코어 로직을 재사용하며 각 클라이언트에 맞는 어댑터만 개발할 수 있습니다.15</li>
<li><strong>UI나 데이터베이스와 같은 외부 기술 요소를 주기적으로 변경하거나 현대화해야 할 가능성이 높은 시스템</strong>: 기술 스택의 변화에 유연하게 대응하고, 특정 기술에 대한 종속성을 줄이고자 할 때 효과적입니다.15</li>
<li><strong>애플리케이션이 여러 입력 제공자(input providers)와 출력 소비자(output consumers)를 가져야 하고, 이로 인해 로직 커스터마이징이 복잡해질 수 있는 경우</strong>: 다양한 외부 시스템과의 연동이 많고, 각 연동 방식이 다를 때 포트와 어댑터 구조가 유용할 수 있습니다.15</li>
<li><strong>높은 테스트 커버리지가 요구되고, 비즈니스 로직의 독립적인 테스트가 중요한 프로젝트</strong>: 테스트 용이성을 극대화하여 소프트웨어 품질을 높이고자 할 때 강력한 선택지가 될 수 있습니다.8</li>
<li><strong><a href="./마이크로서비스-아키텍처(Microservice-Architecture)" class="internal alias" data-slug="마이크로서비스-아키텍처(Microservice-Architecture)">마이크로서비스 아키텍처(Microservice Architecture)</a>에서 각 서비스의 내부 아키텍처</strong>: 각 마이크로서비스가 독립적으로 개발, 배포, 확장될 수 있도록 내부적으로 견고하고 유연한 구조를 갖추는 데 적합할 수 있습니다.4</li>
</ul>
<h3 id="팀의-준비도-및-고려사항">팀의 준비도 및 고려사항<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#팀의-준비도-및-고려사항" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>헥사고널 아키텍처를 성공적으로 도입하기 위해서는 다음과 같은 팀의 준비도와 고려사항을 점검해야 합니다:</p>
<ul>
<li><strong>팀의 이해도 및 역량</strong>: 팀원들이 헥사고널 아키텍처의 기본 개념, 특히 포트, 어댑터, 의존성 역전 원칙 등을 충분히 이해하고 실제 코드에 적용할 수 있는 역량을 갖추었는지 평가해야 합니다.8 초기 학습 곡선이 있을 수 있음을 인지하고, 필요한 교육이나 스터디를 진행하는 것이 좋습니다.</li>
<li><strong>초기 설계 및 구현 노력</strong>: 헥사고널 아키텍처는 전통적인 계층형 아키텍처에 비해 초기 설계 및 구현에 추가적인 시간과 노력이 투입될 수 있습니다.8 포트와 어댑터의 경계를 명확히 하고, 모델 간 매핑 로직을 작성하는 등의 작업이 필요합니다.</li>
<li><strong>과도한 엔지니어링 방지</strong>: 프로젝트의 규모나 복잡도에 비해 헥사고널 아키텍처가 과도한 엔지니어링이 되지 않도록 주의해야 합니다.14 단순한 프로젝트에는 더 가벼운 아키텍처가 적합할 수 있습니다.</li>
</ul>
<h3 id="최종-조언">최종 조언<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#최종-조언" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>헥사고널 아키텍처는 애플리케이션의 핵심 비즈니스 로직을 보호하고, 변화에 유연하게 대응하며, 테스트 가능한 시스템을 만드는 데 매우 강력한 도구입니다. 하지만 그 이면에는 학습 곡선, 잠재적인 복잡성 증가와 같은 고려사항도 존재합니다.</p>
<p>따라서 헥사고널 아키텍처 도입은 단기적인 개발 속도 향상보다는 장기적인 시스템의 건강성, 유지보수성, 그리고 적응성에 대한 투자로 보아야 합니다. “이 프로젝트에 헥사고널 아키텍처가 정말로 필요한가? 그로 인해 얻는 이점이 투입되는 노력과 복잡성을 상쇄하는가?”라는 질문을 스스로에게 던지고, 프로젝트의 특성과 목표에 부합하는지 신중하게 판단하는 것이 중요합니다. 이는 단순히 기술적인 결정을 넘어, 비즈니스의 지속 가능성과 성공에 영향을 미치는 전략적인 선택이 될 수 있습니다.</p>
<p>궁극적으로 아키텍처 선택의 목표는 현재와 미래의 요구사항을 가장 효과적으로 만족시키는 견고하고 지속 가능한 시스템을 구축하는 것임을 기억해야 합니다.</p>
<h2 id="ix-참고-자료">IX. 참고 자료<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#ix-참고-자료" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<ul>
<li>Alistair Cockburn, “Hexagonal Architecture” (Original article): <a href="https://alistair.cockburn.us/hexagonal-architecture/" class="external">https://alistair.cockburn.us/hexagonal-architecture/<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> 5</li>
<li>Alistair Cockburn, Interview on Hexagonal Architecture history: <a href="https://jmgarridopaz.github.io/content/interviewalistair.html" class="external">https://jmgarridopaz.github.io/content/interviewalistair.html<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> 6</li>
<li>AWS Prescriptive Guidance - Hexagonal Architecture Pattern: <a href="https://docs.aws.amazon.com/prescriptive-guidance/latest/cloud-design-patterns/hexagonal-architecture.html" class="external">https://docs.aws.amazon.com/prescriptive-guidance/latest/cloud-design-patterns/hexagonal-architecture.html<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> 1</li>
<li>Wikipedia - Hexagonal architecture (software): <a href="https://en.wikipedia.org/wiki/Hexagonal_architecture_(software)" class="external">https://en.wikipedia.org/wiki/Hexagonal_architecture_(software)<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> 7</li>
<li>Ambitious Solutions - Hexagonal vs Traditional Architecture: <a href="https://ambitioussolutions.mk/blog/hexagonal-vs-traditional-architecture/" class="external">https://ambitioussolutions.mk/blog/hexagonal-vs-traditional-architecture/<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> 8</li>
<li>CardoAI - Hexagonal Architecture: What is it and why should you use it?: <a href="https://cardoai.com/hexagonal-architecture-what-is-it-and-why-should-you-use-it/" class="external">https://cardoai.com/hexagonal-architecture-what-is-it-and-why-should-you-use-it/<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> 13</li>
<li>Aalpha NET - Hexagonal Architecture: <a href="https://www.aalpha.net/blog/hexagonal-architecture/" class="external">https://www.aalpha.net/blog/hexagonal-architecture/<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> 14</li>
<li>Scalastic.io - Hexagonal Architecture: <a href="https://scalastic.io/en/hexagonal-architecture/" class="external">https://scalastic.io/en/hexagonal-architecture/<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> 2</li>
<li>GeeksforGeeks - Hexagonal Architecture System Design: <a href="https://www.geeksforgeeks.org/hexagonal-architecture-system-design/" class="external">https://www.geeksforgeeks.org/hexagonal-architecture-system-design/<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> 3</li>
<li>Apiumhub - Clean and Hexagonal Architecture: <a href="https://apiumhub.com/tech-blog-barcelona/clean-and-hexagonal-architecture/" class="external">https://apiumhub.com/tech-blog-barcelona/clean-and-hexagonal-architecture/<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> 19</li>
<li>(GitHub Example) naspredam/rest-spring-boot-hexagonal-architecture: <a href="https://github.com/naspredam/rest-spring-boot-hexagonal-architecture" class="external">https://github.com/naspredam/rest-spring-boot-hexagonal-architecture<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> 21</li>
<li>(GitHub Example) MartinCastroAlvarez/hexagonal-spring-boot: <a href="https://github.com/MartinCastroAlvarez/hexagonal-spring-boot" class="external">https://github.com/MartinCastroAlvarez/hexagonal-spring-boot<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> 22</li>
<li>Curate Partners - Understanding Hexagonal Architecture: <a href="https://curatepartners.com/blogs/skills-tools-platforms/understanding-hexagonal-architecture-ports-and-adapters-for-modern-software-solutions/" class="external">https://curatepartners.com/blogs/skills-tools-platforms/understanding-hexagonal-architecture-ports-and-adapters-for-modern-software-solutions/<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> 4</li>
<li>Adyog Blog - Understanding Hexagonal Architecture: <a href="https://blog.adyog.com/2023/10/03/understanding-hexagonal-architecture-a-comprehensive-guide/" class="external">https://blog.adyog.com/2023/10/03/understanding-hexagonal-architecture-a-comprehensive-guide/<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> 12</li>
<li>Dev.to - Hexagonal Architecture or Port &amp; Adapters (Jhonny Faber): <a href="https://dev.to/jhonifaber/hexagonal-architecture-or-port-adapters-23ed" class="external">https://dev.to/jhonifaber/hexagonal-architecture-or-port-adapters-23ed<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> 11</li>
<li>GeeksforGeeks - Hexagonal Architecture in Java: <a href="https://www.geeksforgeeks.org/hexagonal-architecture-in-java/" class="external">https://www.geeksforgeeks.org/hexagonal-architecture-in-java/<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> 10</li>
<li>Scalastic.io - Hexagonal Architecture Domain: <a href="https://scalastic.io/en/hexagonal-architecture-domain/" class="external">https://scalastic.io/en/hexagonal-architecture-domain/<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> 23</li>
<li>Dev.to - Hexagonal Architecture (akdevblog): <a href="https://dev.to/akdevblog/hexagonal-architecture-1a0d" class="external">https://dev.to/akdevblog/hexagonal-architecture-1a0d<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> 9</li>
<li>JHUMELSINE Blog - Hexagonal Architecture Introduction: <a href="https://jhumelsine.github.io/2023/10/24/hexagonal-architecture-introduction.html" class="external">https://jhumelsine.github.io/2023/10/24/hexagonal-architecture-introduction.html<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> 16</li>
<li>Dev3lop.com - Hexagonal Architecture for Data Platforms: <a href="https://dev3lop.com/hexagonal-architecture-for-data-platforms-ports-and-adapters/" class="external">https://dev3lop.com/hexagonal-architecture-for-data-platforms-ports-and-adapters/<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> 25</li>
</ul></article><hr/><div class="page-footer"><div class="recent-notes"><h3>최근 게시글</h3><ul class="recent-ul"><li class="recent-li"><div class="section"><div class="desc"><h3><a href="./GraphQL의-배신-1분-타임아웃을-6초로-단축시킨-엑셀-다운로드-성능-개선기" class="internal">GraphQL의 배신? 1분 타임아웃을 6초로 단축시킨 엑셀 다운로드 성능 개선기</a></h3></div><p class="meta"><time datetime="2025-08-25T01:18:57.000Z">2025년 8월 25일</time></p><ul class="tags"></ul></div></li><li class="recent-li"><div class="section"><div class="desc"><h3><a href="./Rust" class="internal">Rust</a></h3></div><p class="meta"><time datetime="2025-08-25T01:18:57.000Z">2025년 8월 25일</time></p><ul class="tags"></ul></div></li><li class="recent-li"><div class="section"><div class="desc"><h3><a href="./Hibernate에서-Cascade=&quot;all-delete-orphan&quot;-오류-해결하기" class="internal">Hibernate에서 Cascade=&quot;all-delete-orphan&quot; 오류 해결하기</a></h3></div><p class="meta"><time datetime="2025-08-14T02:22:38.000Z">2025년 8월 14일</time></p><ul class="tags"></ul></div></li><li class="recent-li"><div class="section"><div class="desc"><h3><a href="./생성형-AI-활용으로-인한-인지-능력-저하" class="internal">생성형 AI 활용으로 인한 인지 능력 저하</a></h3></div><p class="meta"><time datetime="2025-08-14T02:22:38.000Z">2025년 8월 14일</time></p><ul class="tags"></ul></div></li><li class="recent-li"><div class="section"><div class="desc"><h3><a href="./생성형-AI의-활용" class="internal">생성형 AI의 활용</a></h3></div><p class="meta"><time datetime="2025-07-18T01:07:06.000Z">2025년 7월 18일</time></p><ul class="tags"></ul></div></li></ul></div></div></div><div class="right sidebar"><div class="graph"><h3>그래프 뷰</h3><div class="graph-outer"><div id="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:2,&quot;scale&quot;:1.5,&quot;repelForce&quot;:1,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:50,&quot;fontSize&quot;:2,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:false,&quot;enableRadial&quot;:false}"></div><button id="global-graph-icon" aria-label="Global Graph"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xml:space="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
                s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
                c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
                C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
                c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
                v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
                s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
                C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
                S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
                s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
                s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></button></div><div id="global-graph-outer"><div id="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:1,&quot;repelForce&quot;:20,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:300,&quot;fontSize&quot;:1.5,&quot;opacityScale&quot;:1,&quot;showTags&quot;:false,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:true,&quot;enableRadial&quot;:true}"></div></div></div><div class="toc desktop-only"><button type="button" id="toc" class aria-controls="toc-content" aria-expanded="true"><h3>목차</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="toc-content" class><ul class="overflow"><li class="depth-0"><a href="#i-들어가며-헥사고널-아키텍처란-무엇인가" data-for="i-들어가며-헥사고널-아키텍처란-무엇인가">I. 들어가며: 헥사고널 아키텍처란 무엇인가?</a></li><li class="depth-0"><a href="#ii-헥사고널-아키텍처의-탄생-배경과-핵심-구성-요소" data-for="ii-헥사고널-아키텍처의-탄생-배경과-핵심-구성-요소">II. 헥사고널 아키텍처의 탄생 배경과 핵심 구성 요소</a></li><li class="depth-1"><a href="#앨리스터-콕번이-헥사고널-아키텍처를-제안한-이유" data-for="앨리스터-콕번이-헥사고널-아키텍처를-제안한-이유">앨리스터 콕번이 헥사고널 아키텍처를 제안한 이유</a></li><li class="depth-1"><a href="#헥사고널hexagonal이라는-이름의-유래" data-for="헥사고널hexagonal이라는-이름의-유래">”헥사고널(Hexagonal)“이라는 이름의 유래</a></li><li class="depth-1"><a href="#핵심-구성-요소-포트ports와-어댑터adapters" data-for="핵심-구성-요소-포트ports와-어댑터adapters">핵심 구성 요소: 포트(Ports)와 어댑터(Adapters)</a></li><li class="depth-1"><a href="#의존성-역전-원칙-dependency-inversion-principle과-헥사고널-아키텍처" data-for="의존성-역전-원칙-dependency-inversion-principle과-헥사고널-아키텍처">의존성 역전 원칙 (Dependency Inversion Principle)과 헥사고널 아키텍처</a></li><li class="depth-0"><a href="#iii-헥사고널-아키텍처의-장점" data-for="iii-헥사고널-아키텍처의-장점">III. 헥사고널 아키텍처의 장점</a></li><li class="depth-1"><a href="#향상된-테스트-용이성-improved-testability" data-for="향상된-테스트-용이성-improved-testability">향상된 테스트 용이성 (Improved Testability)</a></li><li class="depth-1"><a href="#유연성-및-확장성-flexibility-and-extensibility" data-for="유연성-및-확장성-flexibility-and-extensibility">유연성 및 확장성 (Flexibility and Extensibility)</a></li><li class="depth-1"><a href="#기술적-변화로부터-비즈니스-로직-보호" data-for="기술적-변화로부터-비즈니스-로직-보호">기술적 변화로부터 비즈니스 로직 보호</a></li><li class="depth-1"><a href="#외부-시스템-교체의-용이성" data-for="외부-시스템-교체의-용이성">외부 시스템 교체의 용이성</a></li><li class="depth-1"><a href="#관심사-분리-separation-of-concerns" data-for="관심사-분리-separation-of-concerns">관심사 분리 (Separation of Concerns)</a></li><li class="depth-1"><a href="#의사결정-지연-deferring-decisions" data-for="의사결정-지연-deferring-decisions">의사결정 지연 (Deferring Decisions)</a></li><li class="depth-0"><a href="#iv-헥사고널-아키텍처의-단점-및-고려사항" data-for="iv-헥사고널-아키텍처의-단점-및-고려사항">IV. 헥사고널 아키텍처의 단점 및 고려사항</a></li><li class="depth-1"><a href="#초기-학습-곡선-steeper-learning-curve" data-for="초기-학습-곡선-steeper-learning-curve">초기 학습 곡선 (Steeper Learning Curve)</a></li><li class="depth-1"><a href="#증가된-코드-복잡성-및-간접-참조-increased-code-complexity-and-indirection" data-for="증가된-코드-복잡성-및-간접-참조-increased-code-complexity-and-indirection">증가된 코드 복잡성 및 간접 참조 (Increased Code Complexity and Indirection)</a></li><li class="depth-1"><a href="#모델-간-번역-오버헤드-translation-overhead-between-models" data-for="모델-간-번역-오버헤드-translation-overhead-between-models">모델 간 번역 오버헤드 (Translation Overhead between models)</a></li><li class="depth-1"><a href="#과도한-엔지니어링-가능성-potential-for-over-engineering-in-simple-projects" data-for="과도한-엔지니어링-가능성-potential-for-over-engineering-in-simple-projects">과도한 엔지니어링 가능성 (Potential for Over-engineering in simple projects)</a></li><li class="depth-1"><a href="#디버깅의-어려움-debugging" data-for="디버깅의-어려움-debugging">디버깅의 어려움 (Debugging)</a></li><li class="depth-0"><a href="#v-헥사고널-아키텍처-vs-계층형-아키텍처layered-architecture" data-for="v-헥사고널-아키텍처-vs-계층형-아키텍처layered-architecture">V. 헥사고널 아키텍처 vs. 계층형 아키텍처(Layered Architecture)</a></li><li class="depth-1"><a href="#전통적인-계층형-아키텍처-소개" data-for="전통적인-계층형-아키텍처-소개">전통적인 계층형 아키텍처 소개</a></li><li class="depth-1"><a href="#주요-차이점-비교" data-for="주요-차이점-비교">주요 차이점 비교</a></li><li class="depth-1"><a href="#표-헥사고널-아키텍처-vs-계층형-아키텍처-비교" data-for="표-헥사고널-아키텍처-vs-계층형-아키텍처-비교">표: 헥사고널 아키텍처 vs. 계층형 아키텍처 비교</a></li><li class="depth-0"><a href="#vi-헥사고널-아키텍처와-다른-아키텍처들" data-for="vi-헥사고널-아키텍처와-다른-아키텍처들">VI. 헥사고널 아키텍처와 다른 아키텍처들</a></li><li class="depth-1"><a href="#클린-아키텍처-clean-architecture와의-관계" data-for="클린-아키텍처-clean-architecture와의-관계">클린 아키텍처 (Clean Architecture)와의 관계</a></li><li class="depth-1"><a href="#어니언-아키텍처-onion-architecture와의-유사점" data-for="어니언-아키텍처-onion-architecture와의-유사점">어니언 아키텍처 (Onion Architecture)와의 유사점</a></li><li class="depth-0"><a href="#vii-헥사고널-아키텍처-실제-적용-가이드" data-for="vii-헥사고널-아키텍처-실제-적용-가이드">VII. 헥사고널 아키텍처 실제 적용 가이드</a></li><li class="depth-1"><a href="#헥사고널-아키텍처-패키지-구조화-전략" data-for="헥사고널-아키텍처-패키지-구조화-전략">헥사고널 아키텍처 패키지 구조화 전략</a></li><li class="depth-1"><a href="#java-및-spring을-활용한-간단한-어댑터-구현-예시" data-for="java-및-spring을-활용한-간단한-어댑터-구현-예시">Java 및 Spring을 활용한 간단한 어댑터 구현 예시</a></li><li class="depth-1"><a href="#모델-간-변환" data-for="모델-간-변환">모델 간 변환</a></li><li class="depth-0"><a href="#viii-마무리-헥사고널-아키텍처-언제-선택해야-할까요" data-for="viii-마무리-헥사고널-아키텍처-언제-선택해야-할까요">VIII. 마무리: 헥사고널 아키텍처, 언제 선택해야 할까요?</a></li><li class="depth-1"><a href="#적합한-프로젝트-유형" data-for="적합한-프로젝트-유형">적합한 프로젝트 유형</a></li><li class="depth-1"><a href="#팀의-준비도-및-고려사항" data-for="팀의-준비도-및-고려사항">팀의 준비도 및 고려사항</a></li><li class="depth-1"><a href="#최종-조언" data-for="최종-조언">최종 조언</a></li><li class="depth-0"><a href="#ix-참고-자료" data-for="ix-참고-자료">IX. 참고 자료</a></li></ul></div></div><div class="backlinks"><h3>백링크</h3><ul class="overflow"><li><a href="./모듈(Module)" class="internal">모듈(Module)</a></li></ul></div></div><footer class><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.4.0</a> © 2025</p><ul><li><a href="https://github.com/jackyzha0/quartz">GitHub</a></li><li><a href="https://discord.gg/cRFFHYye7t">Discord Community</a></li></ul></footer></div></div></body><script type="application/javascript">function c(){let t=this.parentElement;t.classList.toggle("is-collapsed");let l=t.classList.contains("is-collapsed")?this.scrollHeight:t.scrollHeight;t.style.maxHeight=l+"px";let o=t,e=t.parentElement;for(;e;){if(!e.classList.contains("callout"))return;let n=e.classList.contains("is-collapsed")?e.scrollHeight:e.scrollHeight+o.scrollHeight;e.style.maxHeight=n+"px",o=e,e=e.parentElement}}function i(){let t=document.getElementsByClassName("callout is-collapsible");for(let s of t){let l=s.firstElementChild;if(l){l.addEventListener("click",c),window.addCleanup(()=>l.removeEventListener("click",c));let e=s.classList.contains("is-collapsed")?l.scrollHeight:s.scrollHeight;s.style.maxHeight=e+"px"}}}document.addEventListener("nav",i);window.addEventListener("resize",i);
</script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/copy-tex.min.js" type="application/javascript"></script><script type="application/javascript">
        const socket = new WebSocket('ws://localhost:3001')
        // reload(true) ensures resources like images and scripts are fetched again in firefox
        socket.addEventListener('message', () => document.location.reload(true))
      </script><script type="module">function L(c){for(;c.firstChild;)c.removeChild(c.firstChild)}var h=class{constructor(e,t){this.container=e;this.content=t;this.setupEventListeners(),this.setupNavigationControls()}isDragging=!1;startPan={x:0,y:0};currentPan={x:0,y:0};scale=1;MIN_SCALE=.5;MAX_SCALE=3;ZOOM_SENSITIVITY=.001;setupEventListeners(){this.container.addEventListener("mousedown",this.onMouseDown.bind(this)),document.addEventListener("mousemove",this.onMouseMove.bind(this)),document.addEventListener("mouseup",this.onMouseUp.bind(this)),this.container.addEventListener("wheel",this.onWheel.bind(this),{passive:!1}),window.addEventListener("resize",this.resetTransform.bind(this))}setupNavigationControls(){let e=document.createElement("div");e.className="mermaid-controls";let t=this.createButton("+",()=>this.zoom(.1)),n=this.createButton("-",()=>this.zoom(-.1)),s=this.createButton("Reset",()=>this.resetTransform());e.appendChild(n),e.appendChild(s),e.appendChild(t),this.container.appendChild(e)}createButton(e,t){let n=document.createElement("button");return n.textContent=e,n.className="mermaid-control-button",n.addEventListener("click",t),window.addCleanup(()=>n.removeEventListener("click",t)),n}onMouseDown(e){e.button===0&&(this.isDragging=!0,this.startPan={x:e.clientX-this.currentPan.x,y:e.clientY-this.currentPan.y},this.container.style.cursor="grabbing")}onMouseMove(e){this.isDragging&&(e.preventDefault(),this.currentPan={x:e.clientX-this.startPan.x,y:e.clientY-this.startPan.y},this.updateTransform())}onMouseUp(){this.isDragging=!1,this.container.style.cursor="grab"}onWheel(e){e.preventDefault();let t=-e.deltaY*this.ZOOM_SENSITIVITY,n=Math.min(Math.max(this.scale+t,this.MIN_SCALE),this.MAX_SCALE),s=this.content.getBoundingClientRect(),r=e.clientX-s.left,i=e.clientY-s.top,o=n-this.scale;this.currentPan.x-=r*o,this.currentPan.y-=i*o,this.scale=n,this.updateTransform()}zoom(e){let t=Math.min(Math.max(this.scale+e,this.MIN_SCALE),this.MAX_SCALE),n=this.content.getBoundingClientRect(),s=n.width/2,r=n.height/2,i=t-this.scale;this.currentPan.x-=s*i,this.currentPan.y-=r*i,this.scale=t,this.updateTransform()}updateTransform(){this.content.style.transform=`translate(${this.currentPan.x}px, ${this.currentPan.y}px) scale(${this.scale})`}resetTransform(){this.scale=1,this.currentPan={x:0,y:0},this.updateTransform()}},b=["--secondary","--tertiary","--gray","--light","--lightgray","--highlight","--dark","--darkgray","--codeFont"],M;async function C(){let e=document.querySelector(".center").querySelectorAll("code.mermaid");if(e.length===0)return;let t=b.reduce((r,i)=>(r[i]=getComputedStyle(document.documentElement).getPropertyValue(i),r),{});M||=await import("https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.4.0/mermaid.esm.min.mjs");let n=M.default,s=document.documentElement.getAttribute("saved-theme")==="dark";n.initialize({startOnLoad:!1,securityLevel:"loose",theme:s?"dark":"base",themeVariables:{fontFamily:t["--codeFont"],primaryColor:t["--light"],primaryTextColor:t["--darkgray"],primaryBorderColor:t["--tertiary"],lineColor:t["--darkgray"],secondaryColor:t["--secondary"],tertiaryColor:t["--tertiary"],clusterBkg:t["--light"],edgeLabelBackground:t["--highlight"]}}),await n.run({nodes:e});for(let r=0;r<e.length;r++){let y=function(){let d=a.querySelector("#mermaid-space"),u=a.querySelector(".mermaid-content");if(!u)return;L(u);let T=i.querySelector("svg").cloneNode(!0);u.appendChild(T),a.classList.add("active"),d.style.cursor="grab",E=new h(d,u)},m=function(){a.classList.remove("active"),E=null},f=function(d){d.key==="Escape"&&m()},i=e[r],o=i.parentElement,p=o.querySelector(".clipboard-button"),l=o.querySelector(".expand-button"),v=window.getComputedStyle(p),w=p.offsetWidth+parseFloat(v.marginLeft||"0")+parseFloat(v.marginRight||"0");l.style.right=`calc(${w}px + 0.3rem)`,o.prepend(l);let a=o.querySelector("#mermaid-container");if(!a)return;let E=null,g=a.querySelector(".close-button");g.addEventListener("click",m),l.addEventListener("click",y),document.addEventListener("keydown",f),window.addCleanup(()=>{g.removeEventListener("click",m),l.removeEventListener("click",y),document.removeEventListener("keydown",f)})}}document.addEventListener("DOMContentLoaded",C);document.addEventListener("nav",C);
</script><script src="./postscript.js" type="module"></script></html>