안녕하세요! 지난 글에서는 소프트웨어 개발에서 **[[모듈(Module)]]**의 중요성과 기본 개념, 그리고 Java에서의 모듈화 방식에 대해 알아보았습니다. 이번 글에서는 한 걸음 더 나아가, Java 프로젝트를 구성할 때 흔히 고민하게 되는 **Java 패키지(Package)**와 **Gradle 모듈(Build-level Module)** 중 어떤 것을 기준으로 코드를 구조화하고 분리해야 할지에 대한 구체적인 가이드라인을 제시하고자 합니다.

이 두 가지 방식은 서로 다른 수준의 모듈화를 제공하며, 프로젝트의 특성과 목표에 따라 적절한 선택이 필요합니다.

---

## 1. Java 패키지 (Packages): 작은 단위의 논리적 그룹화 📁

Java 패키지는 클래스와 인터페이스를 논리적으로 관련된 단위로 묶는 가장 기본적인 방법입니다. 이는 주로 **하나의 빌드 결과물(예: JAR 파일, 하나의 Gradle 모듈) 내에서 코드를 체계적으로 구성**하는 데 사용됩니다.

- **주요 특징 및 목적**:
    
    - **이름 충돌 방지 (Namespace Management)**: 동일한 클래스 이름이 서로 다른 패키지 내에 존재할 수 있도록 합니다.
    - **접근 제어 (Access Control)**: `public`, `protected`, `default` (package-private), `private` 접근 제어자를 통해 클래스 및 멤버의 가시성을 제어하여 기본적인 **캡슐화**를 지원합니다.
    - **코드 가독성 및 구조화**: 관련된 클래스들을 함께 배치하여 전체 코드베이스를 이해하기 쉽게 만듭니다. 예를 들어, `com.example.myapp.user.service`, `com.example.myapp.user.domain`, `com.example.myapp.user.controller` 와 같이 기능별 또는 계층별로 패키지를 구성할 수 있습니다.
- **언제 주로 사용하는가?**:
    
    - 단일 팀 또는 소규모 팀에서 개발하는 **단일 애플리케이션 또는 라이브러리 내부**의 코드를 논리적으로 분리하고 싶을 때.
    - 특정 기능 또는 도메인과 관련된 클래스들을 응집력 있게 관리하고자 할 때.
    - **계층형 아키텍처**에서 각 계층(`presentation`, `application`, `domain`, `infrastructure`)을 구분할 때.
    - 강한 격리나 독립적인 배포 단위까지는 필요하지 않을 때.

패키지 구조는 주로 **응집도**를 높이고, 코드의 **이해도**를 향상시키는 데 초점을 맞춥니다. 하지만 패키지만으로는 독립적인 버전 관리, 빌드, 배포 단위를 구성하기 어렵습니다.

---

## 2. Gradle 모듈 (Gradle Modules): 독립적인 빌드 및 배포 단위 🧱

Gradle에서 모듈(종종 "서브프로젝트" 또는 "프로젝트"라고도 불림)은 **독립적으로 빌드되고 관리될 수 있는 별개의 코드 단위**입니다. 각 Gradle 모듈은 자체 소스 코드, 리소스, 의존성 및 빌드 스크립트(`build.gradle`)를 가질 수 있으며, 결과적으로 개별적인 아티팩트(예: JAR, WAR, AAR 파일)를 생성합니다.

- **주요 특징 및 목적**:
    
    - **독립적인 빌드 및 테스트**: 각 모듈을 개별적으로 빌드하고 테스트할 수 있어, 전체 시스템 빌드 시간을 단축하고 변경의 영향을 특정 모듈로 제한할 수 있습니다.
    - **명확한 의존성 관리**: 모듈 간의 의존 관계를 `build.gradle` 파일에 명시적으로 선언하고 관리합니다. (`api`, `implementation` 등의 설정을 통해 의존성의 전이 범위를 제어).
    - **강한 캡슐화 및 경계**: 모듈 간에는 오직 공개된 API(예: `public` 클래스 및 JPMS를 사용한다면 `exports`된 패키지)를 통해서만 상호작용이 가능하도록 강제할 수 있습니다. (물론, `public`만으로는 약한 캡슐화이므로 JPMS와 함께 사용 시 더욱 강력해집니다).
    - **재사용성 및 독립적 배포**: 특정 모듈을 라이브러리처럼 만들어 여러 다른 프로젝트나 모듈에서 재사용하거나, 필요에 따라 특정 모듈만 독립적으로 버전 관리하고 배포할 수 있습니다. (예: 마이크로서비스 아키텍처의 개별 서비스)
    - **병렬 개발 용이**: 서로 다른 팀이 각기 다른 모듈을 독립적으로 개발하고 관리할 수 있습니다.
- **언제 주로 사용하는가?**:
    
    - **대규모 애플리케이션**을 여러 개의 관리 가능한 작은 단위로 나누고 싶을 때.
    - 시스템의 특정 부분을 **독립적으로 개발, 테스트, 빌드, 배포, 버전 관리**하고 싶을 때.
    - **공통 라이브러리**를 개발하여 여러 프로젝트에서 공유하고자 할 때.
    - **플러그인 아키텍처**나 **마이크로서비스**와 같이 기능적으로 명확히 분리된 컴포넌트가 필요할 때.
    - 빌드 시간을 최적화하고 싶을 때 (변경된 모듈만 재빌드).
    - 서로 다른 기술 스택이나 라이프사이클을 가진 부분을 분리하고 싶을 때 (덜 일반적이지만 가능).

Gradle 모듈은 **결합도**를 낮추고, 시스템의 **유연성**과 **확장성**, **유지보수성**을 크게 향상시키는 데 중점을 둡니다.

---

## 3. 선택의 기준: 언제 무엇을 사용할까? 🎯

패키지와 Gradle 모듈은 상호 배타적인 개념이 아닙니다. **일반적으로 하나의 Gradle 모듈 내에 여러 개의 Java 패키지가 존재**합니다. 중요한 것은 "어느 수준에서 경계를 설정할 것인가?"입니다.

다음은 결정에 도움이 될 수 있는 몇 가지 기준입니다.

|   |   |   |
|---|---|---|
|**기준**|**Java 패키지 중심**|**Gradle 모듈 중심**|
|**프로젝트 크기/복잡성**|소규모, 단일 애플리케이션|대규모, 복잡한 시스템, 다중 애플리케이션/서비스|
|**재사용성 요구**|주로 해당 프로젝트 내부에서의 재사용|여러 프로젝트/시스템 간의 라이브러리 재사용|
|**팀 구조/독립성**|단일 팀 또는 소규모 팀, 밀접한 협업|여러 팀, 독립적인 개발 및 배포 주기 필요|
|**빌드/배포 전략**|단일 빌드, 단일 배포 (모놀리식)|모듈별 독립적 빌드, 테스트, 배포, 버전 관리 가능|
|**캡슐화/경계 수준**|패키지 접근 제어자 수준 (상대적으로 약함)|명시적 의존성, 독립적 아티팩트 (상대적으로 강함), JPMS로 강화|
|**의존성 관리 복잡도**|상대적으로 단순함|복잡한 의존성, 모듈 간 명확한 분리 필요|
|**기술적 이질성**|거의 없음 (단일 Gradle 모듈 내에서는 동일 기술 스택)|모듈별로 다른 JDK 버전 또는 주요 라이브러리 버전 (제한적)|
|**변경 빈도 및 영향 범위**|변경이 잦고, 내부적으로 긴밀히 연관된 로직이 많을 때|특정 기능이 독립적으로 자주 변경되거나, 안정적인 API 제공 필요 시|

**예시 시나리오**:

1. **간단한 웹 애플리케이션 (CRUD 기능 중심)**:
    - 하나의 Gradle 모듈 (예: `app`)을 두고, 그 안에 `com.example.user`, `com.example.product` 등의 도메인별 패키지와 `com.example.common`, `com.example.config` 등의 공통 패키지를 구성하는 것으로 충분할 수 있습니다.
2. **대규모 엔터프라이즈 시스템 (주문, 결제, 배송, 사용자 관리 등 다양한 하위 시스템 존재)**:
    - `order-service` (주문 모듈), `payment-service` (결제 모듈), `user-service` (사용자 모듈), `common-library` (공통 유틸리티 모듈) 등으로 Gradle 모듈을 분리하는 것을 고려할 수 있습니다. 각 Gradle 모듈은 내부적으로 자체적인 패키지 구조를 가집니다.
3. **사내 여러 프로젝트에서 공통으로 사용하는 인증/인가 라이브러리**:
    - 별도의 Gradle 모듈 (예: `security-core`)로 만들어 Nexus/Artifactory와 같은 사설 저장소에 배포하고, 다른 프로젝트에서 의존성으로 가져다 쓰는 것이 좋습니다.

---

## 4. Java 플랫폼 모듈 시스템 (JPMS)과의 관계 🧩

Java 9에서 도입된 JPMS는 패키지보다 더 강력한 캡슐화와 명시적인 의존성 관리를 제공합니다. JPMS는 Gradle 모듈과 함께 사용될 수 있습니다.

- 하나의 Gradle 모듈이 하나의 JPMS 모듈에 해당하도록 구성할 수 있습니다.
- 이 경우, Gradle 모듈의 `build.gradle`에서 의존성을 관리하고, JPMS의 `module-info.java` 파일에서는 해당 Gradle 모듈이 외부에 어떤 패키지를 `exports`하고, 어떤 다른 (JPMS)모듈을 `requires`하는지 더욱 세밀하게 제어할 수 있습니다.

이는 특히 라이브러리를 개발하거나 매우 강력한 캡슐화가 필요한 경우 유용합니다.

---

## 결론: 균형 잡힌 접근 방식이 중요 ⚖️

소프트웨어 모듈화에 있어 Java 패키지와 Gradle 모듈은 서로 다른 역할을 수행하는 중요한 도구입니다.

- **Java 패키지**는 주로 **단일 빌드 단위 내에서의 코드 구성과 논리적 분리**를 위해 사용됩니다.
- **Gradle 모듈**은 **독립적인 빌드, 배포, 버전 관리가 가능한 더 큰 단위의 기능적 분리**를 위해 사용됩니다.

프로젝트의 초기 단계에서는 패키지 기반으로 구조를 잡아가다가, 시스템이 성장하고 복잡성이 증가함에 따라 특정 부분을 별도의 Gradle 모듈로 분리하는 점진적인 접근 방식을 취할 수도 있습니다.

가장 중요한 것은 프로젝트의 현재와 미래의 요구사항(확장성, 유지보수성, 팀 구조 등)을 고려하여 각 방식의 장단점을 이해하고, 가장 적합한 수준의 모듈화를 적용하는 것입니다. 잘 설계된 모듈 구조는 결국 더 건강하고 지속 가능한 소프트웨어를 만드는 밑거름이 될 것입니다.