이 글에서는 객체 간의 상호작용 및 책임 분배에 초점을 맞추는 **행위 패턴**에 대해 깊이 있게 알아보고자 합니다. 행위 패턴을 이해하고 올바르게 사용하면, 객체들이 어떻게 소통하고 협력하여 작업을 완수하는지에 대한 명확한 청사진을 그릴 수 있습니다. 이는 결국 유연하고, 유지보수가 용이하며, 확장 가능한 소프트웨어를 만드는 데 핵심적인 역할을 합니다.

---

### 행위 패턴이란 무엇일까요?

**행위 패턴**은 **알고리즘과 객체 간의 책임 할당**에 관련된 패턴입니다. 이 패턴들은 객체들이 서로 상호작용하는 방식과 각자의 역할을 어떻게 분담하는지에 대한 효과적인 해결책을 제시합니다.

단순히 '무엇'을 하는지에 대한 로직뿐만 아니라, '누가', '언제', '어떻게' 그 로직을 수행할지를 정의함으로써 시스템 전체의 유연성을 크게 향상시킵니다. 즉, 객체 간의 결합도를 낮추고(Loosely Coupled), 각 객체가 자신의 책임에만 집중하도록 만들어 코드의 가독성과 재사용성을 높이는 것이 핵심 목표입니다.

행위 패턴은 크게 두 가지 유형으로 나눌 수 있습니다.

1. **클래스 패턴**: 상속을 사용하여 여러 클래스에 걸쳐 동작을 분산합니다. [[템플릿 메서드 패턴 (Template Method Pattern)]]이 대표적입니다.
2. **객체 패턴**: 객체 합성을 사용하여 동작을 여러 객체에 분산합니다. [[전략 패턴 (Strategy Pattern)]]이나 [[옵서버 패턴 (Observer Pattern)]] 등 대부분의 행위 패턴이 여기에 속하며, 더 동적인 유연성을 제공합니다.

---

### 주요 행위 패턴 소개

다양한 행위 패턴이 존재하지만, 여기서는 가장 널리 사용되고 중요한 몇 가지 패턴을 소개합니다. 각 패턴에 대한 자세한 설명은 해당 노트 링크를 통해 확인해주세요.

- **[[전략 패턴 (Strategy Pattern)]]**: 알고리즘을 각각의 클래스로 캡슐화하여, 런타임에 동적으로 알고리즘을 교체할 수 있게 합니다.
- **[[옵서버 패턴 (Observer Pattern)]]**: 한 객체의 상태가 변할 때 그 객체에 의존하는 다른 객체들에게 자동으로 알림을 보내고 업데이트할 수 있게 하는 일대다(one-to-many) 의존성을 정의합니다.
- **[[템플릿 메서드 패턴 (Template Method Pattern)]]**: 알고리즘의 골격은 상위 클래스에 정의하고, 일부 단계는 하위 클래스에서 구현하도록 하여 알고리즘의 구조는 유지하면서 특정 단계를 재정의할 수 있게 합니다.
- **[[상태 패턴 (State Pattern)]]**: 객체의 내부 상태가 변경됨에 따라 객체의 행위를 변경할 수 있게 합니다. 마치 객체의 클래스가 바뀌는 것처럼 보입니다.
- **[[책임 연쇄 패턴 (Chain of Responsibility Pattern)]]**: 요청을 보내는 객체와 요청을 처리하는 객체 간의 결합을 피하기 위해, 여러 객체를 사슬처럼 연결하고 요청이 해결될 때까지 사슬을 따라 전달하게 합니다.
- **[[커맨드 패턴 (Command Pattern)]]**: 요청 자체를 객체로 캡슐화하여, 요청을 보낸 쪽과 요청을 수행하는 쪽을 분리합니다. 이를 통해 요청을 큐에 저장하거나, 로깅하거나, 작업을 취소하는 등의 기능을 구현할 수 있습니다.
- **[[이터레이터 패턴 (Iterator Pattern)]]**: 컬렉션의 내부 표현은 드러내지 않으면서, 그 안에 포함된 요소들에 순차적으로 접근할 수 있는 방법을 제공합니다.
- **[[중재자 패턴 (Mediator Pattern)]]**: 여러 객체 간의 복잡한 상호작용(M:N 관계)을 하나의 중재자(Mediator) 객체에 캡슐화하여 객체 간의 직접적인 통신을 줄이고 결합도를 낮춥니다.
- **[[메멘토 패턴 (Memento Pattern)]]**: 객체의 캡슐화를 깨뜨리지 않으면서, 객체의 내부 상태를 저장하고 이전 상태로 복원할 수 있게 합니다.
- **[[비지터 패턴 (Visitor Pattern)]]**: 객체 구조의 요소에 대한 처리를 각 요소에서 분리하여, 구조를 변경하지 않고 새로운 동작을 추가할 수 있게 합니다.

---

### 행위 패턴은 언제 사용해야 할까요?

행위 패턴은 다음과 같은 상황에서 특히 유용합니다.

1. **객체 간의 통신 방식이 복잡할 때**: 객체들이 서로 거미줄처럼 얽혀있다면 [[중재자 패턴]]을 사용하여 관계를 단순화할 수 있습니다.
2. **다양한 알고리즘을 유연하게 교체해야 할 때**: 여러 정렬 알고리즘이나 결제 방법을 상황에 따라 바꿔야 한다면 [[전략 패턴]]이 훌륭한 해결책이 됩니다.
3. **한 객체의 변경 사항을 여러 객체에 알려야 할 때**: 주식 가격 변동을 여러 디스플레이에 알려주는 시스템처럼, 상태 변경 전파가 필요하다면 [[옵서버 패턴]]을 고려해야 합니다.
4. **요청을 처리할 객체가 명확하지 않거나 동적으로 정해져야 할 때**: 클릭 이벤트가 어떤 UI 요소에서 처리될지 결정해야 하는 경우 [[책임 연쇄 패턴]]을 사용할 수 있습니다.
5. **알고리즘의 큰 틀은 유지하되, 세부 내용만 바꾸고 싶을 때**: 데이터베이스 연결, 쿼리 실행, 연결 종료와 같은 큰 흐름은 고정하고 쿼리 내용만 바꾸고 싶다면 [[템플릿 메서드 패턴]]이 적합합니다.

---

### 결론

행위 패턴은 단순히 코드를 작성하는 기술을 넘어, 객체 지향 시스템의 동적인 상호작용을 설계하는 철학에 가깝습니다. 이 패턴들을 적재적소에 활용함으로써, 우리는 변화에 유연하게 대응하고, 협업하기 쉬우며, 시간이 지나도 그 가치를 유지하는 견고한 소프트웨어를 구축할 수 있습니다.

처음에는 각 패턴의 개념이 다소 추상적으로 느껴질 수 있습니다. 하지만 실제 문제 해결 과정에서 각 패턴의 의도와 구조를 떠올리며 적용하는 연습을 거듭한다면, 어느새 여러분의 설계 능력이 한 단계 성장해 있음을 발견하게 될 것입니다. 각 패턴의 상세 페이지를 통해 더 깊은 이해를 얻으시길 바랍니다.