디지털 서명(Digital Signature)은 디지털 문서의 **진위성**과 **무결성**을 보장하기 위해 사용되는 암호화 기술입니다. 마치 우리가 종이 계약서에 직접 서명하여 계약의 유효성을 증명하는 것처럼, 디지털 서명은 사이버 공간에서 보낸 사람이 누구인지, 그리고 내용이 위변조되지 않았는지를 수학적으로 증명해 줍니다.

단순히 문서에 서명 이미지를 첨부하는 것이 아니라, [[공개 키 암호화 (Public Key Cryptography)]]기술을 기반으로 한 정교한 메커니즘입니다. 디지털 서명을 제대로 이해하려면, 먼저 [[해시 함수]]와 공개 키 암호화라는 두 가지 핵심 개념을 알아야 합니다.

---

## 디지털 서명의 핵심 원리

디지털 서명은 '서명 생성'과 '서명 검증'이라는 두 단계로 이루어집니다. 이 과정은 송신자와 수신자 간의 신뢰를 구축하는 핵심적인 역할을 합니다.

전체적인 흐름을 그림으로 보면 다음과 같습니다.


```mermaid
sequenceDiagram
    participant Sender as 송신자
    participant Receiver as 수신자

    Note over Sender: 1. 원본 메시지를 해시 함수로 처리
    Sender->>Sender: 해시 값 생성
    Note over Sender: 2. 생성된 해시 값을 개인키로 암호화 (서명 생성)
    Sender->>Sender: 디지털 서명 생성

    Sender->>Receiver: 원본 메시지 + 디지털 서명 전송

    Note over Receiver: 3. 수신한 메시지를 동일한 해시 함수로 처리
    Receiver->>Receiver: 해시 값(A) 생성
    Note over Receiver: 4. 함께 수신한 디지털 서명을 송신자의 공개키로 복호화
    Receiver->>Receiver: 해시 값(B) 획득

    Note over Receiver: 5. 두 해시 값(A와 B) 비교
    alt 해시 값 일치
        Receiver->>Receiver: 서명 검증 성공! (무결성, 인증, 부인 방지 확인)
    else 해시 값 불일치
        Receiver->>Receiver: 서명 검증 실패! (문서가 위변조되었거나 발신자가 다름)
    end
```

### 1. 서명 생성 (송신자)

1. **해시 값 생성**: 송신자는 원본 메시지(예: 계약서 파일)를 [[해시 함수]]를 사용해 고정된 길이의 고유한 값, 즉 **해시(Hash) 값**으로 압축합니다. 메시지가 단 한 글자라도 바뀌면 해시 값은 완전히 달라집니다.
    
2. **개인키로 암호화**: 송신자는 자신의 **개인키(Private Key)**를 이용해 이 해시 값을 암호화합니다. 이렇게 암호화된 해시 값이 바로 **디지털 서명**입니다.
    
3. **메시지와 서명 전송**: 송신자는 원본 메시지와 생성된 디지털 서명을 수신자에게 함께 전송합니다.
    

### 2. 서명 검증 (수신자)

1. **서명 복호화**: 수신자는 사전에 공유받은 송신자의 **공개키(Public Key)**를 사용해 함께 전송된 디지털 서명을 복호화합니다. 성공적으로 복호화되면 원본 메시지의 해시 값이 나타납니다. (이것을 '해시 A'라고 하겠습니다.)
    
2. **해시 값 계산**: 수신자는 함께 받은 원본 메시지를 서명 생성 시 사용된 것과 **동일한 [[해시 함수]]**로 계산하여 새로운 해시 값을 얻습니다. (이것을 '해시 B'라고 하겠습니다.)
    
3. **해시 값 비교**: '해시 A'와 '해시 B'를 비교합니다. 만약 두 값이 **완벽하게 일치**한다면, 이 서명은 유효한 것으로 간주됩니다.
    

---

## 디지털 서명이 보장하는 세 가지

위와 같은 검증 과정을 통해 디지털 서명은 다음과 같은 세 가지 중요한 보안 요소를 보장합니다.

1. **무결성 (Integrity)**
    
    - 메시지가 전송 도중에 변경되지 않았음을 보장합니다. 만약 누군가 메시지를 조금이라도 수정했다면, 수신자가 계산한 '해시 B'가 송신자가 보낸 '해시 A'와 달라지기 때문에 위변조 사실을 즉시 알 수 있습니다.
        
2. **인증 (Authentication)**
    
    - 메시지를 보낸 사람이 진짜 그 사람이 맞는지 증명합니다. 디지털 서명은 송신자의 **개인키**로만 생성할 수 있으므로, 해당 서명을 송신자의 **공개키**로 성공적으로 복호화할 수 있다는 사실 자체가 송신자의 신원을 보증하는 역할을 합니다.
        
3. **부인 방지 (Non-repudiation)**
    
    - 송신자가 메시지를 보냈다는 사실을 나중에 부인할 수 없도록 합니다. 개인키는 오직 소유자만 가지고 있으므로, 해당 개인키로 생성된 서명이 존재한다는 것은 송신자가 직접 서명했다는 강력한 증거가 됩니다.
        

---

## Java를 이용한 디지털 서명 예시 코드

Java의 `java.security` 패키지를 사용하면 디지털 서명을 간단하게 구현해볼 수 있습니다. 다음은 `SHA256withRSA` 알고리즘을 사용한 예시입니다.

```java
import java.security.*;

public class DigitalSignatureExample {

    public static void main(String[] args) throws Exception {
        // 1. 원본 데이터
        String originalMessage = "이것은 디지털 서명을 위한 원본 메시지입니다.";
        byte[] data = originalMessage.getBytes("UTF8");

        // 2. RSA 키 쌍(개인키, 공개키) 생성
        KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
        keyGen.initialize(2048);
        KeyPair keyPair = keyGen.generateKeyPair();
        PrivateKey privateKey = keyPair.getPrivate();
        PublicKey publicKey = keyPair.getPublic();

        // 3. 서명 생성 (송신자 측)
        // 개인키를 사용하여 서명 객체 초기화
        Signature signature = Signature.getInstance("SHA256withRSA");
        signature.initSign(privateKey);
        // 원본 데이터를 업데이트
        signature.update(data);
        // 서명 생성
        byte[] digitalSignature = signature.sign();
        System.out.println("디지털 서명(생성됨): " + new String(digitalSignature, "ISO-8859-1"));

        // 4. 서명 검증 (수신자 측)
        // 공개키를 사용하여 검증 객체 초기화
        Signature verifier = Signature.getInstance("SHA256withRSA");
        verifier.initVerify(publicKey);
        // 검증할 원본 데이터 업데이트
        verifier.update(data);
        // 서명 검증 수행
        boolean isVerified = verifier.verify(digitalSignature);
        System.out.println("서명 검증 결과: " + (isVerified ? "성공" : "실패"));

        // 5. 데이터가 변조된 경우의 검증 실패 테스트
        byte[] tamperedData = (originalMessage + " (내용 변경됨)").getBytes("UTF8");
        verifier.update(tamperedData); // 올바른 데이터 대신 변경된 데이터로 업데이트
        // 참고: verify를 다시 호출하기 전에 update를 다시 해야 하는 경우,
        // Signature 객체를 다시 초기화해야 하지만 여기서는 간단한 시연을 위해 생략합니다.
        // 실제로는 새 객체를 만들거나 initVerify를 다시 호출해야 합니다.
        Signature tamperedVerifier = Signature.getInstance("SHA256withRSA");
        tamperedVerifier.initVerify(publicKey);
        tamperedVerifier.update(tamperedData);
        boolean isTamperedVerified = tamperedVerifier.verify(digitalSignature);
        System.out.println("변조된 데이터에 대한 서명 검증 결과: " + (isTamperedVerified ? "성공" : "실패"));
    }
}
```

위 코드는 키 쌍을 생성하고, 원본 데이터로 서명을 만든 뒤, 동일한 데이터와 다른 데이터로 각각 검증하여 그 결과를 보여줍니다. 이를 통해 무결성이 어떻게 동작하는지 직관적으로 이해할 수 있습니다.

---

## 디지털 서명 알고리즘

디지털 서명을 생성하고 검증하기 위해서는 다양한 암호화 알고리즘이 사용됩니다. 각 알고리즘은 보안 강도, 성능, 호환성 등에서 차이가 있습니다.

### RSA (Rivest-Shamir-Adleman)

RSA는 가장 널리 사용되는 공개 키 암호화 알고리즘 중 하나로, 디지털 서명에도 널리 활용됩니다.

- **특징**: 큰 정수의 소인수분해 문제의 어려움에 기반
- **키 길이**: 일반적으로 2048비트 이상 권장 (3072비트 또는 4096비트 권장)
- **사용 예시**: `SHA256withRSA`, `SHA512withRSA`
- **장점**: 널리 지원되고 검증된 알고리즘
- **단점**: 키 길이가 길어질수록 성능 저하

### ECDSA (Elliptic Curve Digital Signature Algorithm)

타원 곡선 암호학을 기반으로 한 디지털 서명 알고리즘입니다.

- **특징**: 동일한 보안 강도를 위해 RSA보다 훨씬 짧은 키 길이 사용
- **키 길이**: 256비트(ECDSA P-256)는 RSA 3072비트와 유사한 보안 강도
- **사용 예시**: `SHA256withECDSA`, `SHA512withECDSA`
- **장점**: 작은 키 크기로 인한 빠른 처리 속도, 모바일 환경에 적합
- **단점**: 구현이 복잡하고, 일부 환경에서 지원이 제한적일 수 있음

### DSA (Digital Signature Algorithm)

미국 정부에서 표준화한 디지털 서명 알고리즘이지만, 현재는 ECDSA로 대체되는 추세입니다.

- **특징**: 이산 로그 문제에 기반
- **사용 예시**: `SHA256withDSA`
- **현재 상태**: 레거시 시스템에서만 사용, 새로운 프로젝트에서는 권장하지 않음

### EdDSA (Edwards-curve Digital Signature Algorithm)

최신 타원 곡선 기반 디지털 서명 알고리즘입니다.

- **특징**: Ed25519, Ed448 등의 곡선 사용
- **장점**: 높은 보안성과 성능, 부채널 공격에 강함
- **사용 예시**: Ed25519, Ed448

## 공개 키 인프라(PKI)와 디지털 서명

디지털 서명이 신뢰할 수 있으려면, 공개키의 진위성을 확인할 수 있는 메커니즘이 필요합니다. [[공개 키 인프라 (PKI)]]는 이러한 신뢰 체계를 구축하는 핵심 인프라입니다.

PKI에서 [[인증 기관 (CA)]]는 디지털 인증서를 발급하여 특정 공개키가 특정 주체(개인, 조직, 서버 등)에 속한다는 것을 보증합니다. 이 인증서 자체도 CA의 개인키로 디지털 서명되어 있어, 인증서의 무결성과 진위성을 보장합니다.

실제 사용 시나리오:
1. 웹사이트가 HTTPS를 사용할 때, 서버는 CA가 서명한 인증서를 제공합니다.
2. 브라우저는 CA의 공개키를 사용하여 인증서의 서명을 검증합니다.
3. 인증서가 유효하면, 해당 웹사이트의 공개키를 신뢰할 수 있습니다.
4. 이후 통신에서 이 공개키를 사용하여 데이터 암호화 및 서명 검증을 수행합니다.

자세한 내용은 [[공개 키 인프라 (PKI)]]와 [[인증 기관 (CA)]] 문서를 참고해주세요.

## 디지털 서명 vs. HMAC

디지털 서명과 [[HMAC(Hash-based Message Authentication Code)]]는 모두 메시지의 무결성과 인증을 보장하지만, 사용하는 기술과 목적이 다릅니다.

| 구분 | 디지털 서명 | HMAC |
|---|---|---|
| **키 타입** | 비대칭 키 (공개키/개인키 쌍) | 대칭 키 (공유 비밀키) |
| **부인 방지** | 제공 (개인키는 소유자만 보유) | 제공하지 않음 (양쪽이 동일한 키 보유) |
| **성능** | 상대적으로 느림 (복잡한 수학 연산) | 빠름 (해시 함수 기반) |
| **키 분배** | 공개키는 공개 가능 | 비밀키는 안전하게 공유해야 함 |
| **사용 사례** | 전자 문서, 소프트웨어 배포, 법적 효력이 필요한 서명 | API 인증, 메시지 무결성 검증, [[JWT(JSON Web Token)]] 서명 |

디지털 서명은 부인 방지가 필요한 경우에 적합하고, HMAC은 빠른 인증이 필요한 경우에 적합합니다.

## 디지털 서명 vs. 암호화

종종 디지털 서명과 암호화를 혼동하는 경우가 있습니다. 두 기술은 목적이 다릅니다.

- **암호화 (Encryption)**: 데이터의 **기밀성(Confidentiality)**을 보장하는 것이 주 목적입니다. 허가된 사용자 외에는 내용을 볼 수 없도록 숨기는 기술입니다. 보통 수신자의 **공개키**로 암호화하고 수신자의 **개인키**로 복호화합니다.
    
- **디지털 서명 (Digital Signature)**: 데이터의 **무결성, 인증, 부인 방지**를 보장하는 것이 주 목적입니다. 내용이 변조되지 않았고, 누가 보냈는지 증명하는 기술입니다. 송신자의 **개인키**로 암호화(서명)하고 송신자의 **공개키**로 복호화(검증)합니다.

## 실제 사용 사례

디지털 서명은 현대 디지털 환경의 다양한 영역에서 핵심적인 역할을 수행합니다.

### 1. 웹 보안 (HTTPS/TLS)

웹사이트의 SSL/TLS 인증서는 CA가 디지털 서명한 인증서입니다. 이를 통해 사용자는 자신이 접속한 웹사이트가 진짜 해당 도메인의 서버임을 확인할 수 있습니다.

### 2. 소프트웨어 배포 및 코드 서명

소프트웨어 개발자는 자신의 애플리케이션에 디지털 서명을 추가하여:
- 소프트웨어가 변조되지 않았음을 보증
- 개발자의 신원을 확인
- 사용자에게 신뢰성 제공

### 3. 전자 문서 및 전자 계약

법적 효력을 가진 전자 문서에 디지털 서명을 사용하여:
- 문서의 무결성 보장
- 서명자의 신원 확인
- 부인 방지 제공

### 4. 이메일 보안 (S/MIME)

이메일에 디지털 서명을 추가하여:
- 이메일이 변조되지 않았음을 증명
- 발신자 인증
- 피싱 공격 방지

### 5. SSO (Single Sign-On) 프로토콜

[[SAML(Security Assertion Markup Language)]]과 같은 SSO 프로토콜에서 IdP(Identity Provider)가 발급한 어설션(Assertion)에 디지털 서명을 사용하여 SP(Service Provider)가 인증 결과를 신뢰할 수 있게 합니다.

### 6. 블록체인 및 암호화폐

비트코인과 같은 암호화폐에서 트랜잭션에 디지털 서명을 사용하여:
- 트랜잭션의 소유권 증명
- 이중 지불 방지
- 네트워크 보안 유지

### 7. API 인증

일부 API는 요청에 디지털 서명을 포함하여 요청의 무결성과 발신자 인증을 보장합니다.

## 보안 고려사항

디지털 서명을 구현하고 사용할 때 다음 보안 사항들을 반드시 고려해야 합니다.

### 1. 개인키 보호

개인키는 디지털 서명의 핵심이므로 절대 노출되어서는 안 됩니다. 다음 방법들을 고려해야 합니다:

- **하드웨어 보안 모듈(HSM) 사용**: 개인키를 안전한 하드웨어 장치에 저장
- **키 암호화**: 개인키 자체를 암호화하여 저장
- **접근 제어**: 개인키에 대한 접근을 엄격히 제한
- **정기적인 키 로테이션**: 일정 기간마다 새로운 키 쌍 생성 및 교체

### 2. 해시 함수 선택

안전한 해시 함수를 사용해야 합니다:

- **권장**: SHA-256, SHA-384, SHA-512
- **비권장**: MD5, SHA-1 (보안 취약점 발견됨)

### 3. 타임스탬프

디지털 서명에 타임스탬프를 포함하여:
- 서명의 유효 기간 확인
- 재전송 공격(Replay Attack) 방지
- 법적 증거력 강화

### 4. 인증서 검증

PKI 환경에서는 다음을 확인해야 합니다:

- 인증서의 유효 기간 확인
- 인증서 폐기 목록(CRL) 또는 OCSP를 통한 폐기 여부 확인
- 인증서 체인 검증 (루트 CA까지의 신뢰 체인 확인)

### 5. 재전송 공격 방지

동일한 서명이 재사용되는 것을 방지하기 위해:

- 일회용 난수(Nonce) 사용
- 타임스탬프 검증
- 서명된 요청의 고유성 확인

### 6. 키 길이 선택

충분한 보안 강도를 위해 적절한 키 길이를 선택해야 합니다:

- **RSA**: 최소 2048비트 (3072비트 이상 권장)
- **ECDSA**: 최소 256비트 (P-256 곡선)
- **EdDSA**: Ed25519 또는 Ed448

## 디지털 서명과 관련 기술

디지털 서명은 다양한 인증 및 보안 프로토콜의 기반이 됩니다:

- **[[SAML(Security Assertion Markup Language)]]**: SSO 프로토콜에서 어설션의 무결성과 진위성을 보장하기 위해 디지털 서명 사용
- **[[JWT(JSON Web Token)]]**: JWT의 서명 부분에서 디지털 서명 알고리즘(RS256, ES256 등) 사용
- **[[OAuth 2.0]]**: 일부 OAuth 2.0 구현에서 토큰 서명에 디지털 서명 사용

## 결론

디지털 서명은 단순한 보안 기술을 넘어, 온라인 비즈니스, 전자 정부, 금융 거래 등 디지털 사회의 신뢰를 지탱하는 핵심 인프라입니다. 개발자로서 디지털 서명의 원리를 이해하는 것은 안전하고 신뢰성 있는 시스템을 구축하는 데 필수적인 역량이라고 할 수 있습니다.

---

## 참고 자료

- Oracle Java Documentation - Signature Class ([https://docs.oracle.com/javase/8/docs/api/java/security/Signature.html](https://docs.oracle.com/javase/8/docs/api/java/security/Signature.html))
- RFC 3279 - Algorithms and Identifiers for the Internet X.509 Public Key Infrastructure Certificate ([https://www.rfc-editor.org/rfc/rfc3279](https://www.rfc-editor.org/rfc/rfc3279))
- RFC 3447 - Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1 ([https://www.rfc-editor.org/rfc/rfc3447](https://www.rfc-editor.org/rfc/rfc3447))
- RFC 6090 - Fundamental Elliptic Curve Cryptography Algorithms ([https://www.rfc-editor.org/rfc/rfc6090](https://www.rfc-editor.org/rfc/rfc6090))
- NIST Digital Signature Standard (DSS) ([https://csrc.nist.gov/publications/detail/fips/186/4/final](https://csrc.nist.gov/publications/detail/fips/186/4/final))
- Introduction to Digital Signatures - Thales Group ([https://www.thalesgroup.com/en/markets/digital-identity-and-security/iam/encryption/digital-signatures](https://www.thalesgroup.com/en/markets/digital-identity-and-security/iam/encryption/digital-signatures))