상속은 **객체 지향 프로그래밍(OOP)**의 핵심 기둥 중 하나로, **기존의 클래스(상위 클래스)가 가진 필드(속성)와 메서드(행동)를 새로운 클래스(하위 클래스)가 물려받아 사용할 수 있게 하는 메커니즘**입니다.

마치 자식이 부모의 유전적 특징을 물려받는 것처럼, 하위 클래스는 상위 클래스의 특징을 그대로 물려받아 사용하거나, 자신만의 새로운 특징을 추가하거나 기존의 특징을 변경할 수 있습니다.

### 핵심 용어

- **상위 클래스 (Superclass)**: 속성과 메서드를 물려주는 클래스입니다. **부모 클래스(Parent Class)** 또는 **기반 클래스(Base Class)**라고도 불립니다.
- **하위 클래스 (Subclass)**: 속성과 메서드를 물려받는 클래스입니다. **자식 클래스(Child Class)** 또는 **파생 클래스(Derived Class)**라고도 불립니다.

### 상속을 사용하는 이유

1. 코드 재사용성 (Code Reusability)
    
    가장 큰 장점은 코드의 중복을 줄이는 것입니다. 여러 클래스에서 공통으로 사용되는 속성과 메서드를 상위 클래스에 한 번만 정의해두면, 하위 클래스들은 상속을 통해 해당 코드를 그대로 재사용할 수 있습니다. 이는 개발 시간과 비용을 절약하고, 코드의 일관성을 유지하는 데 도움을 줍니다.
    
2. 계층적 구조 형성 (Logical Hierarchy)
    
    상속은 현실 세계의 개념처럼 'is-a' 관계를 모델링하여 클래스 간의 논리적인 계층 구조를 만들 수 있습니다. 예를 들어, '개(Dog)는 동물(Animal)이다', '소나타(Sonata)는 자동차(Car)이다'와 같은 관계를 코드로 명확하게 표현할 수 있습니다. 이는 프로그램의 구조를 더 이해하기 쉽게 만듭니다.
    
3. [[다형성(Polymorphism)]]의 기반
    
    상속은 다형성을 구현하는 필수적인 전제 조건입니다. 다형성이란 '여러 형태를 가질 수 있는 능력'을 의미하며, 상속 관계에서는 상위 클래스 타입의 참조 변수가 하위 클래스 타입의 인스턴스를 가리킬 수 있습니다. 이를 통해 코드를 유연하고 확장 가능하게 만들 수 있습니다.
    

### Java에서의 상속 구현

```java
// 상위 클래스 (Superclass)
public class Animal {
    String name;

    public Animal(String name) {
        this.name = name;
    }

    public void eat() {
        System.out.println(name + "이(가) 먹이를 먹습니다.");
    }
}

// 하위 클래스 (Subclass)
public class Dog extends Animal {
    // 상위 클래스의 생성자를 호출
    public Dog(String name) {
        super(name); // super()는 반드시 생성자의 첫 줄에 와야 합니다.
    }

    // 하위 클래스에 새로운 메서드 추가
    public void bark() {
        System.out.println(name + "이(가) 멍멍 짖습니다.");
    }

    // 상위 클래스의 메서드를 재정의 (메서드 오버라이딩)
    @Override
    public void eat() {
        System.out.println(name + "이(가) 사료를 먹습니다.");
    }
}

// 실행
public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog("보리");
        myDog.eat();  // 재정의된 메서드 호출 -> "보리이(가) 사료를 먹습니다."
        myDog.bark(); // 새로 추가된 메서드 호출 -> "보리이(가) 멍멍 짖습니다."
    }
}
```

- **`extends`**: `Dog` 클래스가 `Animal` 클래스를 상속받음을 명시합니다.
- **`super`**: 상위 클래스를 가리키는 참조 키워드입니다. `super(name)`을 통해 상위 클래스의 생성자를 호출하거나, `super.eat()`과 같이 상위 클래스의 메서드를 호출할 수 있습니다.
- **메서드 오버라이딩 (Method Overriding)**: 상위 클래스로부터 물려받은 메서드를 하위 클래스의 상황에 맞게 재정의하는 것을 의미합니다.

### 상속의 단점과 주의사항

상속은 강력한 도구이지만, 잘못 사용하면 오히려 코드의 유연성을 해치는 독이 될 수 있습니다.

1. 강한 결합도 (High Coupling)
    
    하위 클래스는 상위 클래스의 내부 구현에 강하게 의존하게 됩니다. 만약 상위 클래스의 코드가 변경되면, 이를 상속받는 모든 하위 클래스들이 예상치 못하게 영향을 받거나 오류를 발생시킬 수 있습니다.
    
2. 계층 구조의 복잡성
    
    상속의 깊이가 너무 깊어지면(예: A -> B -> C -> D), 전체 구조를 파악하기 어려워지고 유지보수가 힘들어집니다.
    
3. 단일 상속의 한계
    
    Java를 포함한 많은 언어에서는 클래스의 다중 상속을 지원하지 않습니다. 즉, 하나의 클래스는 오직 하나의 클래스만 상속받을 수 있습니다. 이는 '다이아몬드 문제'와 같은 복잡성을 방지하기 위함이지만, 설계에 제약을 주기도 합니다. (이러한 한계는 보통 [[인터페이스(Interface)]]를 통해 해결합니다.)
    

### 상속보다는 합성 (Composition over Inheritance)

이러한 단점 때문에 현대 객체 지향 설계에서는 무분별한 상속 사용을 지양하고, **"상속보다는 합성을 사용하라"**는 원칙을 강조합니다.

- **상속 (Inheritance)**: **'is-a' 관계**를 표현합니다. (`Dog` is an `Animal`)
- **합성 (Composition)**: **'has-a' 관계**를 표현합니다. 한 클래스가 다른 클래스의 인스턴스를 멤버 변수로 포함하는 방식입니다. (`Car` has an `Engine`)

합성은 상속보다 클래스 간의 결합도를 낮추어 훨씬 유연하고 테스트하기 쉬운 설계를 가능하게 합니다. 상속은 반드시 논리적으로 명확한 'is-a' 관계가 성립하고, 상위 클래스와 하위 클래스 간의 강한 연관성이 설계의 핵심일 때 신중하게 사용해야 합니다. 자세한 내용은 상속보다는 합성 노트를 참고해주세요.