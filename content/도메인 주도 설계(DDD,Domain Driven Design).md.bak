## 도메인 주도 설계란?

이 섹션에서는 도메인 주도 설계(DDD)의 근본적인 정의와 핵심 철학을 소개합니다. DDD가 왜 등장했으며, 소프트웨어 개발의 복잡성을 어떻게 해결하고자 하는지에 대한 이해를 돕는 것을 목표로 합니다.

### DDD의 핵심 철학

도메인 주도 설계(DDD)의 가장 핵심적인 철학은 소프트웨어 개발의 초점을 기술적 측면이 아닌, 소프트웨어가 운영될 [[도메인(Domain)]], 즉 특정 비즈니스 맥락과 문제 영역에 두는 것입니다.1 많은 소프트웨어 프로젝트에서 마주하는 복잡성은 **기술 자체의 어려움보다는 해당 소프트웨어가 해결하고자 하는 비즈니스 도메인의 본질적인 복잡성**에서 비롯된다는 깊은 통찰에서 DDD는 출발합니다. DDD는 단순히 코드를 작성하는 기술적 활동을 넘어, 문제 도메인을 철저히 이해하고 그 이해를 바탕으로 소프트웨어 설계를 이끌어가는 개발 철학이자 접근 방식입니다. 이는 **'어떻게 만들 것인가'라는 기술적 질문 이전에 '무엇을, 왜 만들어야 하는가'** 라는 본질적인 질문에 집중할 것을 요구합니다.

이처럼 도메인에 집중함으로써 개발팀은 비즈니스가 실제로 해결하고자 하는 핵심 문제에 역량을 집중할 수 있게 됩니다. 결과적으로, 비즈니스 목표에 진정으로 부합하고 가치를 제공하는 소프트웨어를 개발할 가능성이 현저히 높아집니다.

DDD는 [[유비쿼터스 언어(Ubiquitous Language)]], [[도메인 모델(Domain Model)]]을 이용해 모두가 이해할 수 있게 [[도메인(Domain)]]을 정의합니다.


### **[[유비쿼터스 언어(Ubiquitous Language)]]**

DDD는 개발자와 비즈니스 이해관계자(특히 도메인 전문가)가 모두 공유하고 이해하는 공통의 언어, 즉 '유비쿼터스 언어(Ubiquitous Language)'의 사용을 강력히 주창합니다. 이 언어는 소프트웨어의 설계 단계부터 시작하여 실제 구현 코드에 이르기까지 일관되게 사용되어야 합니다. 이를 통해 소프트웨어가 의도한 비즈니스 도메인의 개념과 규칙을 정확하게 반영하도록 보장하는 것을 목표로 합니다.1 유비쿼터스 언어는 단순한 용어 목록을 넘어, 도메인 모델과 실제 구현 코드를 긴밀하게 연결하고, 프로젝트가 진행됨에 따라 팀의 집단적인 이해가 깊어지면서 함께 정제되고 발전하는 살아있는 도구입니다. 이 언어가 코드에 직접 반영될 때 그 실효성이 극대화됩니다.

유비쿼터스 언어는 팀 내 의사소통 과정에서 발생할 수 있는 모호성을 줄이고, 용어 해석의 차이로 인한 오해를 방지하는 핵심적인 역할을 수행합니다. 특히 기술팀과 비즈니스팀 간의 깊은 간극을 메우고, 도메인 모델 자체가 이 언어의 구체적인 표현이자 기반이 되도록 합니다.

### [[도메인 모델(Domain Model)]]

도메인 모델은 특정 비즈니스 도메인 내에 존재하는 핵심적인 요소, 즉 엔티티(Entities), 이들의 관계(Relationships), 그리고 이들이 수행하는 행동(Behaviors) 등을 포착하여 개념적으로 표현한 것입니다.1 이 모델은 도메인 전문가와의 긴밀한 협력을 통해 개발되며, 소프트웨어 전체 설계의 구체적인 청사진 역할을 수행합니다.1 도메인 모델은 단순히 다이어그램이나 문서의 집합이 아니라, 추상적인 비즈니스 규칙과 개념들을 소프트웨어 시스템의 구체적인 구조(예: 객체, 함수)로 변환하고 연결하는 핵심적인 매개체입니다. 이는 실행 가능한 설계의 견고한 기반이 됩니다.6

잘 정의된 도메인 모델은 복잡한 비즈니스 로직을 명확하게 이해하고, 팀원 간에 효과적으로 전달하며, 최종적으로 소프트웨어 시스템에 정확하게 구현하기 위한 필수적인 기초가 됩니다. 개발 과정 전체를 이 도메인 모델에 기반함으로써, 개발자들은 비즈니스의 진정한 요구사항을 충실히 반영하는 고품질의 소프트웨어를 구축할 수 있습니다.
    

### DDD 의 장점

- **향상된 의사소통 및 협업:** 개발자와 도메인 전문가 사이에 공유된 유비쿼터스 언어를 사용함으로써, 의사소통 과정에서의 잠재적인 격차를 해소하고 모든 이해관계자가 도메인에 대한 공통된 이해를 형성하도록 촉진합니다.3

- **비즈니스 목표 집중:** 도메인 모델링 과정을 통해 개발자들이 기술적 세부사항보다는 핵심적인 비즈니스 로직에 집중하도록 유도합니다. 이는 결과적으로 개발되는 소프트웨어가 회사의 전략적 목표를 정확하게 충족하도록 보장하는 데 기여합니다.3

- **코드 품질 향상:** 도메인에 대한 깊고 공유된 이해를 바탕으로, 보다 명확하고, 깨끗하며, 신뢰할 수 있는 코드를 작성할 수 있게 됩니다. 또한, 잘 정립된 도메인 개념들은 반복적으로 사용 가능한 설계 패턴의 도출로 이어질 수 있습니다.3

- **유연성 및 적응성:** 애그리거트, 엔티티, 값 객체와 같은 DDD의 구성요소들은 복잡한 비즈니스 도메인을 효과적으로 모델링할 수 있게 해줍니다. 이는 시스템이 시간의 흐름에 따라 발생하는 비즈니스 요구사항의 변경, 기능 업데이트, 그리고 테스트 용이성 측면에서 높은 유연성과 적응성을 갖도록 지원합니다.3

- **확장성 및 모듈화:** 바운디드 컨텍스트와 애그리거트 같은 전략적, 전술적 패턴들은 복잡하고 거대한 시스템을 논리적으로 의미 있고 관리하기 쉬운 작은 부분들로 분해할 수 있게 합니다. 이는 시스템 전체의 확장성을 향상시키고 모듈성을 증진시키는 데 도움을 줍니다.3

- **균형 잡힌 개발:** 사용자 인터페이스(UI)나 사용자 경험(UX)과 같은 특정 측면에 대한 과도한 강조로 인해 정작 중요하지 않거나 불필요한 기능이 개발되는 상황을 방지합니다. 대신, 핵심 도메인 요구사항 해결에 집중함으로써 모든 사용자 및 이해관계자의 실제 필요를 충족하는 균형 잡힌 소프트웨어를 개발할 수 있도록 합니다.3 DDD를 통해 얻을 수 있는 이점들은 단순히 코드의 기술적 품질 개선을 넘어서, 소프트웨어 개발 과정에 참여하는 팀의 역동성을 향상시키고, 개발되는 소프트웨어와 실제 비즈니스 가치 사이의 직접적인 연계를 강화하는 방향으로 확장됩니다. 결국 기술은 비즈니스 문제를 해결하기 위한 수단이며, DDD는 이 수단이 본래의 목적에 더욱 효과적으로 부합하도록 돕는 핵심적인 역할을 수행합니다.

### **언제 DDD를 고려해야 할까요?**
    
- **복잡한 도메인:** 해결해야 할 비즈니스 로직이 매우 복잡하고, 다양한 규칙들이 얽혀 있으며, 도메인 자체를 이해하는 데 상당한 노력이 필요한 경우 DDD는 그 진가를 발휘합니다.1

- **장기 프로젝트:** 개발되는 시스템이 단기간 사용되고 폐기되는 것이 아니라, 장기간에 걸쳐 지속적으로 발전하고 유지보수되어야 하는 경우, DDD를 통해 구축된 견고하고 의미 있는 모델은 변화하는 요구사항에 훨씬 더 잘 대응할 수 있는 기반을 제공합니다.1

- **핵심 도메인 집중:** 개발하고자 하는 소프트웨어가 비즈니스의 핵심 경쟁력과 직접적으로 연결되는 '코어 도메인(Core Domain)'에 해당하여, 이 부분에 대한 깊이 있는 모델링과 정교한 구현이 매우 중요할 때 DDD는 효과적인 접근 방식이 될 수 있습니다.1

- **대규모 시스템 및 팀:** 여러 팀이 협업하여 하나의 거대한 시스템을 개발해야 하는 상황에서,]에서 다루는 바운디드 컨텍스트와 같은 개념들은 시스템을 효과적으로 분할하고 각 팀의 책임을 명확히 하며, 전체 시스템을 관리하는 데 큰 도움을 줄 수 있습니다.5

- **주의:** 모든 소프트웨어 프로젝트에 DDD가 반드시 필요한 것은 아닙니다. 만약 다루고자 하는 도메인이 매우 단순하거나, 프로젝트의 기간이 매우 짧거나, 혹은 주로 데이터의 생성, 조회, 수정, 삭제(CRUD) 작업이 중심이 되는 간단한 애플리케이션의 경우에는 DDD의 모든 요소를 엄격하게 적용하는 것이 오히려 과도한 노력(오버엔지니어링)이 될 수 있습니다.6 도메인에 대한 오해가 발생했을 때 치러야 할 비용이 매우 높은 프로젝트에서 DDD는 특히 그 가치를 발휘합니다. 만약 도메인이 단순하고 모든 팀 구성원이 명확하게 이해하고 있다면, DDD의 형식적인 절차는 불필요한 오버헤드가 될 수 있지만, 도메인이 복잡하고 미묘하여 잘못 해석될 경우 막대한 재작업 비용이나 프로젝트 실패로 이어질 수 있는 상황에서는 DDD를 통한 철저한 도메인 분석과 모델링의 가치가 더욱 커집니다.1

---

## **시스템 구성하기

전략적 설계는 도메인 주도 설계(DDD)의 핵심적인 두 축 중 하나로, 개별 객체의 세부적인 구현보다는 전체 비즈니스 도메인을 거시적인 관점에서 조망하고, 복잡한 시스템을 더 작고 관리하기 용이한 논리적인 부분들로 나누는 데 중점을 둡니다.6 이 단계에서는 [[바운디드 컨텍스트(Bounded Context)]]와 [[컨텍스트 맵핑(Context Mapping)]]을 이용해 시스템의 큰 그림을 그리고, 여러 도메인 모델들이 어떻게 상호작용하고 관계를 맺을 것인지를 정의하는 데 집중합니다.

### **[[바운디드 컨텍스트(Bounded Context)]]**

#### 정의

바운디드 컨텍스트는 **특정 도메인 모델이 일관성을 가지고 의미를 가지는 명확한 논리적 경계**를 정의합니다.1 이 경계 안에서 사용되는 용어, 개념, 규칙들은 명확하게 정의되고 일관되게 적용됩니다. 각 바운디드 컨텍스트는 자신만의 독립적인 도메인 모델과 그 모델에 기반한 유비쿼터스 언어를 가질 수 있으며, 이를 통해 개발팀은 자신이 책임지는 특정 영역의 문제 해결에 집중할 수 있게 됩니다.1
#### 필요성
- **단일 통합 모델의 한계:** 규모가 큰 엔터프라이즈급 시스템 전체에 대해 단일하고 모든 것을 포괄하는 통합된 도메인 모델을 구축하고 유지하는 것은 현실적으로 매우 어렵거나, 설령 가능하더라도 비용 대비 효과적이지 않습니다.5 조직 내의 서로 다른 부서나 팀은 동일한 용어(예: '고객')를 사용하더라도 각자의 업무 맥락에 따라 미묘하게 다른 의미나 중요도를 부여할 수 있으며, 이러한 차이를 단일 모델에 모두 반영하려 하면 모델의 일관성이 깨지고 혼란이 야기될 수 있습니다.5 바운디드 컨텍스트는 이러한 대규모 조직 및 복잡한 도메인에서 필연적으로 발생하는 의미론적 다양성을 수용하고 관리하기 위한 실용적인 해법입니다. 과거의 '단일 기업 모델' 접근 방식의 한계를 인정하고, 특정 맥락(Context) 안에서만 유효한(Bounded) 모델을 정의함으로써 전체 시스템의 복잡성을 효과적으로 분해하고 각 부분의 명확성을 높이는 전략입니다.

- **모델의 명확성 및 일관성 유지:** 바운디드 컨텍스트는 도메인 모델이 적용되는 범위를 명확히 제한함으로써, 해당 경계 내에서는 모델이 모호함 없이 명확하고 내부적으로 일관성을 유지하도록 보장합니다.5

- **팀 자율성 및 집중도 향상:** 각 개발팀은 자신이 책임지는 바운디드 컨텍스트 내의 모델과 유비쿼터스 언어에만 집중하여 개발을 진행할 수 있습니다. 이는 다른 컨텍스트의 모델 변경이나 내부 구현 방식으로부터의 간섭을 최소화하여 팀의 자율성을 높이고, 개발 생산성을 향상시킵니다. 결과적으로 시스템 전체의 모듈성을 증진시키고 유지보수성을 향상시키는 효과를 가져옵니다.1

#### 식별 방법
 - **언어적 경계:** 조직 내에서 사용되는 언어, 특히 특정 용어의 의미나 사용 방식이 달라지는 지점을 기준으로 컨텍스트를 나눌 수 있습니다. 유비쿼터스 언어는 도메인 모델의 핵심 기반이므로, 언어가 변화한다는 것은 다른 모델이 필요하다는 강력한 신호입니다.5

- **팀 조직 구조:** 개발팀의 구성, 각 팀의 책임 범위, 또는 비즈니스 부서의 구조에 따라 컨텍스트 경계를 설정하는 것도 효과적인 방법이 될 수 있습니다. 이는 팀 간의 의사소통 비용을 줄이고 책임 소재를 명확히 하는 데 도움이 됩니다.5

- **비즈니스 하위 도메인:** 전체 비즈니스 도메인을 주요 기능이나 문제 영역을 기준으로 논리적인 하위 도메인(Subdomains)으로 식별하고, 이러한 하위 도메인들을 각각의 바운디드 컨텍스트를 정의하는 기초로 삼을 수 있습니다. 특히 마이크로서비스 아키텍처를 고려할 때, 각 바운디드 컨텍스트는 독립적으로 배포 가능한 마이크로서비스의 후보가 될 수 있습니다.7
###  [[컨텍스트 맵핑(Context Mapping)]]

#### 정의
컨텍스트 맵은 하나의 시스템 내에 존재하는 여러 바운디드 컨텍스트들과, 그들 사이에 맺어지는 다양한 통합 패턴 및 관계들을 시각적으로 명확하게 표현한 문서 또는 다이어그램입니다.5 이는 전략적 설계의 핵심 산출물 중 하나로 간주됩니다.

#### 필요성
- **시스템 전체 조망:** 컨텍스트 맵을 통해 시스템을 구성하는 주요 컴포넌트(바운디드 컨텍스트)들과 각 컴포넌트가 구현하고 있는 도메인 모델에 대한 전체적인 개요를 파악할 수 있습니다.8

- **의사소통 패턴 명확화:** 서로 다른 바운디드 컨텍스트를 담당하는 팀들 간의 기술적인 의사소통 방식뿐만 아니라, 협업의 형태(예: 긴밀한 파트너십, 느슨한 고객-공급자 관계) 및 선호하는 통합 패턴(예: 안티코럽션 계층 사용, 공유 커널 채택 등)을 명확하게 보여줍니다.8

- **조직적 문제 식별:** 때로는 컨텍스트 맵을 통해 팀 간의 보이지 않는 정치적 문제나 의사소통의 어려움, 기술적 결정권의 불균형 등 조직적인 문제를 간접적으로 파악하고 논의하는 데 도움을 줄 수 있습니다.8

- **통합 전략 수립:** 각 바운디드 컨텍스트 간에 어떤 통합 패턴을 적용할지 결정하고, 이로 인해 발생할 수 있는 잠재적인 통합 문제점들을 사전에 식별하며, 시스템 전체의 일관성과 효율성을 유지하기 위한 전략을 수립하는 데 매우 유용합니다.9 컨텍스트 맵은 단순한 기술적 연결 상태만을 보여주는 다이어그램을 넘어, 그 이면에 있는 사람, 팀, 조직 문화, 심지어는 권력 관계까지도 반영하거나 추론할 수 있게 하는 강력한 분석 도구입니다. 예를 들어, 특정 팀이 항상 '공급자(Upstream)' 역할을 하고 다른 여러 팀들이 일방적으로 '준수자(Conformist)' 역할만 수행한다면, 이는 해당 시스템 내에서 기술적 결정권의 불균형이나 특정 팀에 대한 과도한 의존성을 나타낼 수 있습니다.

#### 컨텍스트 맵 예시


```mermaid
            graph TD
                subgraph "영업 컨텍스트 (Sales BC)"
                    A["영업 모델 (핵심 도메인)"]
                end
                subgraph "고객지원 컨텍스트 (Support BC)"
                    B[고객지원 모델]
                end
                subgraph "레거시 빌링 시스템 (Legacy Billing)"
                    C_ACL["빌링 안티코럽션 계층 (ACL)"]
                    C_OHS
                end
                subgraph "제품 카탈로그 컨텍스트 (Product Catalog BC)"
                    D_SK["제품 카탈로그 모델 (공유 커널)"]
                end
            
                A -- "고객/공급자 (U:영업, D:지원) - 영업팀이 공급자, 지원팀이 고객" --> B
                B -- "준수자 (Conformist) - 지원팀이 영업팀 모델 준수" --> A
                A -- "안티코럽션 계층 (ACL) - 영업팀이 레거시 시스템으로부터 모델 보호" --> C_ACL
                C_ACL -- "소비 (Consumes)" --> C_OHS
                C_OHS -- "오픈 호스트 서비스 (OHS) - 레거시 시스템이 API 제공" --> C_ACL
                A -- "공유 커널 (Shared Kernel) - 제품 정보 공유" --> D_SK
                B -- "공유 커널 (Shared Kernel) - 제품 정보 공유" --> D_SK
            
                classDef coreDomain fill:#f9f,stroke:#333,stroke-width:2px;
                class A coreDomain;
```

위 다이어그램은 가상의 컨텍스트 맵 예시입니다. '영업 컨텍스트'는 핵심 도메인으로 표현되었으며, '고객지원 컨텍스트'와는 고객-공급자 관계를 맺고 있고, 동시에 고객지원 컨텍스트가 영업 컨텍스트의 모델을 준수하는 관계도 보여줍니다. 반면, '레거시 빌링 시스템'과는 직접적인 통합 대신 '안티코럽션 계층(ACL)'을 두어 영업 모델을 보호하며, 레거시 시스템은 '오픈 호스트 서비스(OHS)'를 통해 API를 제공합니다. '제품 카탈로그 컨텍스트'의 모델은 영업과 고객지원 컨텍스트에서 '공유 커널'로 사용되어 제품 정보를 공유합니다. 각 화살표는 관계의 방향과 유형을 나타냅니다.10

컨텍스트 맵은 바운디드 컨텍스트 간의 관계를 명확히 하고, 통합 전략을 논의하는 데 매우 유용한 도구입니다. 아래는 대표적인 패턴들입니다.

|                                           |                                                                                                   |                               |                                                     |
| ----------------------------------------- | ------------------------------------------------------------------------------------------------- | ----------------------------- | --------------------------------------------------- |
| **패턴 이름 (Pattern Name)**                  | **설명 (Description)**                                                                              | **관계 유형 (Relationship Type)** | **주요 특징 (Key Characteristic)**                      |
| **파트너십 (Partnership)**                    | 두 팀이 상호 의존적으로 협력하여 통합을 조율합니다. 어느 한쪽이 일방적으로 결정하지 않으며, 공동의 성공을 목표로 합니다. 8                           | 상호 의존 (Mutual Dependency)     | 양방향 협력, 공동의 성공 목표, 높은 수준의 커뮤니케이션 필요                 |
| **공유 커널 (Shared Kernel)**                 | 두 개 이상의 컨텍스트가 도메인 모델의 특정 부분(커널)을 명시적으로 공유하고 함께 개발 및 유지보수합니다.                                      | 공유 (Shared)                   | 모델의 중복 제거, 긴밀한 결합 형성, 커널 변경 시 모든 공유 컨텍스트에 즉각적인 영향   |
| **고객-공급자 (Customer-Supplier)**            | 상류(Upstream, 공급자) 팀과 하류(Downstream, 고객) 팀 간의 명확한 관계. 상류팀은 하류팀의 요구사항을 수렴하여 자신의 계획에 반영합니다. 9        | 상류/하류 (Upstream/Downstream)   | 하류팀의 요구가 상류팀 계획에 반영, 상류팀은 하류팀의 성공 여부와 독립적으로 성공 가능   |
| **준수자 (Conformist)**                      | 하류(Downstream) 컨텍스트가 상류(Upstream) 컨텍스트의 모델을 그대로 수용하고 따릅니다. 하류팀은 모델에 대한 영향력이 거의 없습니다.              | 상류/하류 (Upstream/Downstream)   | 하류팀의 개발 단순성 증대, 상류 모델 변경 시 하류팀에 직접적인 영향 및 취약성 발생    |
| **안티코럽션 계층 (ACL, Anti-Corruption Layer)** | 하류(Downstream) 컨텍스트가 자체 모델을 보호하기 위해, 상류(Upstream) 모델과의 사이에 번역(Translation) 계층을 둡니다. 8             | 상류/하류 (Upstream/Downstream)   | 하류 모델의 독립성 및 순수성 유지, 특히 레거시 시스템이나 외부 시스템 연동 시 매우 유용 |
| **오픈 호스트 서비스 (OHS, Open Host Service)**   | 상류(Upstream) 시스템이 잘 정의된 프로토콜(예: REST API, gRPC)을 통해 자신의 서비스를 하류(Downstream) 시스템들에게 공개적으로 제공합니다. 8 | 서비스 제공 (Service Provision)    | 공개되고 안정적인 인터페이스, 여러 하류 컨텍스트가 공통으로 사용 가능             |
| **공개 언어 (Published Language)**            | 잘 문서화되고 공유되는 정보 교환 언어(예: XML 스키마, JSON 스키마, Protobuf 정의)를 통해 여러 컨텍스트 간의 통합을 수행합니다.                | 정보 교환 (Information Exchange)  | 명확한 데이터 형식 정의, 다양한 기술 스택을 사용하는 시스템 간의 통합 용이         |
| **분리된 방법 (Separate Ways)**                | 두 컨텍스트 간에 의도적으로 어떠한 직접적인 통합도 하지 않고, 각자의 독립적인 길을 갑니다. 이로 인해 기능 중복이 발생할 수 있습니다. 8                   | 무관 (Free/No Connection)       | 통합으로 인한 복잡성 및 비용 회피, 각 컨텍스트의 완전한 개발 및 배포 독립성 확보     |
| **큰 진흙 덩어리 (Big Ball of Mud)**            | 시스템 내에서 모델이 복잡하게 얽혀있고 경계가 불분명하며, 코드 품질이 낮아 관리가 어려운 부분을 나타냅니다. 9                                   | - (문제 상황 식별)                  | 품질 저하된 부분의 격리 필요, 다른 건강한 컨텍스트로의 문제 전파 방지 노력         |
컨텍스트 맵 패턴의 선택은 단순히 기술적인 결정을 넘어, 관련된 팀들 간의 자율성 수준, 통합 지점의 유지보수 비용, 그리고 연결된 시스템들이 각기 다른 속도로 진화할 수 있는 유연성에 직접적이고 중대한 영향을 미칩니다. 예를 들어, '파트너십' 패턴은 높은 수준의 협업과 공동 책임을 요구하지만, 두 시스템이 함께 유기적으로 발전할 수 있는 큰 유연성을 제공합니다. 반면, '안티코럽션 계층' 패턴은 하류 컨텍스트의 모델을 외부 변화로부터 효과적으로 보호하지만, 번역 계층을 개발하고 지속적으로 유지보수하는 데 상당한 비용과 노력이 소요될 수 있습니다. 이처럼 각 패턴은 서로 다른 장단점과 트레이드오프를 가지므로, 어떤 패턴을 선택하느냐에 따라 개발 방식, 팀 간의 관계 설정, 그리고 시스템의 장기적인 유지보수성과 발전 가능성이 크게 달라질 수 있습니다. 따라서 컨텍스트 맵 패턴의 선택은 신중하고 전략적인 의사결정을 필요로 합니다.

---

## 도메인 모델의 구성 요소 상세화

전략적 설계가 시스템 전체의 큰 그림과 바운디드 컨텍스트 간의 관계를 정의했다면, 전술적 설계는 각 개별 바운디드 컨텍스트 내에서 도메인 모델을 구성하는 구체적인 요소들, 즉 빌딩 블록(building blocks)들을 정밀하게 설계하고 정의하는 단계입니다.6 이 단계에서는 [[엔티티(Entity)]], [[값 객체(Value Objects)]], [[애그리게이트(Aggregate)]], [[서비스(Service)]], [[리포지토리(Repository),]] 팩[[토리(Factory)]], 그리고 [[도메인 이벤트(Domain Event)]]와 같은 핵심적인 패턴들을 활용하여 도메인 모델을 구체화합니다.

- ### **[[엔티티(Entity)]] 와 [[값 객체(Value Objects)]] 구분하기**
    
    - **엔티티 (Entity):**
        - **정의:** 고유한 식별자(identifier)를 가지며, 시간이 지남에 따라 그 속성(attributes)들이 변경될 수 있지만, 식별자 자체는 변하지 않고 연속성을 유지하는 객체입니다.1 엔티티의 생명주기 동안 그 상태는 변할 수 있지만, 우리는 식별자를 통해 동일한 엔티티임을 추적하고 구분할 수 있습니다.
        - **특징:**
            - **식별성 (Identity):** 엔티티의 가장 핵심적인 특징은 시스템 내에서 유일하게 구별될 수 있는 고유한 ID를 가진다는 것입니다. 이 ID는 엔티티를 조회하거나 다른 객체에서 참조하는 데 사용됩니다.7
            - **생명주기 (Lifecycle):** 엔티티는 생성되고, 시간이 지남에 따라 상태가 변경되며, 결국에는 소멸될 수 있는 명확한 생명주기를 가집니다.12
            - **가변성 (Mutability):** 일반적으로 엔티티의 속성들은 변경될 수 있습니다. 예를 들어, 고객(Customer) 엔티티의 주소나 연락처는 시간이 지남에 따라 변경될 수 있지만, 고객 ID는 그대로 유지됩니다.7
            - **예시:** 고객(Customer), 주문(Order), 상품(Product), 계좌(Account) 등과 같이 시스템 내에서 고유하게 식별되고 추적되어야 하는 개념들이 엔티티로 모델링됩니다.7
    - **값 객체 (Value Object):**
        - **정의:** 어떤 개념적인 전체를 나타내는 하나 이상의 속성들의 단순한 모음으로, 고유한 식별자를 갖지 않고 오직 그 객체가 가진 속성들의 값으로만 정의되는 객체입니다.1 값 객체는 그 자체로 독립적인 생명주기를 갖기보다는, 주로 엔티티의 속성을 기술하거나 측정하는 데 사용됩니다.
        - **특징:**
            - **식별성 없음 (No Identity):** 값 객체는 고유한 ID를 가지지 않습니다. 두 값 객체의 모든 속성 값이 완전히 동일하다면, 이 두 객체는 서로 동일한 것으로 간주됩니다 (구조적 동등성, structural equality).12
            - **불변성 (Immutability):** 값 객체는 일단 한 번 생성되면 그 내부 상태가 변하지 않는 것(immutable)이 이상적입니다. 만약 값 객체의 상태 변경이 필요하다면, 기존 객체를 수정하는 대신 새로운 속성 값을 가진 새로운 값 객체를 생성하여 대체하는 방식을 사용합니다.13 이는 예측 가능성을 높이고 부작용을 줄이는 데 도움이 됩니다.
            - **측정 또는 기술 (Measures or Describes):** 도메인 내의 어떤 것을 측정(예: 길이, 무게, 금액), 수량화(예: 개수) 또는 기술(예: 색상, 주소, 기간)하는 데 주로 사용됩니다.14
            - **자가 유효성 검사 (Self-Validating):** 값 객체는 생성 시점에 자신의 속성 값들이 유효한 범위 내에 있는지, 또는 특정 규칙을 만족하는지 스스로 검사하는 로직을 포함할 수 있습니다.
            - **예시:** 주소(Address), 금액(Money), 색상(Color), 기간(DateRange), IP 주소(IPAddress), 이름(Name) 등과 같이 그 값 자체가 중요한 개념들이 값 객체로 모델링됩니다.13
    - **핵심 구분 기준:** 엔티티와 값 객체를 구분하는 것은 전술적 설계의 기본 중 하나이며, 다음 기준들을 통해 명확히 할 수 있습니다.12
        - **식별자 유무 및 동등성 비교 방식:** 엔티티는 고유 식별자를 가지며, 두 엔티티가 동일한지 여부는 이 식별자를 비교하여 판단합니다(식별자 동등성, identifier equality). 반면, 값 객체는 식별자가 없으며, 모든 속성의 값이 동일한지 여부로 동등성을 판단합니다(구조적 동등성, structural equality).12
        - **생명주기 및 가변성:** 엔티티는 시스템 내에서 비교적 긴 시간 동안 연속적인 생명주기를 가지며, 그 상태가 변경될 수 있는 가변성(mutability)을 가집니다. 반면, 값 객체는 일반적으로 수명이 짧고 일시적이며, 불변성(immutability)을 지향하여 상태 변경으로 인한 복잡성을 최소화합니다.12
        - **독립적 존재 가능성:** 엔티티는 그 자체로 독립적으로 존재하며 시스템 내에서 추적될 수 있습니다. 하지만 값 객체는 일반적으로 하나 이상의 엔티티에 소속되어 그 엔티티의 속성을 설명하거나 특징짓는 역할을 하며, 독립적으로 존재하기보다는 엔티티의 컨텍스트 안에서 의미를 가집니다.12
    - **인용:** "The main difference between entities and value objects lies in the way we compare their instances to each other. The concept of identifier equality refers to entities, whereas the concept of structural equality - to value objects." 12
    - **엔티티 vs. 값 객체 비교 테이블:**

|   |   |   |
|---|---|---|
|**특징 (Feature)**|**[[엔티티(Entity)]]**|**[[값 객체(Value Objects)]]**|
|**식별자 (Identifier)**|고유 식별자 가짐 (예: ID 필드) 7|식별자 없음 12|
|**동등성 비교 (Equality)**|식별자 동등성 (Identifier Equality) - ID가 같으면 동일 객체 12|구조적 동등성 (Structural Equality) - 모든 속성 값이 같으면 동일 객체 12|
|**가변성 (Mutability)**|일반적으로 변경 가능 (Mutable) - 속성 값 변경 가능 7|불변 지향 (Immutable) - 생성 후 상태 변경 불가, 변경 시 새 객체 생성 13|
|**생명주기 (Lifespan)**|연속적인 생명주기 (생성, 다양한 상태 변경, 소멸) 12|일반적으로 일시적, 필요에 따라 생성 및 폐기, 엔티티의 생명주기에 의존적일 수 있음 12|
|**정의 방식 (How Defined)**|고유한 식별자로 정의됨, 속성은 시간에 따라 변경될 수 있음 7|객체를 구성하는 모든 속성의 조합으로 정의됨 13|
|**독립적 존재 (Can it live alone?)**|독립적으로 존재 가능하며, 자체적인 생명주기 관리 13|일반적으로 엔티티의 속성으로 존재하거나 엔티티에 소속되어 의미를 가짐 12|
|**주요 관심사 (Main Concern)**|"누구인가?", "무엇인가?" (객체의 정체성, Who/What it is)|"어떤 값인가?", "얼마나?" (객체가 나타내는 값, What value it has)|

엔티티와 값 객체의 구분은 단순히 이론적인 분류 체계를 따르는 것을 넘어, 도메인 모델의 의미를 더욱 명확하게 하고 시스템 전체의 복잡성을 효과적으로 관리하기 위한 매우 실질적이고 중요한 설계 결정입니다. 만약 식별성이 본질적으로 필요 없는 개념(예: 특정 시점의 환율, 색상 코드)을 엔티티로 잘못 모델링한다면, 불필요한 식별자 관리, 생명주기 관리의 오버헤드가 발생하고 모델의 의도가 흐려질 수 있습니다. 반대로, 시스템 내에서 고유하게 추적되고 참조되어야 할 핵심적인 개념(예: 특정 고객의 주문 이력)을 값 객체로 잘못 모델링한다면, 해당 객체의 히스토리를 추적하거나 다른 객체에서 안정적으로 참조하는 것이 불가능해지는 심각한 문제가 발생할 수 있습니다. 따라서 이 구분은 도메인 모델링의 초기 단계에서부터 신중하게 이루어져야 하며, 모델의 정확성과 견고성에 큰 영향을 미칩니다.

- ### **`[[애그리게이트(Aggregate)]]` : 일관성의 경계 관리**
    
    - **정의:** 애그리거트는 관련된 여러 엔티티와 값 객체들의 묶음(클러스터 또는 그룹)으로, 데이터 변경의 기본 단위이자 일관성이 유지되어야 하는 경계로 취급됩니다.1 애그리거트 내의 모든 객체들은 하나의 논리적인 단위로 간주되며, 특정 비즈니스 규칙(불변성, invariants)을 공유하고 함께 변경됩니다. 따라서 애그리거트에 대한 모든 변경 작업은 하나의 트랜잭션으로 처리되어 원자성을 보장해야 합니다.16
    - **구성 요소:**
        - **`]`:** 애그리거트 내에 포함된 여러 엔티티 중에서 단 하나를 루트(Root)로 지정합니다. 이 애그리거트 루트는 해당 애그리거트 전체에 대한 유일한 진입점(entry point) 역할을 수행합니다.15 외부의 다른 객체들은 오직 이 애그리거트 루트를 통해서만 애그리거트 내부의 다른 엔티티나 값 객체에 접근하고 상태를 변경하는 작업을 요청할 수 있습니다.16
        - **내부 엔티티 및 값 객체:** 애그리거트 루트에 의해 직접 또는 간접적으로 관리되는 다른 엔티티들과 값 객체들입니다. 이들은 애그리거트 루트의 생명주기에 의존하며, 애그리거트 경계 외부에서 직접 참조되어서는 안 됩니다.
    - **`]` 의 역할:**
        - **일관성 보증:** 애그리거트 루트는 해당 애그리거트가 항상 지켜야 하는 모든 비즈니스 규칙(불변성, invariants)을 강제하고 보호하는 책임을 집니다. 애그리거트에 대한 모든 상태 변경 요청은 루트를 통해 이루어지므로, 루트는 이러한 요청을 검증하고 실행하여 모든 작업이 애그리거트를 일관된 상태로 유지하도록 보장합니다.15
        - **캡슐화:** 애그리거트 루트는 애그리거트 내부의 복잡한 구조와 구현 세부사항을 외부로부터 숨기고, 외부에는 해당 애그리거트가 수행할 수 있는 잘 정의된 비즈니스 행위(메서드)만을 인터페이스로 노출합니다. 이는 객체 지향의 캡슐화 원칙을 강화합니다.15
        - **단일 접근점:** 애그리거트 내부의 어떤 객체의 상태를 변경하고자 할 때, 반드시 애그리거트 루트를 통해서만 해당 작업을 수행해야 합니다. 이는 애그리거트의 일관성을 유지하고 비즈니스 규칙을 강제하는 데 필수적인 원칙입니다.16
    - **애그리거트 설계 원칙:** 효과적인 애그리거트를 설계하기 위해서는 다음과 같은 주요 원칙들을 고려해야 합니다.
        - **작게 유지하라 (Make them small):** 애그리거트의 크기가 너무 커지면, 하나의 애그리거트를 수정하기 위해 너무 많은 객체들이 함께 로드되고 잠금(lock)되어야 하므로 동시성 문제 발생 가능성이 높아지고 시스템 성능에 부정적인 영향을 줄 수 있습니다.17
        - **하나의 트랜잭션으로 하나의 애그리거트만 수정하라 (Modify one aggregate per request/transaction):** 단일 요청이나 트랜잭션 내에서는 가급적 하나의 애그리거트 인스턴스만 수정하는 것을 목표로 해야 합니다. 여러 애그리거트를 한 트랜잭션에서 동시에 수정하려고 하면 시스템의 복잡성이 크게 증가하고, 분산 트랜잭션 관리가 필요하게 되어 구현이 어려워질 수 있습니다.17 이러한 애그리거트 간의 연쇄적인 변경은 `]`를 통한 최종적 일관성(eventual consistency) 방식으로 해결하는 것이 일반적입니다.
        - **다른 애그리거트는 ID로 참조하라 (Reference other aggregates by identity):** 한 애그리거트가 다른 애그리거트를 참조해야 할 경우, 다른 애그리거트의 객체 자체를 직접 참조하는 대신, 해당 애그리거트 루트의 고유 식별자(ID)만을 참조해야 합니다. 직접적인 객체 참조는 애그리거트 간의 강한 결합을 만들고, 애그리거트의 경계를 모호하게 만들며, 로딩 성능 문제를 야기할 수 있습니다.17
        - **진정한 비즈니스 불변성을 찾아라 (Find true business invariants):** 애그리거트는 특정 비즈니스 규칙, 즉 불변성(항상 참이어야 하는 조건)을 보호하고 강제하기 위해 존재합니다. 따라서 애그리거트를 설계할 때는 해당 애그리거트가 책임져야 할 핵심적인 비즈니스 불변성이 무엇인지 명확하게 식별하고 정의해야 합니다.17
    - **인용:** "An AGGREGATE is a cluster of associated objects that we treat as a unit for the purpose of data changes." (Eric Evans) 15 애그리거트는 단순한 객체들의 그룹핑을 의미하는 것을 넘어, 복잡한 도메인에서 데이터의 무결성과 비즈니스 규칙의 일관성을 보장하는 핵심적인 트랜잭션 경계 역할을 수행합니다. 이는 여러 객체에 걸쳐 있는 상태 변경을 원자적으로 처리함으로써, 시스템의 상태 관리를 단순화하고 예측 가능하게 만드는 데 크게 기여합니다.15 애그리거트 루트는 마치 성의 문지기처럼 애그리거트의 수문장(gatekeeper) 역할을 수행하여, 외부로부터의 모든 접근을 통제하고 애그리거트 내부 상태를 보호하며 비즈니스 규칙에 따른 일관성을 강제하는 궁극적인 책임을 집니다.16 이를 통해 애그리거트 내부의 복잡성은 효과적으로 숨겨지고, 외부에는 잘 정의된 인터페이스만을 제공함으로써 캡슐화 원칙이 강화됩니다.
- ### **서비스 계층: `]` 와 `]`**
    
    - **개요:** 도메인 내의 어떤 중요한 로직들은 특정 엔티티나 값 객체 하나에 명확하게 속한다고 보기 어색하거나, 여러 도메인 객체에 걸쳐 수행되는 경우가 있습니다. 이러한 로직들을 캡슐화하고 도메인 모델 내에서 명시적으로 표현하기 위해 서비스(Service)라는 개념을 사용합니다. DDD에서는 이러한 서비스를 주로 도메인 서비스와 애플리케이션 서비스의 두 가지 유형으로 구분하여 그 역할과 책임을 명확히 합니다.4
    - **`]`:**
        - **정의:** 특정 엔티티나 값 객체의 책임으로 할당하기에는 부자연스러운 순수한 도메인 로직을 캡슐화하는 역할을 합니다.4 이러한 로직은 종종 여러 엔티티나 값 객체들 간의 상호작용을 포함하거나, 도메인의 중요한 계산 또는 비즈니스 규칙 검증을 수행합니다. 도메인 서비스는 상태를 가지지 않는(stateless) 작업(operation)의 형태로 표현됩니다.7
        - **특징:**
            - **상태 비저장 (Stateless):** 도메인 서비스는 자체적으로 어떠한 상태도 가지지 않아야 합니다. 필요한 모든 데이터는 메서드 호출 시 파라미터로 전달받거나, 리포지토리를 통해 조회하여 사용하고, 작업 결과를 반환하거나 다른 도메인 객체의 상태를 변경하는 방식으로 동작합니다.4
            - **도메인 중심 인터페이스:** 도메인 서비스의 인터페이스(메서드 시그니처)는 주로 도메인 모델의 다른 요소들, 즉 엔티티나 값 객체, 그리고 도메인에서 사용되는 유비쿼터스 언어로 정의됩니다.4
            - **도메인 객체 조작:** 도메인 객체(엔티티, 값 객체)를 입력으로 받고, 새로운 도메인 객체를 반환하거나, 기존 도메인 객체의 상태를 변경하는 부수 효과(side effect)를 통해 도메인 로직을 수행합니다.18
            - **예시:** 두 은행 계좌 엔티티 간의 자금 이체 로직(이체 가능 여부 확인, 각 계좌 잔액 변경 등), 여러 상품 정보와 고객 등급, 프로모션 규칙 등을 복합적으로 고려하여 주문 총액에 대한 할인을 계산하는 로직 등이 도메인 서비스로 구현될 수 있습니다.
    - **`]`:**
        - **정의:** 사용자의 요청이나 외부 시스템의 호출과 같은 특정 유스케이스(use case)를 실행하기 위해 필요한 작업 흐름을 조정(orchestrate)하고, 도메인 계층의 객체들과 데이터베이스나 메시징 큐와 같은 인프라스트럭처 계층 간의 상호작용을 관리하는 역할을 합니다.19 애플리케이션 서비스는 일반적으로 프레젠테이션 계층(UI 계층)이나 다른 외부 시스템으로부터의 요청을 받아 처리하는 진입점이 됩니다.
        - **특징:**
            - **상태 비저장 (Stateless):** 애플리케이션 서비스 또한 자체적으로 상태를 가지지 않는 것이 일반적입니다.19
            - **워크플로우 조정 및 위임:** 애플리케이션 서비스는 복잡한 비즈니스 로직을 직접 포함하지 않습니다. 대신, 해당 유스케이스를 수행하기 위해 필요한 도메인 객체(주로 애그리거트 루트)나 도메인 서비스의 메서드를 호출하여 실제 비즈니스 로직 처리를 위임합니다. 즉, "얇게(thin)" 유지하는 것이 중요합니다.19
            - **트랜잭션 및 보안 관리:** 애플리케이션 서비스는 종종 트랜잭션 경계를 관리하는 책임을 집니다. 또한, 필요한 경우 인증이나 권한 부여와 같은 보안 관련 로직을 처리하기도 합니다.19
            - **인프라스트럭처 활용:** 리포지토리를 통해 애그리거트를 데이터베이스에서 가져오거나 저장하고, 외부 시스템과의 통신(예: 알림 발송)을 위한 인프라스트럭처 서비스를 호출할 수 있습니다.
            - **DTO 사용:** 일반적으로 입력으로 DTO(Data Transfer Object)를 받고, 작업 결과를 DTO 형태로 반환하거나 아무것도 반환하지 않을 수 있습니다. 도메인 객체를 직접 외부로 노출하는 것을 피하기 위함입니다.18
            - **예시:** 새로운 사용자 등록 요청을 받아 사용자 정보를 검증하고, 사용자 애그리거트를 생성하여 저장한 후 환영 이메일을 발송하는 '사용자 등록 처리 서비스', 고객의 상품 주문 요청을 받아 재고를 확인하고, 주문 애그리거트를 생성하며, 결제를 처리하고, 주문 완료 알림을 보내는 '상품 주문 처리 서비스' 등이 애플리케이션 서비스의 예입니다.
    - **구분:** 도메인 서비스와 애플리케이션 서비스는 명확히 구분되어야 하며, 그 기준은 다음과 같습니다.7
        - **주요 관심사:** 도메인 서비스는 '도메인 고유의 핵심 비즈니스 로직' 자체에 중점을 두는 반면, 애플리케이션 서비스는 '애플리케이션의 특정 유스케이스를 위한 워크플로우 조정 및 외부와의 연동'에 중점을 둡니다.
        - **상호작용 대상:** 도메인 서비스는 주로 다른 도메인 객체들(엔티티, 값 객체)과 상호작용하며 순수한 도메인 로직을 수행합니다. 반면, 애플리케이션 서비스는 UI 계층, 외부 시스템, 인프라스트럭처 계층(리포지토리, 메시징 시스템 등), 그리고 도메인 계층(도메인 서비스, 애그리거트) 모두와 상호작용하여 유스케이스를 완성합니다.
    - **도메인 서비스 vs. 애플리케이션 서비스 비교 테이블:**

|   |   |   |
|---|---|---|
|**구분 (Aspect)**|**]**|**]**|
|**목적 (Purpose)**|특정 엔티티/값 객체에 속하기 어려운 핵심 도메인 로직 캡슐화 4|특정 유스케이스의 실행 흐름 조정, 애플리케이션 워크플로우 관리 19|
|**주요 로직 (Primary Logic)**|순수 비즈니스 규칙, 여러 도메인 객체 간의 연산, 도메인 고유 계산|도메인 객체/서비스 호출 조정, 트랜잭션 관리, 보안 처리, 외부 시스템 및 인프라 연동 19|
|**상태 (Statefulness)**|상태 없음 (Stateless) 4|상태 없음 (Stateless) 19|
|**입력/출력 (Input/Output)**|주로 도메인 객체 (엔티티, 값 객체), 도메인 특정 원시 타입 18|주로 DTO(Data Transfer Objects), 일반 원시 타입 18|
|**도메인 객체와의 상호작용**|도메인 객체의 메서드 직접 호출, 새로운 도메인 객체 생성/기존 객체 상태 변경|리포지토리를 통해 애그리거트 로드/저장, 도메인 서비스의 메서드 호출 19|
|**주요 호출자 (Primary Consumer)**|애플리케이션 서비스, 다른 도메인 서비스, 때로는 애그리거트 내부 18|프레젠테이션 계층 (UI 컨트롤러), 외부 시스템 API 게이트웨이, 스케줄링된 작업 등 18|
|**관심사 (Concern)**|"이 도메인이 무엇을 할 수 있는가?", "이 비즈니스 규칙은 어떻게 동작하는가?"|"이 애플리케이션이 사용자나 다른 시스템에게 어떤 기능을 제공하는가?"|

```
    *   **테이블의 가치:**
        1.  **역할과 책임 명확화:** 도메인 고유의 로직과 애플리케이션 수준의 조정 로직을 명확히 구분하는 것은 DDD에서 매우 중요한 관심사 분리 원칙입니다. 이 테이블은 각 서비스 계층의 역할과 책임을 명확히 정의하여, 개발자가 로직을 적절한 위치에 배치하고 각 계층의 목적에 집중하도록 돕습니다.
        2.  **계층 분리 강화 (Separation of Concerns):** 도메인 계층이 UI, 데이터베이스 접근, 트랜잭션 관리와 같은 애플리케이션 특화 로직이나 인프라스트럭처 관심사로부터 오염되는 것을 방지합니다. 동시에, 애플리케이션 계층이 순수 비즈니스 로직으로 인해 불필요하게 비대해지는 것을 막아줍니다. 이는 시스템 전체의 유지보수성과 테스트 용이성을 크게 향상시킵니다.
        3.  **설계 일관성 유지:** 팀 내에서 서비스 계층을 설계하고 구현할 때 일관된 기준과 가이드라인을 제공합니다. [19]는 "애플리케이션 서비스를 얇게 유지하라(Keep Application-Services Thin)"고 조언하는데, 이는 애플리케이션 서비스가 오케스트레이션 역할에 충실해야 하며, 복잡한 비즈니스 로직은 도메인 계층으로 위임해야 함을 의미합니다.
        4.  **재사용성 증진:** 순수한 도메인 로직만을 담고 있는 도메인 서비스는 특정 유스케이스에 종속되지 않으므로, 여러 다른 유스케이스(즉, 여러 애플리케이션 서비스)에서 재사용될 가능성이 높습니다.[18] 이는 코드 중복을 줄이고 시스템의 효율성을 높입니다.

도메인 서비스와 애플리케이션 서비스의 명확한 구분은 도메인 모델의 순수성을 지키고, 애플리케이션의 다양한 유스케이스들을 효과적으로 관리하기 위한 핵심적인 아키텍처 원칙입니다. 이러한 구분이 없다면, 도메인 모델은 UI나 데이터베이스와 같은 외부 요소에 대한 지식을 갖게 되어 결합도가 높아지고 테스트가 어려워지며, 반대로 애플리케이션 수준의 로직이 도메인 객체 내부에 흩어져 있으면 특정 유스케이스를 파악하고 변경하는 것이 매우 어려워집니다. 따라서 이 두 유형의 서비스를 명확히 분리하는 것은 관심사의 분리(Separation of Concerns) 원칙을 DDD에 효과적으로 적용하는 중요한 방법론입니다.[7, 18, 19]
```

- ### **`]` : 애그리거트의 영속성 관리**
    
    - **정의:** 리포지토리는 도메인 객체, 특히 애그리거트 루트의 영속성(데이터베이스 등에 저장하고 조회하는 작업)을 담당하는 추상화된 인터페이스입니다.20 리포지토리는 도메인 계층과 실제 데이터 저장소가 위치하는 인프라스트럭처 계층 사이의 중재자 역할을 수행하며, 도메인 모델 코드가 특정 영속성 기술(예: JPA, JDBC, NoSQL API)에 직접적으로 의존하지 않도록 분리합니다.
    - **특징:**
        - **컬렉션과 유사한 인터페이스:** 리포지토리는 마치 메모리상에 존재하는 객체들의 컬렉션처럼 애그리거트를 추가(저장), 제거, 그리고 다양한 조건으로 조회하는 메서드들을 제공합니다. 일반적인 메서드 이름으로는 `findById(id)`, `save(aggregate)`, `delete(aggregate)`, `findAll()` 등이 있습니다.
        - **애그리거트 루트 단위로 작동:** 리포지토리는 반드시 애그리거트 루트에 대해서만 제공되어야 합니다. 애그리거트는 일관성의 단위이므로, 애그리거트 전체가 하나의 단위로 저장되고 조회되어야 합니다. 애그리거트 내부의 개별 엔티티나 값 객체를 직접 조회하거나 저장하는 리포지토리는 만들지 않습니다.
        - **구현은 인프라 계층에 위치:** 리포지토리의 인터페이스는 도메인 계층에 정의되어 도메인 서비스나 애플리케이션 서비스가 이 인터페이스에 의존하도록 합니다. 그러나 이 인터페이스의 실제 구현 클래스(예: JPA를 사용하는 `OrderRepositoryImpl`, MongoDB를 사용하는 `CustomerRepositoryImpl` 등)는 인프라스트럭처 계층에 위치합니다. 이를 통해 의존성 역전 원칙(Dependency Inversion Principle)을 따릅니다.
    - **인용:** "Repositories serve as an abstraction layer, offering methods to pull out domain objects, while neatly tucking away the underlying infrastructure." 20 리포지토리 패턴의 핵심 가치는 도메인 모델을 영속성 메커니즘의 구체적인 세부 사항으로부터 효과적으로 분리(decoupling)하는 데 있습니다. 이러한 분리를 통해 도메인 모델은 특정 데이터베이스 기술이나 SQL 쿼리, ORM 프레임워크의 어노테이션 등에 대해 알 필요가 없어지므로, 모델 자체의 순수성을 유지하고 비즈니스 로직에만 집중할 수 있게 됩니다. 만약 리포지토리 추상화가 없다면, 도메인 로직을 담고 있는 엔티티나 도메인 서비스 내부에 영속성 처리 관련 코드가 직접적으로 섞이게 되어 모델이 불필요하게 복잡해지고, 향후 데이터베이스 기술을 변경해야 할 경우 도메인 코드까지 광범위하게 수정해야 하는 심각한 문제가 발생할 수 있습니다. 또한, 리포지토리 인터페이스를 사용하면 단위 테스트 시 실제 데이터베이스 연결 없이 모의(mock) 리포지토리 객체를 주입하여 도메인 로직을 격리된 상태에서 훨씬 용이하게 테스트할 수 있다는 장점도 있습니다.
- ### **`[[팩토리 (Factory)]]` : 복잡한 객체 생성 책임**
    
    - **정의:** 팩토리는 복잡한 도메인 객체, 특히 여러 구성요소를 가지거나 생성 시 특정 비즈니스 규칙(불변성)을 만족시켜야 하는 애그리거트 루트, 엔티티, 또는 값 객체의 생성 로직을 전문적으로 캡슐화하는 역할을 합니다.14 객체를 생성하는 과정이 단순한 생성자 호출만으로 끝나지 않거나, 생성에 필요한 정보가 여러 곳에서 오거나, 특정 조건에 따라 다른 하위 타입의 객체를 생성해야 할 때 팩토리 패턴의 사용이 매우 유용합니다.
    - **특징:**
        - **일관된 상태로 객체 생성 보장:** 팩토리는 생성된 객체가 모든 필수적인 불변성(invariants)을 만족하는 유효하고 일관된 상태임을 보장해야 할 책임이 있습니다. 즉, 팩토리를 통해 생성된 객체는 즉시 사용 가능한 완전한 상태여야 합니다.4
        - **생성 로직의 분리 및 캡슐화:** 객체 생성에 필요한 복잡한 로직, 초기화 과정, 또는 외부 의존성(예: 다른 서비스 호출 결과)들을 해당 객체를 사용하려는 클라이언트 코드로부터 완전히 분리하고 숨깁니다. 이를 통해 클라이언트 코드는 객체 생성의 세부 사항을 알 필요 없이 단순하게 유지될 수 있습니다.14
        - **원자적 연산 (Atomic Operation):** 일반적으로 팩토리 메서드는 객체를 성공적으로 생성하는 데 필요한 모든 정보를 한 번의 호출로 전달받아, 원자적으로 객체 생성 과정을 완료합니다. 생성 과정에서 일부 규칙이 위반되거나 필요한 정보가 부족하면 객체 생성을 실패시키고 예외를 발생시킬 수 있습니다.4
        - **다양한 구현 위치:** 팩토리는 여러 형태로 구현될 수 있습니다. 생성될 객체 자체의 정적 메서드(static factory method), 해당 객체의 인터페이스에 정의된 팩토리 메서드, 또는 완전히 독립적인 별도의 팩토리 서비스 클래스 형태로 존재할 수 있습니다. 때로는 애그리거트 루트가 내부 엔티티를 생성하는 팩토리 역할을 수행하기도 합니다.4
    - **인용:** "Factories shoulder the responsibility of crafting complex domain objects and aggregates. They package the entire process of object creation and initialization, endorsing code reusability and a clean separation of concerns." 20 팩토리는 객체 생성 과정의 복잡성을 효과적으로 캡슐화하고, 객체가 생성되는 시점부터 그 유효성과 일관성을 철저히 보장함으로써 도메인 모델 전체의 견고함과 신뢰성을 높이는 데 중요한 역할을 합니다. 만약 객체 생성 로직이 복잡함에도 불구하고(예를 들어, 여러 다른 값 객체들을 조합하여 하나의 엔티티를 구성해야 하거나, 특정 비즈니스 조건에 따라 서로 다른 구체적인 하위 타입의 객체를 생성해야 하는 경우) 이러한 로직이 클라이언트 코드에 그대로 노출된다면, 클라이언트 코드는 불필요하게 지저분해지고 객체가 불완전하거나 유효하지 않은 상태로 생성될 위험이 커집니다. 팩토리는 이러한 객체 생성과 관련된 모든 책임을 한 곳으로 집중시켜 관리함으로써 이와 같은 문제들을 효과적으로 해결합니다.4
- ### **`]` : 도메인 내 중요한 사건 알림**
    
    - **정의:** 도메인 이벤트는 특정 바운디드 컨텍스트 내의 도메인에서 발생한, 비즈니스적으로 의미 있고 중요한 사건(significant occurrence)을 나타내는 객체입니다.21 이러한 이벤트는 일반적으로 도메인 객체(주로 애그리거트)의 상태가 변경된 결과로 발생하며, "주문이 완료되었다(OrderPlaced)", "상품이 배송되었다(ProductShipped)"와 같이 과거 시제로 명명됩니다. 이는 해당 사건이 이미 발생했음을 명확히 나타냅니다.
    - **특징:**
        - **불변성 (Immutability):** 도메인 이벤트는 과거에 이미 발생한 사실을 기록하는 것이므로, 일단 생성된 후에는 그 내용이 변경되어서는 안 되는 불변(immutable) 객체여야 합니다.22
        - **정보 전달:** 이벤트는 해당 사건과 관련된 최소한의 필수적인 정보를 담고 있어야 합니다. 예를 들어, `OrderPlaced` 이벤트는 어떤 주문(주문 ID)이 누구에 의해(고객 ID) 언제 발생했는지 등의 정보를 포함할 수 있습니다. 너무 많은 정보를 담기보다는, 이벤트 수신자가 추가 정보가 필요할 경우 ID를 통해 조회할 수 있도록 하는 것이 일반적입니다.
        - **디커플링 (Decoupling):** 도메인 이벤트를 사용하면 시스템의 서로 다른 부분(예: 서로 다른 애그리거트, 또는 심지어 다른 바운디드 컨텍스트)들이 서로에 대해 직접적인 의존 관계를 갖지 않고도 상호작용할 수 있게 됩니다. 이벤트 발행자(publisher)는 누가 이벤트를 구독(subscribe)하는지 알 필요가 없으며, 구독자는 발행자에 대해 알 필요가 없습니다.21
        - **부수 효과 트리거 (Side Effect Trigger):** 하나의 애그리거트에서 발생한 도메인 이벤트는 시스템의 다른 부분에서 다양한 부수적인 효과(side effects)를 유발하는 트리거 역할을 할 수 있습니다. 예를 들어, 주문 완료 이벤트는 재고 관리 시스템에서 해당 상품의 재고를 감소시키거나, 고객에게 주문 확인 이메일을 발송하는 작업을 시작시킬 수 있습니다.
        - **감사 추적 (Audit Trail):** 시스템 내에서 발생한 모든 중요한 비즈니스 사건들의 기록으로 활용될 수 있어, 문제 발생 시 원인 추적이나 비즈니스 분석에 유용한 데이터를 제공할 수 있습니다.21
    - **활용:**
        - **애그리거트 간의 최종적 일관성(Eventual Consistency) 달성:** 한 트랜잭션에서 하나의 애그리거트만 수정한다는 원칙을 지키면서도, 여러 애그리거트에 걸친 비즈니스 프로세스를 구현할 때 도메인 이벤트가 핵심적인 역할을 합니다. 예를 들어, 주문 애그리거트에서 주문이 완료되면 `OrderPlaced` 이벤트를 발행하고, 이 이벤트를 구독하는 결제 애그리거트나 배송 애그리거트가 비동기적으로 다음 단계를 처리하도록 할 수 있습니다.
        - **외부 시스템과의 통합:** 내부 시스템에서 발생한 도메인 이벤트를 외부 시스템에 전달하여, 외부 시스템이 필요한 작업을 수행하도록 유도할 수 있습니다.
        - **사용자 알림 (Notification):** 특정 도메인 이벤트 발생 시 사용자에게 이메일, SMS, 또는 애플리케이션 내 알림을 보내는 데 활용될 수 있습니다.
        - **`]`의 기본 구성 요소:** 이벤트 소싱 패턴에서는 애플리케이션의 현재 상태를 직접 저장하는 대신, 상태를 변경시킨 모든 도메인 이벤트들의 순차적인 목록을 저장합니다. 도메인 이벤트는 이벤트 소싱의 가장 기본적인 구성 요소입니다.21
    - **인용:** "In DDD, a Domain Event represents something significant that has happened within a specific Bounded Context." 21 도메인 이벤트는 현대의 복잡한 분산 시스템 환경에서 시스템 내의 여러 구성 요소들을 느슨하게 연결(loosely coupled)하고, 비동기적(asynchronous)이며 반응형(reactive) 시스템 아키텍처를 구축하는 데 있어 매우 핵심적인 역할을 수행합니다. 특히, 애그리거트 설계 원칙 중 "하나의 트랜잭션에서는 하나의 애그리거트만 수정한다"는 제약을 지키면서도, 여러 애그리거트의 경계를 넘나드는 복잡한 비즈니스 프로세스를 우아하고 효과적으로 처리할 수 있는 강력한 방법을 제공합니다. Eric Evans가 그의 저서 초판에서는 도메인 이벤트 패턴을 비중 있게 다루지 않았지만, 오늘날에는 이벤트를 통합하지 않고는 도메인 계층을 완전히 효과적으로 개발하기 어렵다고 할 정도로 그 중요성이 매우 커졌습니다.21

---

## **4. `#]`**

도메인 주도 설계(DDD)의 다양한 개념들을 이론적으로 이해하는 것만큼이나, 이러한 개념들을 실제 소프트웨어 개발 프로젝트에 성공적으로 적용하고 구현하는 것도 매우 중요합니다. 이 섹션에서는 DDD를 실제 시스템에 구현할 때 고려해야 할 주요 사항들과 함께, 널리 사용되는 스프링(Spring) 프레임워크를 활용한 간단한 코드 예시를 통해 독자 여러분의 이해를 돕고자 합니다.

- ### **반복적 개선과 협업의 중요성**
    
    - **설명:** 도메인 주도 설계는 프로젝트 초기에 한 번 완벽한 도메인 모델을 만들고 그것으로 끝나는 정적인 활동이 결코 아닙니다. 비즈니스 환경과 요구사항은 끊임없이 변화하고, 이에 따라 소프트웨어도 지속적으로 진화하고 적응해야 합니다.1 따라서, 도메인 전문가(비즈니스 담당자, 현업 사용자 등)와 개발팀 간의 지속적이고 반복적인 긴밀한 협업을 통해, 도메인 모델과 이를 반영하는 소프트웨어를 점진적으로 개선해 나가는 것이 DDD 성공의 핵심적인 요소입니다.1 DDD의 성공은 초기 모델의 완벽함에 달려 있는 것이 아니라, 변화하는 비즈니스 환경에 대한 지속적인 학습 의지와 이를 모델에 반영하여 개선해 나가는 능력에 달려있습니다. 이는 단순히 기술적인 문제 해결을 넘어, 조직의 문화와 개발 프로세스 자체의 변화를 요구할 수도 있습니다.
    - **실천 방안:**
        - **정기적인 지식 공유 세션 (Knowledge Crunching Sessions):** 개발팀과 도메인 전문가가 함께 모여 도메인 지식을 집중적으로 탐구하고 공유하는 세션을 정기적으로 가집니다. 이를 통해 유비쿼터스 언어를 정제하고 도메인 모델에 대한 이해를 심화시킵니다.4
        - **프로토타이핑 및 실험 (Brainstorming and Experimenting):** 복잡하거나 불확실한 도메인 영역에 대해서는 실제 코드로 빠르게 프로토타입을 만들거나 다양한 모델링 아이디어를 실험해 봄으로써, 이론적인 논의만으로는 발견하기 어려운 문제점이나 새로운 통찰을 얻을 수 있습니다.4
        - **사용자 및 도메인 전문가로부터의 피드백 적극 수용 및 반영:** 개발 과정 전반에 걸쳐 실제 사용자나 도메인 전문가로부터 적극적으로 피드백을 구하고, 이를 도메인 모델과 소프트웨어 설계에 신속하게 반영하는 반복적인 개발 사이클을 구축합니다.1
    - **인용:** "DDD embraces this reality by promoting continuous and iterative collaboration between technical experts and domain experts... The domain model and the software are continuously refined based on feedback from domain experts and users." 1
- ### **(선택적) `]`**
    
    - **개요:** 스프링 프레임워크의 일부인 스프링 데이터(Spring Data)와 같은 현대적인 프레임워크들은 리포지토리 패턴의 구현을 상당히 단순화하여, 개발자가 애그리거트의 영속성 처리를 보다 쉽게 할 수 있도록 지원합니다. 하지만, DDD의 핵심 원칙들(예: 값 객체의 불변성, 애그리거트 루트를 통한 접근 제어)과 객체-관계 매핑(ORM, Object-Relational Mapping) 기술의 본질적인 특성 및 제약사항 간의 균형을 신중하게 맞추는 것이 매우 중요합니다.16 프레임워크는 DDD 패턴 구현을 효과적으로 도울 수 있지만, 동시에 도메인 모델의 순수성을 해칠 수 있는 위험도 내포하고 있습니다. 개발자는 프레임워크가 제공하는 편리함과 DDD 원칙 사이에서 항상 의식적인 균형을 잡으려는 노력을 기울여야 합니다.
        
    - **JPA 사용 시 고려사항 16:**
        
        - **값 객체의 불변성 유지의 어려움:** JPA 엔티티로 매핑하기 위해서는 값 객체의 속성들이 `final` 키워드로 선언될 수 없거나, 기본 생성자(default constructor) 및 세터(setter) 메서드가 필요한 경우가 발생할 수 있습니다. 이는 값 객체의 핵심 원칙인 불변성을 해칠 수 있는 잠재적인 문제입니다.
        - **인공적인 ID 필요성:** 관계형 데이터베이스 테이블에 매핑하기 위해, 본래 식별자가 필요 없는 애그리거트 내부의 값 객체나 루트가 아닌 내부 엔티티에도 데이터베이스 기본 키(primary key) 역할을 하는 인공적인 ID를 추가해야 할 수도 있습니다. 이는 도메인 모델의 순수성을 다소 저해할 수 있습니다.
        - **타협점 모색:** 순수한 DDD 원칙에 입각한 도메인 모델과 JPA와 같은 ORM 기술이 가지는 현실적인 제약 사이에서 적절한 타협점을 찾는 것이 중요합니다. 때로는 완벽한 모델 순수성보다는 실용성을 우선해야 할 수도 있습니다.16
        - **대안 고려:** 만약 JPA의 제약사항이 도메인 모델의 표현력을 심각하게 저해한다고 판단될 경우, 애그리거트를 하나의 문서(document) 형태로 자연스럽게 저장하기 용이한 문서 지향 데이터베이스(예: MongoDB)를 사용하는 것을 대안으로 고려해 볼 수 있습니다. 이는 모델과 영속성 표현 간의 불일치(impedance mismatch)를 줄이는 데 도움이 될 수 있습니다.16
    - 간단한 자바 (스프링 데이터 JPA) 예시:
        
        아래는 주문(Order) 애그리거트와 이를 위한 스프링 데이터 JPA 리포지토리의 매우 간략화된 예시 코드입니다. 실제 프로젝트에서는 훨씬 더 정교한 모델링과 예외 처리, 비즈니스 로직이 포함될 것입니다.
        
        Java
        
        ```
        // src/main/java/com/example/ddd/order/domain/Order.java
        package com.example.ddd.order.domain;
        
        import org.springframework.data.domain.AbstractAggregateRoot;
        import jakarta.persistence.*;
        import java.util.ArrayList;
        import java.util.List;
        import java.util.Objects;
        
        @Entity
        @Table(name = "orders") // 데이터베이스 테이블 이름을 'orders'로 지정
        public class Order extends AbstractAggregateRoot<Order> { // 도메인 이벤트 발행을 위해 AbstractAggregateRoot 상속
        
            @Id
            @GeneratedValue(strategy = GenerationType.IDENTITY)
            private Long id;
        
            @Embedded // 고객 정보, 배송지 정보 등을 포함하는 값 객체
            private Orderer orderer; // 주문자 정보 (값 객체)
        
            @ElementCollection(fetch = FetchType.LAZY) // 값 객체 컬렉션 매핑
            @CollectionTable(name = "order_line", joinColumns = @JoinColumn(name = "order_id"))
            @OrderColumn(name = "line_idx") // 리스트 순서 유지를 위한 컬럼
            private List<OrderLine> orderLines = new ArrayList<>(); // 주문 항목들 (값 객체 리스트)
        
            @Embedded
            private Money totalAmount; // 총 주문 금액 (값 객체)
        
            @Enumerated(EnumType.STRING)
            private OrderState state; // 주문 상태 (예: PENDING, SHIPPED, CANCELLED)
        
            protected Order() { // JPA를 위한 기본 생성자
            }
        
            public Order(Orderer orderer, List<OrderLine> orderLines) {
                setOrderer(orderer);
                setOrderLines(orderLines); // 내부적으로 유효성 검사 및 totalAmount 계산
                this.state = OrderState.PENDING; // 초기 상태 설정
        
                // 주문 생성 관련 도메인 이벤트 발행 (필요시)
                // registerEvent(new OrderPlacedEvent(this.id, this.totalAmount));
            }
        
            private void setOrderer(Orderer orderer) {
                if (orderer == null) throw new IllegalArgumentException("Orderer cannot be null");
                this.orderer = orderer;
            }
        
            private void setOrderLines(List<OrderLine> orderLines) {
                if (orderLines == null |
        ```
        

| orderLines.isEmpty()) {

throw new IllegalArgumentException("Order must have at least one order line");

}

this.orderLines = new ArrayList<>(orderLines); // 방어적 복사

calculateTotalAmount();

}

```
        private void calculateTotalAmount() {
            this.totalAmount = new Money(
                orderLines.stream().mapToInt(ol -> ol.getPurchasePrice().getValue() * ol.getQuantity()).sum()
            );
        }

        // 주문 취소와 같은 비즈니스 메서드 예시
        public void cancel() {
            if (this.state!= OrderState.PENDING) { // 특정 상태에서만 취소 가능
                throw new IllegalStateException("Order cannot be cancelled in its current state: " + this.state);
            }
            this.state = OrderState.CANCELLED;
            // 주문 취소 관련 도메인 이벤트 발행 (필요시)
            // registerEvent(new OrderCancelledEvent(this.id));
        }
        
        // Getter 메서드들 (필요한 경우에만 노출)
        public Long getId() { return id; }
        public Orderer getOrderer() { return orderer; }
        public List<OrderLine> getOrderLines() { return List.copyOf(orderLines); } // 불변 리스트 반환
        public Money getTotalAmount() { return totalAmount; }
        public OrderState getState() { return state; }

        // JPA가 값 객체 컬렉션을 제대로 관리하기 위해 equals, hashCode 중요
        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null |
```

| getClass()!= o.getClass()) return false;

Order order = (Order) o;

return Objects.equals(id, order.id); // 엔티티는 ID로 비교

}

```
        @Override
        public int hashCode() {
            return Objects.hash(id);
        }
    }
    ```

    ```java
    // src/main/java/com/example/ddd/order/domain/OrderRepository.java
    package com.example.ddd.order.domain;

    import org.springframework.data.jpa.repository.JpaRepository;

    // 스프링 데이터 JPA 리포지토리 인터페이스
    public interface OrderRepository extends JpaRepository<Order, Long> {
        // 필요에 따라 사용자 정의 _쿼리 메서드 추가 가능
        // 예: List<Order> findByOrdererMemberId(MemberId memberId);
    }
    ```

    ```java
    // src/main/java/com/example/ddd/order/application/PlaceOrderService.java
    package com.example.ddd.order.application;

    import com.example.ddd.order.domain.*;
    import org.springframework.stereotype.Service;
    import org.springframework.transaction.annotation.Transactional;
    import java.util.List;

    // 애플리케이션 서비스에서 리포지토리 사용 예시
    @Service
    public class PlaceOrderService {
        private final OrderRepository orderRepository;
        // private final ProductRepository productRepository; // 실제로는 상품 정보 조회 등 필요

        public PlaceOrderService(OrderRepository orderRepository) {
            this.orderRepository = orderRepository;
        }

        @Transactional // 트랜잭션 관리
        public Long placeOrder(OrderRequest orderRequest) {
            // OrderRequest DTO로부터 Orderer, List<OrderLine> 생성 로직 (생략)
            // 예시:
            // Orderer orderer = new Orderer(new MemberId(orderRequest.getOrdererId()), orderRequest.getOrdererName());
            // List<OrderLine> orderLines = orderRequest.getOrderLines().stream()
            //.map(reqLine -> {
            // Product product = productRepository.findById(reqLine.getProductId())
            //.orElseThrow(() -> new ProductNotFoundException(reqLine.getProductId()));
            // return new OrderLine(product.getId(), product.getPrice(), reqLine.getQuantity());
            // })
            //.collect(Collectors.toList());

            // Order order = new Order(orderer, orderLines);
            // Order savedOrder = orderRepository.save(order); // 애그리거트 전체를 저장

            // return savedOrder.getId();
            return 1L; // 실제 구현에서는 생성된 주문 ID 반환
        }
    }
    ```
    *   **코드 설명:** 위 코드는 주문(`Order`)을 애그리거트 루트로 하는 간단한 예시입니다. `Order` 클래스는 주문자 정보(`Orderer` - 값 객체), 주문 항목 리스트(`OrderLine` - 값 객체), 총 주문 금액(`Money` - 값 객체), 주문 상태(`OrderState` - Enum) 등을 포함합니다. `OrderRepository`는 스프링 데이터 JPA의 `JpaRepository`를 상속받아 기본적인 CRUD 기능을 제공하며, `PlaceOrderService`라는 애플리케이션 서비스에서 이 리포지토리를 사용하여 `Order` 애그리거트를 저장(영속화)합니다. `Order` 클래스가 `AbstractAggregateRoot`를 상속하면, 애그리거트 내에서 `registerEvent()` 메서드를 통해 도메인 이벤트를 쉽게 발행할 수 있습니다 (다음 섹션에서 더 자세히 설명).
    *   **주의:** 이 예시는 매우 간략화된 것으로, 실제 프로덕션 코드에서는 값 객체의 불변성 보장, 애그리거트 루트를 통한 접근 제어 강화, 풍부한 비즈니스 로직, 예외 처리, 테스트 코드 등이 훨씬 더 정교하게 구현되어야 합니다. 특히 [16]에서 지적된 것처럼, JPA를 사용할 때 발생할 수 있는 DDD 원칙과의 타협점들을 충분히 인지하고 신중하게 설계해야 합니다.
```

- ### **(선택적) `]`**
    
    - **개요:** 스프링 프레임워크는 애그리거트 내에서 도메인 이벤트를 발행하고, 발행된 이벤트를 애플리케이션 내의 다른 컴포넌트에서 감지하여 처리하는 메커니즘을 비교적 쉽고 편리하게 구현할 수 있도록 지원합니다.23 이는 애그리거트 간의 느슨한 결합을 유지하면서도 복잡한 비즈니스 프로세스를 연계하는 데 매우 유용합니다.
        
    - **스프링 데이터의 `AbstractAggregateRoot` 활용 23:**
        
        - 도메인 이벤트를 발행하고자 하는 애그리거트 루트 클래스가 스프링 데이터에서 제공하는 `org.springframework.data.domain.AbstractAggregateRoot` 클래스를 상속받도록 합니다.
        - 애그리거트 내의 비즈니스 메서드 실행 결과로 도메인 이벤트가 발생했을 때, `registerEvent(Object event)` 메서드를 호출하여 해당 이벤트 객체를 등록합니다. 이 메서드는 `AbstractAggregateRoot`로부터 상속받은 것입니다.
        - 스프링 데이터 리포지토리의 `save()` 메서드(또는 `saveAll()`, `delete()` 등)가 호출되어 애그리거트의 변경사항이 영속화될 때, 이전에 `registerEvent()`를 통해 등록된 모든 도메인 이벤트들이 스프링의 애플리케이션 이벤트 발행 메커니즘을 통해 자동으로 발행(publish)됩니다.
        - 이렇게 발행된 도메인 이벤트는 스프링의 `@EventListener` 어노테이션이나, 트랜잭션 생명주기와 연동되는 `@TransactionalEventListener` 어노테이션이 붙은 메서드에서 감지하여 처리할 수 있습니다.
    - 간단한 자바 (스프링) 예시:
        
        아래는 주문이 생성되었을 때 OrderPlacedEvent라는 도메인 이벤트를 발행하고, 이를 처리하는 간단한 예시 코드입니다.
        
        Java
        
        ```
        // src/main/java/com/example/ddd/order/domain/OrderPlacedEvent.java
        package com.example.ddd.order.domain;
        
        import java.time.LocalDateTime;
        
        // 도메인 이벤트 정의
        public class OrderPlacedEvent {
            private final Long orderId;
            private final Money totalAmount;
            private final LocalDateTime timestamp;
        
            public OrderPlacedEvent(Long orderId, Money totalAmount) {
                this.orderId = orderId;
                this.totalAmount = totalAmount;
                this.timestamp = LocalDateTime.now();
            }
        
            // Getter 메서드들
            public Long getOrderId() { return orderId; }
            public Money getTotalAmount() { return totalAmount; }
            public LocalDateTime getTimestamp() { return timestamp; }
        }
        ```
        
        Java
        
        ```
        // 애그리거트 루트에서 이벤트 발행 (Order.java - 이전 예시에서 수정/추가)
        // package com.example.ddd.order.domain;
        // import org.springframework.data.domain.AbstractAggregateRoot;
        //...
        // public class Order extends AbstractAggregateRoot<Order> {
            //... (기존 코드)...
        
            // 생성자에서 이벤트 발행 예시
            // public Order(Orderer orderer, List<OrderLine> orderLines) {
                //... (기존 생성자 로직)...
                // this.state = OrderState.PENDING;
        
                // 주문 ID가 생성된 후 (실제로는 DB 저장 후 ID가 할당되므로, save 직후 발행이 더 적절할 수 있음)
                // 또는 비즈니스적으로 주문이 '확정'되는 시점에 이벤트 발행
                // registerEvent(new OrderPlacedEvent(this.id, this.totalAmount)); // ID가 아직 없을 수 있으므로 주의
            // }
        
            // 주문 완료 후 이벤트 발행을 위한 메서드 (예시)
            public void place() {
                //... 주문 확정 관련 로직...
                if (this.id == null) { // ID가 할당된 후에 이벤트를 발행하는 것이 일반적
                    // ID가 없는 상태에서 이벤트를 발행하면 이벤트 핸들러에서 주문을 식별하기 어려움
                    // 보통은 repository.save()가 호출된 후, 스프링이 ID를 할당하고 이벤트를 발행함.
                    // 따라서, 애그리거트 메서드 내에서 registerEvent를 호출하고,
                    // save가 호출되면 스프링이 자동으로 이벤트를 발행하는 흐름을 따름.
                }
                // 이 예시에서는 Order 객체가 생성되고 ID가 할당되었다고 가정하고 이벤트를 등록합니다.
                // 실제로는 OrderService 등에서 order.place() 호출 후 orderRepository.save(order)를 호출하면,
                // AbstractAggregateRoot에 의해 이벤트가 발행됩니다.
                if(this.id!= null) { // ID가 할당된 경우에만 이벤트 등록 (예시적 제약)
                     registerEvent(new OrderPlacedEvent(this.id, this.totalAmount));
                }
            }
        // }
        ```
        
        Java
        
        ```
        // src/main/java/com/example/ddd/order/application/OrderEventEmailNotifier.java
        package com.example.ddd.order.application;
        
        import com.example.ddd.order.domain.OrderPlacedEvent;
        import org.springframework.context.event.EventListener;
        import org.springframework.scheduling.annotation.Async;
        import org.springframework.stereotype.Component;
        import org.springframework.transaction.event.TransactionPhase;
        import org.springframework.transaction.event.TransactionalEventListener;
        
        // 도메인 이벤트 리스너 (예: 이메일 알림)
        @Component
        public class OrderEventEmailNotifier {
        
            // @EventListener // 일반적인 스프링 이벤트 리스너
            @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT) // 트랜잭션 커밋 후 이벤트 처리
            @Async // 비동기 처리 (별도 스레드에서 실행, @EnableAsync 설정 필요)
            public void handleOrderPlacedEvent(OrderPlacedEvent event) {
                System.out.println("Order placed event received for order ID: " + event.getOrderId());
                System.out.println("Total amount: " + event.getTotalAmount().getValue());
                System.out.println("Timestamp: " + event.getTimestamp());
        
                // 여기에 실제 이메일 발송 로직 구현
                // sendEmailToCustomer(event.getOrderId(), "주문이 성공적으로 완료되었습니다.");
                System.out.println("Sending order confirmation email for order " + event.getOrderId() + " (simulated)");
            }
        }
        ```
        
        - **코드 설명:** `Order` 애그리거트가 생성되거나(또는 `place()`와 같은 특정 상태 변경 메서드 호출 시) `registerEvent()`를 통해 `OrderPlacedEvent`를 등록합니다. 이후 `OrderRepository.save(order)`가 애플리케이션 서비스 등에서 호출되면, 스프링 프레임워크가 이 등록된 이벤트를 자동으로 발행합니다. `OrderEventEmailNotifier` 클래스의 `handleOrderPlacedEvent` 메서드는 `@TransactionalEventListener` 어노테이션을 통해 이 이벤트를 감지하고, 주문 완료 이메일 발송과 같은 후속 처리를 수행합니다. `@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)`를 사용하면, 주 트랜잭션이 성공적으로 커밋된 이후에만 이벤트 핸들러가 실행되도록 보장하여, 데이터 불일치 위험을 줄이는 데 도움이 됩니다. `@Async` 어노테이션은 해당 이벤트 처리를 비동기적으로 수행하도록 하여, 주 요청 처리 흐름의 응답 시간을 단축시킬 수 있습니다.
        - **주의:** 23에서 언급된 것처럼, 도메인 이벤트 발행 시점과 트랜잭션 관리에 각별히 주의해야 합니다. 만약 이벤트가 발행되었으나 주 트랜잭션이 롤백된다면, 실제로는 반영되지 않은 변경에 대한 "유령(spurious)" 이벤트가 발생하여 시스템 전체에 불일치를 야기할 수 있습니다. `@TransactionalEventListener`는 이러한 문제를 효과적으로 완화하는 데 도움을 줄 수 있는 좋은 스프링 기능입니다.

---

## **5. `# [[결론: 도메인 주도 설계를 통한 소프트웨어 가치 향상]]`**

- **DDD의 궁극적 가치:** 도메인 주도 설계는 단순히 특정 기술 스택이나 프로그래밍 패턴의 집합을 넘어서, 소프트웨어 개발 과정에서 마주하게 되는 본질적인 복잡성에 정면으로 대응하고 이를 효과적으로 관리하기 위한 심도 있는 전략이자 철학입니다.1
- **비즈니스와 기술의 정렬:** DDD의 핵심은 비즈니스 도메인에 대한 깊고 정확한 이해를 바탕으로 소프트웨어를 모델링하는 것입니다. 이를 통해 개발되는 기술적 구현물들이 실제 비즈니스의 요구사항 및 전략적 목표와 긴밀하게 정렬되도록 보장하며, 소프트웨어가 비즈니스에 실질적인 가치를 제공하도록 이끌어줍니다.1
- **지속 가능한 소프트웨어:** 잘 정의된 도메인 모델, 명확한 경계를 가진 바운디드 컨텍스트, 그리고 견고하고 의미 있는 전술적 설계 패턴들은 소프트웨어 시스템이 예기치 않은 변화에 유연하게 대응하고, 장기간에 걸쳐 안정적으로 유지보수될 수 있는 지속 가능한 아키텍처를 구축하는 데 크게 기여합니다.1
- **팀의 성장과 전문성 향상:** DDD를 성공적으로 실천하는 과정에서 개발팀은 해당 비즈니스 도메인에 대한 지식을 지속적으로 심화시키게 됩니다. 또한, 도메인 전문가와의 효과적이고 명확한 소통 능력을 향상시키며, 결과적으로 사용자의 기대를 뛰어넘는 더 높은 품질의 소프트웨어를 제공할 수 있는 전문적인 역량을 갖추게 됩니다.4
- **마무리:** 복잡하고 끊임없이 변화하는 비즈니스 도메인을 다루는 모든 소프트웨어 개발자와 아키텍트에게 도메인 주도 설계는 강력한 사고의 틀과 구체적이고 실용적인 도구들을 제공합니다. DDD의 핵심 원칙들을 프로젝트의 특성에 맞게 꾸준히 학습하고 창의적으로 적용함으로써, 우리는 기술적 부채를 줄이고, 사용자의 만족도를 높이며, 궁극적으로 비즈니스에 진정으로 의미 있는 가치를 창출하는 훌륭한 소프트웨어를 만들어 나갈 수 있을 것입니다. 도메인 주도 설계는 단순히 더 나은 코드를 작성하는 기술을 넘어, 소프트웨어 개발이라는 활동 자체를 비즈니스의 전략적 목표 달성을 위한 핵심 동력으로 전환시키는 과정으로 이해할 수 있습니다. 복잡성을 효과적으로 관리하고, 변화에 민첩하게 적응하며, 팀의 전문성을 지속적으로 향상시키는 것은 장기적으로 기업의 경쟁력 강화에 직접적으로 기여하는 전략적 투자가 될 것입니다.1

---

## **6. `# [[참고 자료]]`**

- Evans, Eric. _Domain-Driven Design: Tackling Complexity in the Heart of Software_. Addison-Wesley, 2003.
- Vernon, Vaughn. _Implementing Domain-Driven Design_. Addison-Wesley, 2013.
- Redis: Domain-Driven Design (DDD) - [https://redis.io/glossary/domain-driven-design-ddd/](https://redis.io/glossary/domain-driven-design-ddd/) 1
- RST Software: Introduction to Domain-Driven Design (DDD) Glossary - [https://www.rst.software/blog/introduction-to-domain-driven-design-ddd-glossary](https://www.rst.software/blog/introduction-to-domain-driven-design-ddd-glossary) 3
- Microsoft Azure: Tactical DDD - [https://learn.microsoft.com/en-us/azure/architecture/microservices/model/tactical-ddd](https://learn.microsoft.com/en-us/azure/architecture/microservices/model/tactical-ddd) 7
- Martin Fowler: BoundedContext -(https://martinfowler.com/bliki/BoundedContext.html) 5
- Microsoft Press Store: The Ultimate Gist of DDD - [https://www.microsoftpressstore.com/articles/article.aspx?p=3192407](https://www.microsoftpressstore.com/articles/article.aspx?p=3192407) 6
- SoftEngBook: Domain-Driven Design (DDD): A Summary - [https://softengbook.org/articles/ddd](https://softengbook.org/articles/ddd) 24
- Danilo Batista Queiroz: Eric Evans Domain-Driven Design summary (Gist) - [https://gist.github.com/danilobatistaqueiroz/f441e6a33e43b8bc47cf00d8eefd254b](https://gist.github.com/danilobatistaqueiroz/f441e6a33e43b8bc47cf00d8eefd254b) 4
- MSA School: 도메인 주도 설계(DDD) - [https://www.msaschool.io/operation/design/design-two/](https://www.msaschool.io/operation/design/design-two/) 2
- O'Reilly: What Is Domain-Driven Design? - Context Mapping - [https://www.oreilly.com/library/view/what-is-domain-driven/9781492057802/ch04.html](https://www.oreilly.com/library/view/what-is-domain-driven/9781492057802/ch04.html) 8
- DDD-Crew: Context Mapping - [https://github.com/ddd-crew/context-mapping](https://github.com/ddd-crew/context-mapping) 9
- Enterprise Craftsmanship: Entity vs Value Object: The Ultimate List of Differences - [https://enterprisecraftsmanship.com/posts/entity-vs-value-object-the-ultimate-list-of-differences/](https://enterprisecraftsmanship.com/posts/entity-vs-value-object-the-ultimate-list-of-differences/) 12
- Stack Overflow: Value vs Entity Objects (Domain Driven Design) - [https://stackoverflow.com/questions/75446/value-vs-entity-objects-domain-driven-design](https://stackoverflow.com/questions/75446/value-vs-entity-objects-domain-driven-design) 13
- Cosmic Python: The Aggregate Pattern - [https://www.cosmicpython.com/book/chapter_07_aggregate.html](https://www.cosmicpython.com/book/chapter_07_aggregate.html) 15
- Reddit r/DomainDrivenDesign: About Aggregate -(https://www.reddit.com/r/DomainDrivenDesign/comments/14uveow/about_aggregate/) 17
- Rico Fritzsche: Diving into Domain-Driven Design: Repositories, Factories, & Bounded Contexts Explained - [https://ricofritzsche.me/diving-into-domain-driven-design/](https://ricofritzsche.me/diving-into-domain-driven-design/) 20
- Opus Software: DDD Concepts and Patterns – Value Object and Factory - [https://opus.ch/ddd-concepts-and-patterns-value-object-and-factory/](https://opus.ch/ddd-concepts-and-patterns-value-object-and-factory/) 14
- Kranio: From Good to Great in DDD: Understanding Application Services Patterns in Domain-Driven Design - [https://www.kranio.io/en/blog/de-bueno-a-excelente-en-ddd-comprension-de-los-patrones-de-application-services-en-domain-driven-design---6-10](https://www.kranio.io/en/blog/de-bueno-a-excelente-en-ddd-comprension-de-los-patrones-de-application-services-en-domain-driven-design---6-10) 19
- ASP.NET Boilerplate: Domain Services -(https://aspnetboilerplate.com/Pages/Documents/Domain-Services) 18
- Dev.to: Domain Events and Event Sourcing in Domain-Driven Design - [https://dev.to/ruben_alapont/domain-events-and-event-sourcing-in-domain-driven-design-l0n](https://dev.to/ruben_alapont/domain-events-and-event-sourcing-in-domain-driven-design-l0n) 21
- Ompluscator: Practical DDD: Domain Event - [https://www.ompluscator.com/article/golang/practical-ddd-domain-event/](https://www.ompluscator.com/article/golang/practical-ddd-domain-event/) 22
- Baeldung: DDD Aggregates and @DomainEvents - [https://www.baeldung.com/spring-data-ddd](https://www.baeldung.com/spring-data-ddd) 23
- Baeldung: Persisting DDD Aggregates with Spring - [https://www.baeldung.com/spring-persisting-ddd-aggregates](https://www.baeldung.com/spring-persisting-ddd-aggregates) 16
- Mermaid.js: Examples - [https://mermaid.js.org/syntax/examples.html](https://mermaid.js.org/syntax/examples.html) 10
- Mermaid.js: Entity Relationship Diagrams -([https://mermaid.js.org/syntax/entityRelationshipDiagram.html](https://mermaid.js.org/syntax/entityRelationshipDiagram.html)) 11