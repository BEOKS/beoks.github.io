---
draft: true
tags:
  - memory
  - java
  - performance
---

참조 카운팅(Reference Counting)은 객체가 몇 번 참조되고 있는지 추적해서 메모리를 관리하는 기법이다. [[Netty]]의 [[Netty ByteBuf]]가 이 방식을 사용해서 GC 부담을 줄이고 메모리를 효율적으로 재사용한다.

---

## 왜 참조 카운팅인가?

Java는 GC(Garbage Collector)가 메모리를 자동 관리한다. 그런데 왜 Netty는 별도의 참조 카운팅을 사용할까?

### GC의 한계

1. **불확실한 해제 시점**: GC가 언제 실행될지 예측 불가
2. **STW(Stop-The-World)**: GC 동안 애플리케이션 일시 정지
3. **대용량 버퍼**: 네트워크 버퍼는 크고 수명이 짧아 GC 부담 증가

### 참조 카운팅의 이점

1. **즉시 해제**: 참조 카운트가 0이 되면 바로 메모리 반환
2. **예측 가능**: 해제 시점을 개발자가 제어
3. **풀링 가능**: 해제된 버퍼를 재사용해서 할당 비용 절감

---

## 기본 사용법

```java
// 버퍼 생성 - 참조 카운트 1
ByteBuf buf = ctx.alloc().buffer();
assert buf.refCnt() == 1;

// 참조 증가
buf.retain();
assert buf.refCnt() == 2;

// 참조 감소
buf.release();
assert buf.refCnt() == 1;

// 마지막 참조 해제
buf.release();
assert buf.refCnt() == 0;
// 이제 buf 사용 불가
```

---

## ReferenceCounted 인터페이스

참조 카운팅을 사용하는 객체는 `ReferenceCounted` 인터페이스를 구현한다.

```java
public interface ReferenceCounted {
    // 현재 참조 카운트
    int refCnt();

    // 참조 카운트 증가
    ReferenceCounted retain();
    ReferenceCounted retain(int increment);

    // 참조 카운트 감소, 0이 되면 해제
    boolean release();
    boolean release(int decrement);

    // 터치 (디버깅용)
    ReferenceCounted touch();
    ReferenceCounted touch(Object hint);
}
```

---

## 소유권 규칙

Netty에서 ByteBuf의 소유권은 명확한 규칙을 따른다.

### 규칙 1: 생성자 또는 수신자가 해제 책임

```java
// 내가 만들면 내가 해제
ByteBuf buf = ctx.alloc().buffer();
try {
    // 사용
} finally {
    buf.release();  // 내 책임
}
```

### 규칙 2: 전달하면 책임도 이전

```java
public void channelRead(ChannelHandlerContext ctx, Object msg) {
    ByteBuf buf = (ByteBuf) msg;

    // 방법 1: 다음 핸들러로 전달 (책임 이전)
    ctx.fireChannelRead(buf);
    // 이제 다음 핸들러가 해제 책임

    // 방법 2: 직접 소비 (내가 해제)
    try {
        process(buf);
    } finally {
        buf.release();
    }
}
```

### 규칙 3: 보관하려면 retain

```java
public class MessageBuffer extends ChannelInboundHandlerAdapter {
    private ByteBuf savedBuf;

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        ByteBuf buf = (ByteBuf) msg;

        // 나중에 사용하려면 retain
        buf.retain();
        this.savedBuf = buf;

        // 전달도 해야 함
        ctx.fireChannelRead(buf);
    }

    public void doSomething() {
        // 나중에 사용
        process(savedBuf);
        savedBuf.release();  // 내가 retain 했으니 내가 release
        savedBuf = null;
    }
}
```

---

## SimpleChannelInboundHandler의 자동 해제

`SimpleChannelInboundHandler`는 메시지를 자동으로 해제해준다.

```java
public class MyHandler extends SimpleChannelInboundHandler<ByteBuf> {

    @Override
    protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) {
        // msg 사용
        // channelRead0 리턴 후 자동으로 msg.release() 호출됨
    }
}
```

자동 해제를 원하지 않으면:

```java
public class MyHandler extends SimpleChannelInboundHandler<ByteBuf> {

    public MyHandler() {
        super(false);  // 자동 해제 비활성화
    }

    @Override
    protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) {
        // 직접 해제하거나 전달
        ctx.fireChannelRead(msg.retain());
    }
}
```

---

## 파생 버퍼의 참조 관계

`slice()`, `duplicate()`, `retainedSlice()` 등으로 만든 파생 버퍼는 원본과 메모리를 공유한다.

### 비유지 파생 (Non-retained)

```java
ByteBuf original = ctx.alloc().buffer();  // refCnt: 1
ByteBuf slice = original.slice();          // 새로운 참조 카운트 없음

// slice는 original이 살아있는 동안만 유효
// slice.release() 호출하면 안 됨!
original.release();  // 둘 다 무효화
```

### 유지 파생 (Retained)

```java
ByteBuf original = ctx.alloc().buffer();       // refCnt: 1
ByteBuf slice = original.retainedSlice();      // original refCnt: 2

// slice는 독립적으로 관리
slice.release();   // original refCnt: 1
original.release();  // original refCnt: 0
```

---

## 메모리 누수 탐지

Netty는 참조 카운팅 버그를 찾기 위한 누수 탐지 기능을 제공한다.

### 활성화 방법

```java
// JVM 옵션
-Dio.netty.leakDetectionLevel=PARANOID

// 프로그램에서
ResourceLeakDetector.setLevel(Level.PARANOID);
```

### 탐지 레벨

| 레벨 | 설명 | 성능 영향 |
|-----|------|---------|
| DISABLED | 탐지 안 함 | 없음 |
| SIMPLE | 1% 샘플링 (기본값) | 최소 |
| ADVANCED | 1% 샘플링 + 접근 기록 | 중간 |
| PARANOID | 100% 추적 | 높음 |

### 누수 발견 시 로그

```
LEAK: ByteBuf.release() was not called before it's garbage-collected.
Recent access records:
#1:
    io.netty.buffer.AdvancedLeakAwareByteBuf.writeBytes(...)
    com.example.MyHandler.channelRead(...)
    ...
```

---

## 흔한 실수

### 1. 해제 누락

```java
public void channelRead(ChannelHandlerContext ctx, Object msg) {
    ByteBuf buf = (ByteBuf) msg;
    if (invalid(buf)) {
        return;  // 해제 없이 리턴! 누수 발생
    }
    ctx.fireChannelRead(buf);
}

// 수정
public void channelRead(ChannelHandlerContext ctx, Object msg) {
    ByteBuf buf = (ByteBuf) msg;
    if (invalid(buf)) {
        buf.release();  // 해제 후 리턴
        return;
    }
    ctx.fireChannelRead(buf);
}
```

### 2. 이중 해제

```java
ByteBuf buf = ctx.alloc().buffer();
ctx.writeAndFlush(buf);  // writeAndFlush가 해제함
buf.release();  // 이중 해제! IllegalReferenceCountException
```

### 3. 해제 후 사용

```java
ByteBuf buf = ctx.alloc().buffer();
buf.release();
buf.writeByte(1);  // IllegalReferenceCountException
```

---

## ReferenceCountUtil 헬퍼

```java
// 안전한 해제 (null 체크, 타입 체크 포함)
ReferenceCountUtil.release(msg);

// 성공적으로 해제되면 true
boolean released = ReferenceCountUtil.release(msg);

// 여러 번 해제
ReferenceCountUtil.release(msg, 2);

// retain
ReferenceCountUtil.retain(msg);

// ReferenceCounted가 아니면 무시됨
ReferenceCountUtil.release("not a bytebuf");  // 아무 일도 안 함
```

---

## References

- [[Netty]]
- [[Netty ByteBuf]]
- [[Zero-Copy]]
