자바에서 모듈 시스템은 자바 9 버전에서 도입된 기능으로, [[패키지의 한계와 문제점]]을 보완해 애플리케이션을 더 모듈화하고 구조화할 수 있게 해줍니다. 모듈 시스템을 사용하면 응용 프로그램을 여러 모듈로 분할하여 각 모듈 간의 의존성을 명확하게 정의하고, 캡슐화를 강화하며, 런타임에 불필요한 모듈을 제거하여 애플리케이션의 크기를 줄일 수 있습니다.

아래에서는 자바에서 모듈을 구현하는 방법에 대해 단계별로 자세히 설명하겠습니다.

---

## 1. 모듈의 개념 이해

모듈은 관련된 패키지와 리소스의 그룹으로, `module-info.java` 파일을 통해 그 모듈의 종속성(의존성)과 공개 API를 정의합니다.

- **모듈 선언**: 각 모듈은 고유한 이름을 가지며, `module-info.java` 파일에서 선언됩니다.
- **의존성 관리**: 모듈은 다른 모듈에 대한 의존성을 명시적으로 선언해야 합니다.
- **캡슐화 강화**: 모듈은 공개(export)할 패키지를 명시적으로 선언하며, 그렇지 않은 패키지는 모듈 외부에 노출되지 않습니다.

---

## 2. 모듈 생성 단계

### 2.1 프로젝트 구조 설정

먼저, 모듈을 구현할 프로젝트의 디렉토리 구조를 설정합니다. 예를 들어, 두 개의 모듈 `com.example.modulea`와 `com.example.moduleb`가 있다고 가정하겠습니다.

```
my-app/
├── modulea/
│   ├── src/
│   │   └── com/example/modulea/HelloModuleA.java
│   └── module-info.java
└── moduleb/
    ├── src/
    │   └── com/example/moduleb/HelloModuleB.java
    └── module-info.java
```

### 2.2 `module-info.java` 파일 작성

각 모듈의 루트 디렉토리에 `module-info.java` 파일을 생성하고 모듈을 선언합니다.

**modulea/module-info.java**:

```java
module com.example.modulea {
    exports com.example.modulea;
}
```

- `exports` 키워드를 사용하여 모듈 외부로 공개할 패키지를 명시합니다.

**moduleb/module-info.java**:

```java
module com.example.moduleb {
    requires com.example.modulea;
    exports com.example.moduleb;
}
```

- `requires` 키워드를 사용하여 `com.example.moduleb` 모듈이 `com.example.modulea` 모듈에 의존함을 명시합니다.
- `exports`로 자신의 패키지를 공개합니다.

### 2.3 클래스 작성

**modulea/src/com/example/modulea/HelloModuleA.java**:

```java
package com.example.modulea;

public class HelloModuleA {
    public void sayHello() {
        System.out.println("Hello from Module A!");
    }
}
```

**moduleb/src/com/example/moduleb/HelloModuleB.java**:

```java
package com.example.moduleb;

import com.example.modulea.HelloModuleA;

public class HelloModuleB {
    public void sayHello() {
        HelloModuleA moduleA = new HelloModuleA();
        moduleA.sayHello();
        System.out.println("Hello from Module B!");
    }
}
```

- `moduleb`에서 `modulea`의 클래스를 사용하려면 `requires`로 의존성을 선언하고, `modulea`에서는 해당 패키지를 `exports`해야 합니다.

---

## 3. 모듈 컴파일 및 실행

### 3.1 컴파일

터미널에서 각 모듈을 컴파일합니다.

**1단계: 출력 디렉토리 생성**

```
mkdir -p out/modulea
mkdir -p out/moduleb
```

**2단계: modulea 컴파일**

```
javac -d out/modulea modulea/module-info.java modulea/src/com/example/modulea/HelloModuleA.java
```

**3단계: moduleb 컴파일**

```
javac --module-path out -d out/moduleb moduleb/module-info.java moduleb/src/com/example/moduleb/HelloModuleB.java
```

- `--module-path` 옵션은 의존하는 모듈의 위치를 지정합니다.

### 3.2 실행

모듈을 실행하려면 `java` 명령어의 `--module` 옵션을 사용합니다.

**moduleb 실행**

```
java --module-path out -m com.example.moduleb/com.example.moduleb.HelloModuleB
```

- `-m` 옵션은 `모듈명/클래스명` 형식으로 메인 클래스를 지정합니다.

**HelloModuleB.java에 main 메소드 추가**

실행하려면 `main` 메소드가 필요하므로 `HelloModuleB.java`를 수정합니다.

```java
package com.example.moduleb;

import com.example.modulea.HelloModuleA;

public class HelloModuleB {
    public static void main(String[] args) {
        HelloModuleB hello = new HelloModuleB();
        hello.sayHello();
    }

    public void sayHello() {
        HelloModuleA moduleA = new HelloModuleA();
        moduleA.sayHello();
        System.out.println("Hello from Module B!");
    }
}
```

다시 컴파일 후 실행합니다.

**컴파일**

```
javac --module-path out -d out/moduleb moduleb/module-info.java moduleb/src/com/example/moduleb/HelloModuleB.java
```

**실행**

```
java --module-path out -m com.example.moduleb/com.example.moduleb.HelloModuleB
```

**출력 결과**

```
Hello from Module A!
Hello from Module B!
```

---

## 4. 모듈 시스템의 주요 요소

### 4.1 `requires` 키워드

- 다른 모듈에 대한 의존성을 선언합니다.
- 예: `requires com.example.modulea;`

### 4.2 `exports` 키워드

- 모듈 외부로 공개할 패키지를 선언합니다.
- 예: `exports com.example.modulea;`

### 4.3 `opens` 키워드

- 리플렉션 등을 통해 런타임에 패키지의 모든 요소에 접근할 수 있게 합니다.
- 주로 프레임워크나 라이브러리에서 리플렉션을 사용하는 경우에 필요합니다.
- 예: `opens com.example.modulea;`

### 4.4 `provides`와 `uses` 키워드

- 서비스 프로바이더와 컨슈머를 선언할 때 사용합니다.
- 서비스 로더 메커니즘과 함께 동작합니다.

**예시**:

- 서비스 인터페이스를 제공하는 모듈에서:

```java
exports com.example.service;
provides com.example.service.MyService with com.example.service.impl.MyServiceImpl;
```

- 서비스를 사용하는 모듈에서:

```java
requires com.example.service;
uses com.example.service.MyService;
```

---

## 5. 추가 사항

### 5.1 자동 모듈

- 기존의 모듈화되지 않은 JAR를 모듈로 취급할 수 있습니다.
- `module-info.java`가 없는 경우 JAR의 이름이 모듈 이름이 됩니다.

### 5.2 모듈 이름 규칙

- 모듈 이름은 유니크해야 하며, 일반적으로 도메인 네임을 반전시켜 사용합니다.
- 예: `com.example.modulea`

### 5.3 전이적 의존성 (`requires transitive`)

- 모듈 B가 모듈 A를 `requires`하고, 모듈 C가 모듈 B를 `requires`할 때, 모듈 C가 모듈 A의 공개 API에 접근하려면 모듈 B에서 `requires transitive com.example.modulea;`로 선언해야 합니다.

---

## 6. IDE를 통한 모듈 관리

이클립스(Eclipse), 인텔리J(IntelliJ IDEA) 등 현대의 IDE들은 자바 모듈 시스템을 지원합니다.

- **프로젝트 생성 시 모듈 옵션 선택**: 새로운 모듈 프로젝트를 생성하거나 기존 프로젝트에 모듈 정보를 추가할 수 있습니다.
- **`module-info.java` 자동 생성 및 편집 지원**: IDE에서 모듈과 관련된 구문을 자동 완성하고 오류를 검출해 줍니다.
- **빌드 및 실행 설정**: 모듈 경로와 의존성을 IDE 설정에서 관리할 수 있습니다.

---

## 7. 요약

자바의 모듈 시스템은 대규모 애플리케이션을 보다 효율적으로 관리하고, 캡슐화를 강화하며, 의존성을 명확하게 정의할 수 있게 해주는 강력한 도구입니다. 이를 구현하기 위해서는:

1. 프로젝트를 모듈 단위로 구조화하고, 각 모듈에 `module-info.java` 파일을 생성합니다.
2. 필요한 의존성은 `requires`로, 외부에 공개할 패키지는 `exports`로 선언합니다.
3. 모듈 간의 의존성과 공개 범위를 명확히 관리하여 코드의 안정성과 보안을 향상시킵니다.

자바 모듈 시스템을 제대로 활용하면 애플리케이션의 유지 보수성과 확장성이 크게 향상됩니다.